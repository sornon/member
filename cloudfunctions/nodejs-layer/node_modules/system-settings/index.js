'use strict';

const {
  COLLECTIONS,
  normalizeBackgroundId,
  getDefaultBackgroundId,
  normalizeBackgroundCatalog
} = require('common-config');

const SYSTEM_SETTINGS_COLLECTION = COLLECTIONS.SYSTEM_SETTINGS;
const FEATURE_TOGGLE_DOC_ID = 'feature_toggles';

const DEFAULT_CACHE_VERSIONS = Object.freeze({
  global: 1,
  menu: 1
});

const DEFAULT_HOME_ENTRIES = Object.freeze({
  activities: true,
  mall: true,
  secretRealm: false,
  rights: true,
  pvp: false,
  trading: false
});

const DEFAULT_GUILD_TEAM_SETTINGS = Object.freeze({
  enabled: false,
  baseEnemyPower: 1500,
  rewardMultiplier: 1,
  raidCooldownMs: 10 * 1000
});

const DEFAULT_GUILD_BOSS_SETTINGS = Object.freeze({
  enabled: true,
  dailyAttempts: 3,
  cooldownMs: 5 * 60 * 1000,
  maxRounds: 20,
  rotation: [
    { bossId: 'ancient_spirit_tree', level: 65 }
  ]
});

const DEFAULT_GUILD_RISK_CONTROL_SETTINGS = Object.freeze({
  enabled: true,
  loggerTag: 'guild',
  actions: {
    donate: { cooldownMs: 10 * 1000, dailyLimit: 20 },
    'tasks.claim': { cooldownMs: 10 * 1000, dailyLimit: 10 },
    'boss.challenge': { cooldownMs: 10 * 1000, dailyLimit: 6 },
    bossChallenge: { cooldownMs: 10 * 1000, dailyLimit: 6 }
  },
  abuseDetection: {
    enabled: true,
    windowMs: 60 * 1000,
    threshold: 15
  }
});

const DEFAULT_GUILD_SETTINGS = Object.freeze({
  enabled: true,
  maxMembers: 30,
  secret: 'guild_default_secret',
  leaderboardCacheTtlMs: 5 * 60 * 1000,
  schemaVersion: 1,
  teamBattle: DEFAULT_GUILD_TEAM_SETTINGS,
  boss: DEFAULT_GUILD_BOSS_SETTINGS,
  riskControl: DEFAULT_GUILD_RISK_CONTROL_SETTINGS
});

const DEFAULT_RAGE_SETTINGS = Object.freeze({
  start: 0,
  turnGain: 20,
  basicAttackGain: 10,
  damageTakenMultiplier: 1.5,
  critGain: 1,
  critTakenGain: 1
});

const DEFAULT_GAME_PARAMETERS = Object.freeze({
  rage: DEFAULT_RAGE_SETTINGS
});

const DEFAULT_EQUIPMENT_ENHANCEMENT = Object.freeze({
  guaranteedLevel: 3,
  decayPerLevel: 10,
  maxLevel: 10
});

const DEFAULT_GLOBAL_BACKGROUND = Object.freeze({
  enabled: false,
  backgroundId: '',
  animated: false
});

function cloneGlobalBackgroundCatalog(list = []) {
  const normalized = normalizeBackgroundCatalog(list);
  return normalized.map((entry) => ({ ...entry }));
}

function toCacheVersionNumber(value, fallback = 1) {
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) {
    const fallbackNumeric = Number(fallback);
    if (!Number.isFinite(fallbackNumeric)) {
      return 1;
    }
    return Math.max(0, Math.floor(fallbackNumeric));
  }
  if (numeric >= Number.MAX_SAFE_INTEGER) {
    return 1;
  }
  return Math.max(0, Math.floor(numeric));
}

function normalizeCacheVersions(raw) {
  const source = raw && typeof raw === 'object' ? raw : {};
  const keys = new Set([
    ...Object.keys(DEFAULT_CACHE_VERSIONS),
    ...Object.keys(source)
  ]);
  const versions = {};
  keys.forEach((key) => {
    versions[key] = toCacheVersionNumber(
      source[key],
      DEFAULT_CACHE_VERSIONS[key] || 1
    );
  });
  return versions;
}

function cloneCacheVersions(raw = DEFAULT_CACHE_VERSIONS) {
  const normalized = normalizeCacheVersions(raw);
  return { ...normalized };
}

function toBoolean(value, fallback = false) {
  if (typeof value === 'boolean') {
    return value;
  }
  if (typeof value === 'number') {
    if (!Number.isFinite(value)) {
      return fallback;
    }
    return value !== 0;
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) {
      return fallback;
    }
    const normalized = trimmed.toLowerCase();
    if (['false', '0', 'off', 'no', '关闭', '否', '禁用', '停用', 'disabled'].includes(normalized)) {
      return false;
    }
    if (['true', '1', 'on', 'yes', '开启', '启用', 'enable', 'enabled'].includes(normalized)) {
      return true;
    }
    return fallback;
  }
  if (value == null) {
    return fallback;
  }
  if (typeof value.valueOf === 'function') {
    try {
      const primitive = value.valueOf();
      if (primitive !== value) {
        return toBoolean(primitive, fallback);
      }
    } catch (error) {
      return fallback;
    }
  }
  return Boolean(value);
}

function normalizeHomeEntries(raw) {
  const source = raw && typeof raw === 'object' ? raw : {};
  const normalized = {};
  Object.keys(DEFAULT_HOME_ENTRIES).forEach((key) => {
    normalized[key] = toBoolean(source[key], DEFAULT_HOME_ENTRIES[key]);
  });
  return normalized;
}

function cloneHomeEntries(raw = DEFAULT_HOME_ENTRIES) {
  const normalized = normalizeHomeEntries(raw);
  return { ...normalized };
}

function normalizeGuildTeamSettings(raw = {}) {
  const source = raw && typeof raw === 'object' ? raw : {};
  const enabled = toBoolean(source.enabled, DEFAULT_GUILD_TEAM_SETTINGS.enabled);
  const baseEnemyPower = clampInt(source.baseEnemyPower, 500, 500000, DEFAULT_GUILD_TEAM_SETTINGS.baseEnemyPower);
  const rewardMultiplier = Number.isFinite(Number(source.rewardMultiplier))
    ? Math.max(0.1, Number(source.rewardMultiplier))
    : DEFAULT_GUILD_TEAM_SETTINGS.rewardMultiplier;
  const raidCooldownMs = clampInt(
    source.raidCooldownMs,
    1000,
    60 * 60 * 1000,
    DEFAULT_GUILD_TEAM_SETTINGS.raidCooldownMs
  );
  return {
    enabled,
    baseEnemyPower,
    rewardMultiplier,
    raidCooldownMs
  };
}

function normalizeGuildBossSettings(raw = {}) {
  const source = raw && typeof raw === 'object' ? raw : {};
  const enabled = toBoolean(source.enabled, DEFAULT_GUILD_BOSS_SETTINGS.enabled);
  const dailyAttempts = clampInt(source.dailyAttempts, 1, 20, DEFAULT_GUILD_BOSS_SETTINGS.dailyAttempts);
  const cooldownMs = clampInt(source.cooldownMs, 10 * 1000, 24 * 60 * 60 * 1000, DEFAULT_GUILD_BOSS_SETTINGS.cooldownMs);
  const maxRounds = clampInt(source.maxRounds, 5, 40, DEFAULT_GUILD_BOSS_SETTINGS.maxRounds);
  const rotation = Array.isArray(source.rotation) && source.rotation.length
    ? source.rotation
        .map((entry) => {
          if (!entry || typeof entry !== 'object') {
            return null;
          }
          const bossId = typeof entry.bossId === 'string' && entry.bossId.trim() ? entry.bossId.trim() : null;
          const level = clampInt(entry.level, 1, 200, 60);
          if (!bossId) {
            return null;
          }
          return { bossId, level };
        })
        .filter(Boolean)
    : DEFAULT_GUILD_BOSS_SETTINGS.rotation;
  return {
    enabled,
    dailyAttempts,
    cooldownMs,
    maxRounds,
    rotation
  };
}

function normalizeRiskActionConfig(raw = {}, fallback = {}) {
  const source = raw && typeof raw === 'object' ? raw : {};
  const fallbackSource = fallback && typeof fallback === 'object' ? fallback : {};
  const cooldownMs = clampInt(
    source.cooldownMs,
    1000,
    24 * 60 * 60 * 1000,
    clampInt(fallbackSource.cooldownMs, 1000, 24 * 60 * 60 * 1000, 10 * 1000)
  );
  const dailyLimit = clampInt(
    source.dailyLimit,
    0,
    100000,
    clampInt(fallbackSource.dailyLimit, 0, 100000, 0)
  );
  return {
    cooldownMs,
    dailyLimit
  };
}

function normalizeGuildRiskControlSettings(raw = {}) {
  const source = raw && typeof raw === 'object' ? raw : {};
  const base = DEFAULT_GUILD_RISK_CONTROL_SETTINGS;
  const enabled = toBoolean(source.enabled, base.enabled);
  const loggerTag =
    typeof source.loggerTag === 'string' && source.loggerTag.trim()
      ? source.loggerTag.trim()
      : base.loggerTag;
  const actionSource = source.actions && typeof source.actions === 'object' ? source.actions : {};
  const actionKeys = new Set([
    ...Object.keys(base.actions || {}),
    ...Object.keys(actionSource)
  ]);
  const actions = {};
  actionKeys.forEach((key) => {
    const fallback = base.actions && base.actions[key] ? base.actions[key] : {};
    actions[key] = normalizeRiskActionConfig(actionSource[key], fallback);
  });
  const abuseFallback = base.abuseDetection || {};
  const abuseSource = source.abuseDetection && typeof source.abuseDetection === 'object' ? source.abuseDetection : {};
  const abuseDetection = {
    enabled: toBoolean(abuseSource.enabled, abuseFallback.enabled !== undefined ? abuseFallback.enabled : true),
    windowMs: clampInt(
      abuseSource.windowMs,
      1000,
      24 * 60 * 60 * 1000,
      clampInt(abuseFallback.windowMs, 1000, 24 * 60 * 60 * 1000, 60 * 1000)
    ),
    threshold: clampInt(abuseSource.threshold, 1, 100000, clampInt(abuseFallback.threshold, 1, 100000, 15))
  };
  return {
    enabled,
    loggerTag,
    actions,
    abuseDetection
  };
}

function normalizeGuildSettings(raw = {}) {
  const source = raw && typeof raw === 'object' ? raw : {};
  const enabled = toBoolean(source.enabled, DEFAULT_GUILD_SETTINGS.enabled);
  const maxMembers = clampInt(source.maxMembers, 5, 200, DEFAULT_GUILD_SETTINGS.maxMembers);
  const secret =
    typeof source.secret === 'string' && source.secret.trim()
      ? source.secret.trim()
      : DEFAULT_GUILD_SETTINGS.secret;
  const leaderboardCacheTtlMs = clampInt(
    source.leaderboardCacheTtlMs,
    30 * 1000,
    6 * 60 * 60 * 1000,
    DEFAULT_GUILD_SETTINGS.leaderboardCacheTtlMs
  );
  const schemaVersion = clampInt(source.schemaVersion, 1, 100, DEFAULT_GUILD_SETTINGS.schemaVersion);
  const teamBattle = normalizeGuildTeamSettings(source.teamBattle || source.team || {});
  const boss = normalizeGuildBossSettings(source.boss || source.bossRaid || {});
  const riskControl = normalizeGuildRiskControlSettings(source.riskControl || source.risk || {});
  return {
    enabled,
    maxMembers,
    secret,
    leaderboardCacheTtlMs,
    schemaVersion,
    teamBattle,
    boss,
    riskControl
  };
}

function cloneGuildSettings(raw = DEFAULT_GUILD_SETTINGS) {
  const normalized = normalizeGuildSettings(raw);
  return {
    ...normalized,
    teamBattle: { ...normalized.teamBattle },
    boss: {
      ...normalized.boss,
      rotation: Array.isArray(normalized.boss.rotation)
        ? normalized.boss.rotation.map((entry) => ({ ...entry }))
        : []
    },
    riskControl: {
      ...normalized.riskControl,
      actions: Object.entries(normalized.riskControl.actions || {}).reduce((acc, [key, value]) => {
        acc[key] = { ...value };
        return acc;
      }, {}),
      abuseDetection: { ...normalized.riskControl.abuseDetection }
    }
  };
}

function toNumber(value) {
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : NaN;
}

function clampNonNegative(value) {
  return Math.max(0, value);
}

function clampInt(value, min, max, fallback) {
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) {
    return fallback;
  }
  const clamped = Math.max(min, Math.min(max, Math.floor(numeric)));
  return clamped;
}

function normalizeRageSettings(raw) {
  const base = raw && typeof raw === 'object' ? raw : {};
  const normalized = {
    start: clampNonNegative(toNumber(base.start))
  };
  if (Number.isNaN(normalized.start)) {
    normalized.start = DEFAULT_RAGE_SETTINGS.start;
  }

  normalized.turnGain = clampNonNegative(toNumber(base.turnGain));
  if (Number.isNaN(normalized.turnGain)) {
    normalized.turnGain = DEFAULT_RAGE_SETTINGS.turnGain;
  }

  normalized.basicAttackGain = clampNonNegative(toNumber(base.basicAttackGain));
  if (Number.isNaN(normalized.basicAttackGain)) {
    normalized.basicAttackGain = DEFAULT_RAGE_SETTINGS.basicAttackGain;
  }

  const damageTakenMultiplier = toNumber(base.damageTakenMultiplier);
  normalized.damageTakenMultiplier = Number.isNaN(damageTakenMultiplier)
    ? DEFAULT_RAGE_SETTINGS.damageTakenMultiplier
    : Math.max(0, damageTakenMultiplier);

  const critGain = toNumber(base.critGain);
  normalized.critGain = Number.isNaN(critGain)
    ? DEFAULT_RAGE_SETTINGS.critGain
    : clampNonNegative(critGain);

  const critTakenGain = toNumber(base.critTakenGain);
  normalized.critTakenGain = Number.isNaN(critTakenGain)
    ? DEFAULT_RAGE_SETTINGS.critTakenGain
    : clampNonNegative(critTakenGain);

  return normalized;
}

function normalizeGameParameters(raw) {
  const base = raw && typeof raw === 'object' ? raw : {};
  return {
    rage: normalizeRageSettings(base.rage)
  };
}

function normalizeEquipmentEnhancementConfig(raw) {
  const base = raw && typeof raw === 'object' ? raw : {};
  const maxLevel = clampInt(
    Object.prototype.hasOwnProperty.call(base, 'maxLevel') ? base.maxLevel : DEFAULT_EQUIPMENT_ENHANCEMENT.maxLevel,
    1,
    99,
    DEFAULT_EQUIPMENT_ENHANCEMENT.maxLevel
  );
  let guaranteedLevel = clampInt(
    base.guaranteedLevel,
    0,
    maxLevel,
    Math.min(DEFAULT_EQUIPMENT_ENHANCEMENT.guaranteedLevel, maxLevel)
  );
  const decayPerLevel = clampInt(
    base.decayPerLevel,
    0,
    100,
    DEFAULT_EQUIPMENT_ENHANCEMENT.decayPerLevel
  );
  if (guaranteedLevel > maxLevel) {
    guaranteedLevel = maxLevel;
  }
  return {
    guaranteedLevel,
    decayPerLevel,
    maxLevel
  };
}

function normalizeGlobalBackground(raw) {
  const base = raw && typeof raw === 'object' ? raw : {};
  const enabled = toBoolean(base.enabled, DEFAULT_GLOBAL_BACKGROUND.enabled);
  const desiredId = normalizeBackgroundId(base.backgroundId || '');
  const backgroundId = desiredId || (enabled ? getDefaultBackgroundId() : '');
  const animated = toBoolean(base.animated, DEFAULT_GLOBAL_BACKGROUND.animated);
  return {
    enabled,
    backgroundId,
    animated
  };
}

function cloneGlobalBackground(config = DEFAULT_GLOBAL_BACKGROUND) {
  const normalized = normalizeGlobalBackground(config);
  return {
    enabled: normalized.enabled,
    backgroundId: normalized.backgroundId,
    animated: normalized.animated
  };
}

function cloneRageSettings(settings = DEFAULT_RAGE_SETTINGS) {
  const normalized = normalizeRageSettings(settings);
  return {
    start: normalized.start,
    turnGain: normalized.turnGain,
    basicAttackGain: normalized.basicAttackGain,
    damageTakenMultiplier: normalized.damageTakenMultiplier,
    critGain: normalized.critGain,
    critTakenGain: normalized.critTakenGain
  };
}

function cloneGameParameters(parameters = DEFAULT_GAME_PARAMETERS) {
  const normalized = normalizeGameParameters(parameters);
  return {
    rage: cloneRageSettings(normalized.rage)
  };
}

function cloneEquipmentEnhancementConfig(config = DEFAULT_EQUIPMENT_ENHANCEMENT) {
  const normalized = normalizeEquipmentEnhancementConfig(config);
  return {
    guaranteedLevel: normalized.guaranteedLevel,
    decayPerLevel: normalized.decayPerLevel,
    maxLevel: normalized.maxLevel
  };
}

function serializeRageSettings(settings) {
  const normalized = normalizeRageSettings(settings);
  return {
    start: normalized.start,
    turnGain: normalized.turnGain,
    basicAttackGain: normalized.basicAttackGain,
    damageTakenMultiplier: normalized.damageTakenMultiplier,
    critGain: normalized.critGain,
    critTakenGain: normalized.critTakenGain
  };
}

function serializeGameParameters(parameters) {
  const normalized = normalizeGameParameters(parameters);
  return {
    rage: serializeRageSettings(normalized.rage)
  };
}

function serializeGlobalBackground(config) {
  return cloneGlobalBackground(config);
}

function serializeEquipmentEnhancementConfig(config) {
  return cloneEquipmentEnhancementConfig(config);
}

function incrementCacheVersionValue(value) {
  const numeric = Number(value);
  if (!Number.isFinite(numeric) || numeric < 0) {
    return 1;
  }
  if (numeric >= Number.MAX_SAFE_INTEGER) {
    return 1;
  }
  return Math.max(0, Math.floor(numeric)) + 1;
}

function resolveRageSettingsSource(documentData) {
  if (!documentData || typeof documentData !== 'object') {
    return null;
  }
  if (documentData.gameParameters && typeof documentData.gameParameters === 'object') {
    return documentData.gameParameters.rage || null;
  }
  if (documentData.rageSettings) {
    return documentData.rageSettings;
  }
  return null;
}

function resolveGameParametersFromDocument(documentData) {
  const rageSource = resolveRageSettingsSource(documentData);
  if (!rageSource) {
    return cloneGameParameters(DEFAULT_GAME_PARAMETERS);
  }
  return {
    rage: normalizeRageSettings(rageSource)
  };
}

function resolveEquipmentEnhancementFromDocument(documentData) {
  if (!documentData || typeof documentData !== 'object') {
    return cloneEquipmentEnhancementConfig(DEFAULT_EQUIPMENT_ENHANCEMENT);
  }
  if (Object.prototype.hasOwnProperty.call(documentData, 'equipmentEnhancement')) {
    return cloneEquipmentEnhancementConfig(documentData.equipmentEnhancement);
  }
  return cloneEquipmentEnhancementConfig(DEFAULT_EQUIPMENT_ENHANCEMENT);
}

function buildResourceConfigOverrides(parameters) {
  const normalized = normalizeGameParameters(parameters);
  return {
    startValue: normalized.rage.start,
    turnGain: normalized.rage.turnGain,
    basicAttackGain: normalized.rage.basicAttackGain,
    damageTakenGain: normalized.rage.damageTakenMultiplier,
    critGain: normalized.rage.critGain,
    critTakenGain: normalized.rage.critTakenGain
  };
}

module.exports = {
  SYSTEM_SETTINGS_COLLECTION,
  FEATURE_TOGGLE_DOC_ID,
  DEFAULT_CACHE_VERSIONS,
  DEFAULT_HOME_ENTRIES,
  DEFAULT_RAGE_SETTINGS,
  DEFAULT_GAME_PARAMETERS,
  DEFAULT_EQUIPMENT_ENHANCEMENT,
  DEFAULT_GLOBAL_BACKGROUND,
  DEFAULT_GUILD_SETTINGS,
  DEFAULT_GUILD_BOSS_SETTINGS,
  DEFAULT_GUILD_RISK_CONTROL_SETTINGS,
  normalizeCacheVersions,
  normalizeHomeEntries,
  normalizeGuildSettings,
  normalizeGuildTeamSettings,
  normalizeGuildBossSettings,
  normalizeGuildRiskControlSettings,
  normalizeRageSettings,
  normalizeGameParameters,
  normalizeEquipmentEnhancementConfig,
  normalizeGlobalBackground,
  incrementCacheVersionValue,
  serializeRageSettings,
  serializeGameParameters,
  serializeEquipmentEnhancementConfig,
  serializeGlobalBackground,
  resolveGameParametersFromDocument,
  resolveEquipmentEnhancementFromDocument,
  buildResourceConfigOverrides,
  cloneCacheVersions,
  cloneHomeEntries,
  cloneGuildSettings,
  cloneRageSettings,
  cloneGameParameters,
  cloneEquipmentEnhancementConfig,
  cloneGlobalBackground,
  cloneGlobalBackgroundCatalog
};
