'use strict';

function isPlainObject(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }
  return Object.prototype.toString.call(value) === '[object Object]';
}

function clone(value) {
  if (Array.isArray(value)) {
    return value.map((item) => clone(item));
  }
  if (isPlainObject(value)) {
    const result = {};
    Object.keys(value).forEach((key) => {
      result[key] = clone(value[key]);
    });
    return result;
  }
  return value;
}

function normalizeTimeline(timeline) {
  if (!Array.isArray(timeline)) {
    return [];
  }
  return timeline
    .filter((entry) => entry && typeof entry === 'object')
    .map((entry) => clone(entry));
}

function normalizeLegacyRounds(legacy) {
  if (!Array.isArray(legacy)) {
    return [];
  }
  return legacy
    .filter((entry) => entry !== undefined && entry !== null)
    .map((entry) => (isPlainObject(entry) ? clone(entry) : entry));
}

function normalizeParticipants(participants) {
  if (!participants || typeof participants !== 'object') {
    return { player: null, opponent: null };
  }
  const normalized = {};
  Object.keys(participants).forEach((key) => {
    normalized[key] = clone(participants[key]);
  });

  const resolveParticipant = (aliases) => {
    for (let i = 0; i < aliases.length; i += 1) {
      const alias = aliases[i];
      if (alias && normalized[alias]) {
        return normalized[alias];
      }
    }
    return null;
  };

  const player = resolveParticipant(['player', 'self', 'ally', 'member', 'actor']);
  const opponent = resolveParticipant(['opponent', 'enemy', 'foe', 'target', 'rival']);

  normalized.player = player ? player : normalized.player || null;
  normalized.opponent = opponent ? opponent : normalized.opponent || null;

  if (!normalized.enemy && normalized.opponent) {
    normalized.enemy = normalized.opponent;
  }

  return normalized;
}

function normalizeMetadata(metadata, mode, seed) {
  const normalized = isPlainObject(metadata) ? clone(metadata) : {};
  const resolvedMode = typeof mode === 'string' && mode.trim()
    ? mode.trim()
    : typeof normalized.mode === 'string' && normalized.mode.trim()
    ? normalized.mode.trim()
    : 'pve';
  normalized.mode = resolvedMode;
  if (seed !== undefined && seed !== null && !normalized.seed) {
    normalized.seed = seed;
  }
  return normalized;
}

function normalizeOutcome(outcome) {
  if (!isPlainObject(outcome)) {
    return null;
  }
  return clone(outcome);
}

function resolveRoundCount({ explicitRounds, timeline, legacyRounds, outcome }) {
  if (Number.isFinite(explicitRounds)) {
    return Math.max(0, Math.floor(Number(explicitRounds)));
  }
  if (outcome && Number.isFinite(outcome.rounds)) {
    return Math.max(0, Math.floor(Number(outcome.rounds)));
  }
  if (timeline.length) {
    const lastEntry = timeline[timeline.length - 1];
    const roundValue = Number(lastEntry && lastEntry.round);
    if (Number.isFinite(roundValue)) {
      return Math.max(0, Math.floor(roundValue));
    }
    return timeline.length;
  }
  if (legacyRounds.length) {
    const lastLegacy = legacyRounds[legacyRounds.length - 1];
    if (isPlainObject(lastLegacy) && Number.isFinite(lastLegacy.round)) {
      return Math.max(0, Math.floor(Number(lastLegacy.round)));
    }
    const numericLength = Number(legacyRounds.length);
    if (Number.isFinite(numericLength)) {
      return Math.max(0, Math.floor(numericLength));
    }
  }
  return 0;
}

function normalizeLog(log) {
  if (!Array.isArray(log)) {
    return [];
  }
  return log.filter((entry) => typeof entry === 'string' && entry);
}

function normalizePlainObject(value) {
  if (!isPlainObject(value)) {
    return null;
  }
  return clone(value);
}

function normalizeRewards(rewards) {
  if (!rewards) {
    return null;
  }
  if (Array.isArray(rewards)) {
    return clone(rewards);
  }
  if (isPlainObject(rewards)) {
    return clone(rewards);
  }
  return rewards;
}

function normalizeOptions(options) {
  if (!isPlainObject(options)) {
    return {};
  }
  return clone(options);
}

function collectParticipantIds(participant) {
  if (!isPlainObject(participant)) {
    return [];
  }
  const ids = [];
  ['id', 'memberId', 'characterId', 'roleId', 'openid'].forEach((key) => {
    const value = participant[key];
    if (typeof value === 'string' && value.trim()) {
      ids.push(value.trim());
    }
  });
  return ids;
}

function deriveVictory({ victoryFlag, draw, winnerId, actorId, participants }) {
  if (typeof victoryFlag === 'boolean') {
    return victoryFlag;
  }
  if (draw) {
    return false;
  }
  if (!winnerId) {
    return false;
  }
  if (typeof actorId === 'string' && actorId.trim() && actorId.trim() === winnerId) {
    return true;
  }
  const participantIds = collectParticipantIds(participants && participants.player);
  return participantIds.includes(winnerId);
}

function resolveIdFromValue(value) {
  if (typeof value === 'string' && value.trim()) {
    return value.trim();
  }
  if (isPlainObject(value)) {
    const ids = collectParticipantIds(value);
    return ids.length ? ids[0] : null;
  }
  return null;
}

function createBattlePayload(input = {}) {
  const rawTimeline = input.timeline || (input.simulation && input.simulation.timeline);
  const timeline = normalizeTimeline(rawTimeline);
  let legacyRounds = normalizeLegacyRounds(input.legacyRounds);
  if (!legacyRounds.length && Array.isArray(input.rounds) && !Number.isFinite(input.rounds)) {
    legacyRounds = normalizeLegacyRounds(input.rounds);
  }
  const mode = typeof input.mode === 'string' ? input.mode : undefined;
  const metadata = normalizeMetadata(input.metadata, mode, input.seed);
  const participants = normalizeParticipants(input.participants || {});
  const outcome = normalizeOutcome(input.outcome);
  const explicitRounds = Number.isFinite(input.rounds)
    ? Number(input.rounds)
    : Number.isFinite(input.roundCount)
    ? Number(input.roundCount)
    : null;
  const rounds = resolveRoundCount({ explicitRounds, timeline, legacyRounds, outcome });
  const rawResult = isPlainObject(input.result) ? clone(input.result) : null;
  const winnerId = resolveIdFromValue(
    input.winnerId || (rawResult && rawResult.winnerId) || (outcome && outcome.winnerId)
  );
  const loserId = resolveIdFromValue(
    input.loserId || (rawResult && rawResult.loserId) || (outcome && outcome.loserId)
  );
  let draw;
  if (typeof input.draw === 'boolean') {
    draw = input.draw;
  } else if (rawResult && Object.prototype.hasOwnProperty.call(rawResult, 'draw')) {
    draw = !!rawResult.draw;
  } else if (outcome && Object.prototype.hasOwnProperty.call(outcome, 'draw')) {
    draw = !!outcome.draw;
  } else if (outcome && outcome.result === 'draw') {
    draw = true;
  } else {
    draw = false;
  }

  if (rawResult) {
    rawResult.winnerId = winnerId || null;
    rawResult.loserId = loserId || null;
    rawResult.draw = draw;
  }

  const actorId = resolveIdFromValue(input.actorId);
  const victory = deriveVictory({
    victoryFlag: input.victory,
    draw,
    winnerId,
    actorId,
    participants
  });

  const player = input.player ? clone(input.player) : participants.player ? clone(participants.player) : null;
  const opponent = input.opponent
    ? clone(input.opponent)
    : participants.opponent
    ? clone(participants.opponent)
    : null;

  const payload = {
    battleId: input.battleId || input.matchId || input.id || null,
    matchId: input.matchId || null,
    seed: input.seed || (metadata.seed ? metadata.seed : null),
    mode: metadata.mode,
    rounds,
    timeline,
    legacyRounds,
    participants,
    outcome,
    metadata,
    result: rawResult,
    player,
    opponent,
    options: normalizeOptions(input.options),
    createdAt: input.createdAt || null,
    winnerId: winnerId || null,
    loserId: loserId || null,
    draw,
    victory,
    defeat: !victory && !draw,
    log: normalizeLog(input.log),
    rewards: normalizeRewards(input.rewards || (outcome && outcome.rewards)),
    remaining: normalizePlainObject(input.remaining || (outcome && outcome.remaining)),
    combatPower: normalizePlainObject(input.combatPower)
  };

  if (!payload.battleId && payload.matchId) {
    payload.battleId = payload.matchId;
  }

  if (input.signature) {
    payload.signature = input.signature;
  }

  if (input.seasonId) {
    payload.seasonId = input.seasonId;
  }

  if (input.extra && isPlainObject(input.extra)) {
    payload.extra = clone(input.extra);
  }

  return payload;
}

function decorateBattleReplay(record = {}, options = {}) {
  const defaultMode = typeof options.defaultMode === 'string' ? options.defaultMode : 'pvp';
  const payload = createBattlePayload({
    battleId: record.matchId || record.battleId || record.id || record._id || null,
    matchId: record.matchId || record._id || null,
    seed: record.seed,
    mode: record.mode || defaultMode,
    rounds: record.rounds,
    legacyRounds: record.legacyRounds,
    timeline: record.timeline,
    participants: record.participants,
    outcome: record.outcome,
    metadata: record.metadata,
    result: record.result,
    player: record.player,
    opponent: record.opponent,
    options: record.options,
    createdAt: record.createdAt,
    winnerId: record.winnerId,
    loserId: record.loserId,
    draw: record.draw,
    log: record.log,
    rewards: record.rewards,
    remaining: record.remaining,
    combatPower: record.combatPower,
    signature: record.signature,
    seasonId: record.seasonId
  });
  if (record.seed && !payload.seed) {
    payload.seed = record.seed;
  }
  if (record.signature) {
    payload.signature = record.signature;
  }
  if (record.seasonId) {
    payload.seasonId = record.seasonId;
  }
  return payload;
}

module.exports = {
  createBattlePayload,
  decorateBattleReplay
};
