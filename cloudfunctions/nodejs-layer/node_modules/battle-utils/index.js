'use strict';

function toFiniteNumber(value) {
  if (value === null || value === undefined) {
    return null;
  }
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === 'string') {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  if (typeof value !== 'object') {
    return null;
  }
  if (Number.isFinite(value.speed)) {
    return Number(value.speed);
  }
  return null;
}

function resolveSpeedValue(source, visited = new Set()) {
  if (source === null || source === undefined) {
    return null;
  }
  if (typeof source !== 'object') {
    return toFiniteNumber(source);
  }
  if (visited.has(source)) {
    return null;
  }
  visited.add(source);

  const direct = toFiniteNumber(source);
  if (direct !== null) {
    return direct;
  }

  const directSpeed = toFiniteNumber(source.speed);
  if (directSpeed !== null) {
    return directSpeed;
  }

  const candidateKeys = [
    'stats',
    'combatant',
    'baseStats',
    'finalStats',
    'attributes',
    'attributeTotals',
    'attributeSummary',
    'state',
    'player',
    'opponent',
    'enemy',
    'target'
  ];

  for (let i = 0; i < candidateKeys.length; i += 1) {
    const key = candidateKeys[i];
    if (!Object.prototype.hasOwnProperty.call(source, key)) {
      continue;
    }
    const nested = source[key];
    if (nested === null || nested === undefined) {
      continue;
    }
    if (typeof nested === 'object') {
      const resolved = resolveSpeedValue(nested, visited);
      if (resolved !== null) {
        return resolved;
      }
    } else {
      const resolved = toFiniteNumber(nested);
      if (resolved !== null) {
        return resolved;
      }
    }
  }

  if (Array.isArray(source)) {
    for (let i = 0; i < source.length; i += 1) {
      const value = source[i];
      const resolved = resolveSpeedValue(value, visited);
      if (resolved !== null) {
        return resolved;
      }
    }
  }

  const values = Object.values(source);
  for (let i = 0; i < values.length; i += 1) {
    const resolved = resolveSpeedValue(values[i], visited);
    if (resolved !== null) {
      return resolved;
    }
  }

  return null;
}

function determineRoundOrder(playerSource, opponentSource, options = {}) {
  const {
    fallbackFirst = 'player',
    playerKey = 'player',
    opponentKey = 'opponent'
  } = options;

  const playerSpeed = resolveSpeedValue(playerSource);
  const opponentSpeed = resolveSpeedValue(opponentSource);

  const fallbackNormalized = typeof fallbackFirst === 'string' ? fallbackFirst.toLowerCase() : 'player';
  let firstSide = fallbackNormalized === 'opponent' || fallbackNormalized === 'enemy' ? 'opponent' : 'player';

  if (playerSpeed !== null && opponentSpeed !== null) {
    if (playerSpeed > opponentSpeed) {
      firstSide = 'player';
    } else if (playerSpeed < opponentSpeed) {
      firstSide = 'opponent';
    }
  } else if (playerSpeed !== null) {
    firstSide = 'player';
  } else if (opponentSpeed !== null) {
    firstSide = 'opponent';
  }

  const order = firstSide === 'player' ? [playerKey, opponentKey] : [opponentKey, playerKey];

  return {
    order,
    firstSide,
    playerSpeed,
    opponentSpeed
  };
}

module.exports = {
  determineRoundOrder,
  resolveSpeedValue
};
