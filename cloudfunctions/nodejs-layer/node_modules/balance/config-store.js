const cloud = require('wx-server-sdk');

const { COLLECTIONS } = require('common-config');
const {
  getBalanceDefaults,
  applyRuntimeBalanceConfig,
  withTemporaryBalanceConfig
} = require('balance/config-loader');

const db = cloud.database();

const BALANCE_CONFIG_COLLECTION = COLLECTIONS.BALANCE_CONFIGS || 'balanceConfigs';
const STATUS_USE = 'use';
const STATUS_STAGING = 'staging';
const STATUS_BACKUP = 'backup';
const CACHE_TTL_MS = 60 * 1000;

function deepMerge(base = {}, override = {}) {
  if (Array.isArray(base) || Array.isArray(override)) {
    return override !== undefined ? override : base;
  }
  if (typeof base !== 'object' || typeof override !== 'object' || !override) {
    return override !== undefined ? override : base;
  }
  const result = { ...base };
  Object.keys(override).forEach((key) => {
    result[key] = deepMerge(base[key], override[key]);
  });
  return result;
}

function clone(value) {
  return JSON.parse(JSON.stringify(value || {}));
}

function stripProfile(section = {}) {
  if (!section || typeof section !== 'object') return {};
  if (section.profiles && typeof section.profiles === 'object') {
    const versionKey = section.version || 'v1';
    const profiles = section.profiles || {};
    const selected = profiles[versionKey] || profiles.v1 || profiles[Object.keys(profiles)[0]] || {};
    return deepMerge({}, selected);
  }
  const { version, profiles, ...rest } = section;
  return rest || {};
}

function normalizeBalanceConfig(config = {}) {
  const source = config && typeof config === 'object' ? config : {};
  return {
    level: stripProfile(source.level || {}),
    equipment: stripProfile(source.equipment || {}),
    skill: stripProfile(source.skill || {}),
    pve: stripProfile(source.pve || {}),
    pvp: stripProfile(source.pvp || {})
  };
}

function mergeWithDefaults(config = {}) {
  const defaults = getBalanceDefaults();
  const normalized = normalizeBalanceConfig(config);
  return {
    level: deepMerge(defaults.level, normalized.level),
    equipment: deepMerge(defaults.equipment, normalized.equipment),
    skill: deepMerge(defaults.skill, normalized.skill),
    pve: deepMerge(defaults.pve, normalized.pve),
    pvp: deepMerge(defaults.pvp, normalized.pvp)
  };
}

async function getNextBalanceConfigId() {
  const snapshot = await db
    .collection(BALANCE_CONFIG_COLLECTION)
    .orderBy('_id', 'desc')
    .limit(1)
    .get()
    .catch(() => null);
  const maxId = snapshot && snapshot.data && snapshot.data.length ? Number(snapshot.data[0]._id) : 0;
  return Number.isFinite(maxId) ? maxId + 1 : 1;
}

async function findBalanceDocumentByStatus(status) {
  const result = await db
    .collection(BALANCE_CONFIG_COLLECTION)
    .where({ status })
    .orderBy('updatedAt', 'desc')
    .limit(1)
    .get()
    .catch(() => null);
  if (!result || !result.data || !result.data.length) return null;
  return result.data[0];
}

async function findBalanceDocumentsByStatus(status) {
  const result = await db
    .collection(BALANCE_CONFIG_COLLECTION)
    .where({ status })
    .orderBy('updatedAt', 'desc')
    .limit(50)
    .get()
    .catch(() => null);
  if (!result || !result.data || !result.data.length) return [];
  return result.data;
}

async function readBalanceConfig(status = STATUS_USE) {
  const snapshot = await findBalanceDocumentByStatus(status);
  if (!snapshot) {
    return { exists: false, config: null, metadata: {} };
  }
  const { _id, updatedAt, updatedBy, updatedByName, notes, status: currentStatus, ...rest } = snapshot;
  return {
    exists: true,
    config: normalizeBalanceConfig(rest),
    metadata: {
      id: _id,
      status: currentStatus,
      updatedAt: updatedAt || null,
      updatedBy: updatedBy || '',
      updatedByName: updatedByName || '',
      notes: typeof notes === 'string' ? notes : ''
    }
  };
}

async function writeBalanceConfig(status, config = {}, metadata = {}, options = {}) {
  const now = new Date();
  const forceInsert = options && options.forceInsert;
  const existing = forceInsert ? null : await findBalanceDocumentByStatus(status);
  const nextId = existing && existing._id ? existing._id : await getNextBalanceConfigId();
  const data = {
    status,
    ...normalizeBalanceConfig(config),
    updatedAt: metadata.updatedAt || now,
    createdAt: existing && existing.createdAt ? existing.createdAt : metadata.createdAt || now,
    updatedBy: metadata.updatedBy || '',
    updatedByName: metadata.updatedByName || '',
    notes: metadata.notes || ''
  };

  const docRef = db.collection(BALANCE_CONFIG_COLLECTION).doc(String(nextId));
  if (existing) {
    await docRef.update({ data });
  } else {
    await docRef.set({ data });
  }
  if (status === STATUS_USE) {
    cachedActive = null;
    cachedAt = 0;
  }
  return { config: { ...data, _id: nextId }, updatedAt: data.updatedAt };
}

async function demoteBalanceStatus(currentStatus, nextStatus, excludeId) {
  const existing = await findBalanceDocumentsByStatus(currentStatus);
  if (!existing.length) return;
  const tasks = existing
    .filter((doc) => String(doc._id) !== String(excludeId || ''))
    .map((doc) => updateBalanceStatusById(doc._id, nextStatus));
  await Promise.all(tasks);
}

async function updateBalanceDocumentStatus(id, status, metadata = {}) {
  if (!id) return null;
  const now = metadata.updatedAt || new Date();
  const data = { status, updatedAt: now };
  if (Object.prototype.hasOwnProperty.call(metadata, 'updatedBy')) {
    data.updatedBy = metadata.updatedBy || '';
  }
  if (Object.prototype.hasOwnProperty.call(metadata, 'updatedByName')) {
    data.updatedByName = metadata.updatedByName || '';
  }
  if (Object.prototype.hasOwnProperty.call(metadata, 'notes')) {
    data.notes = metadata.notes || '';
  }
  await db
    .collection(BALANCE_CONFIG_COLLECTION)
    .doc(String(id))
    .update({ data })
    .catch(() => null);
  if (status === STATUS_USE) {
    cachedActive = null;
    cachedAt = 0;
  }
  return { id, status, updatedAt: now };
}

let cachedActive = null;
let cachedAt = 0;

async function loadActiveBalanceConfig(options = {}) {
  const now = Date.now();
  const force = options && options.force;
  if (!force && cachedActive && now - cachedAt < CACHE_TTL_MS) {
    return cachedActive;
  }
  const { exists, config, metadata } = await readBalanceConfig(STATUS_USE);
  const merged = mergeWithDefaults(exists ? config : {});
  cachedActive = {
    exists,
    config: merged,
    metadata: metadata || {}
  };
  cachedAt = now;
  return cachedActive;
}

async function ensureActiveRuntimeConfig(options = {}) {
  const { config } = await loadActiveBalanceConfig(options);
  applyRuntimeBalanceConfig(config);
  return config;
}

function runWithBalanceConfig(overrides = {}, runner) {
  return withTemporaryBalanceConfig(mergeWithDefaults(overrides), runner);
}

async function updateBalanceStatusById(id, status) {
  if (!id) return;
  await db
    .collection(BALANCE_CONFIG_COLLECTION)
    .doc(String(id))
    .update({ data: { status } })
    .catch(() => null);
}

module.exports = {
  BALANCE_CONFIG_COLLECTION,
  STATUS_USE,
  STATUS_STAGING,
  STATUS_BACKUP,
  deepMerge,
  mergeWithDefaults,
  normalizeBalanceConfig,
  readBalanceConfig,
  writeBalanceConfig,
  demoteBalanceStatus,
  updateBalanceDocumentStatus,
  updateBalanceStatusById,
  loadActiveBalanceConfig,
  ensureActiveRuntimeConfig,
  runWithBalanceConfig
};
