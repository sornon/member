'use strict';

const {
  clamp,
  executeAttack,
  resolveCombatStats,
  resolveSpecialStats,
  DEFAULT_COMBAT_STATS,
  DEFAULT_SPECIAL_STATS
} = require('combat-system');
const {
  SKILL_MAP,
  resolveSkillQualityColor,
  resolveSkillQualityLabel
} = require('skill-model');
const { BASIC_ATTACK, resolveRuntimeSkill } = require('./config');

const DEFAULT_RESOURCE_TYPE = 'qi';
const RESOURCE_CONFIG = {
  type: DEFAULT_RESOURCE_TYPE,
  baseMax: 100,
  startFraction: 0,
  turnGain: 20,
  basicAttackGain: 10,
  damageTakenGain: 1.5
};

function toNumber(value, fallback = 0) {
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : fallback;
}

function pickRng(actor, fallback) {
  if (actor && typeof actor.rng === 'function') {
    return actor.rng;
  }
  if (typeof fallback === 'function') {
    return fallback;
  }
  return Math.random;
}

function buildSkillLoadout(skillsState, options = {}) {
  const loadout = [];
  const equipped = Array.isArray(skillsState && skillsState.equipped) ? skillsState.equipped : [];
  const inventory = new Map();
  const entries = Array.isArray(skillsState && skillsState.inventory) ? skillsState.inventory : [];
  entries.forEach((entry) => {
    if (!entry || typeof entry !== 'object') {
      return;
    }
    const skillId = typeof entry.skillId === 'string' ? entry.skillId.trim() : '';
    if (!skillId) {
      return;
    }
    inventory.set(skillId, Math.max(1, Math.floor(Number(entry.level) || 1)));
  });

  equipped.forEach((rawId) => {
    const skillId = typeof rawId === 'string' ? rawId.trim() : '';
    if (!skillId) {
      return;
    }
    const runtime = resolveRuntimeSkill(skillId);
    if (!runtime || runtime === BASIC_ATTACK) {
      return;
    }
    const level = inventory.get(skillId) || 1;
    loadout.push({ ...runtime, level });
  });

  const includeBasic = options && options.includeBasic !== false;
  if (includeBasic) {
    loadout.push({ ...BASIC_ATTACK, level: 1 });
  }
  return loadout;
}

function resolveResourceNumber(candidates, fallback) {
  for (let i = 0; i < candidates.length; i += 1) {
    const candidate = candidates[i];
    if (candidate === undefined || candidate === null) {
      continue;
    }
    const numeric = Number(candidate);
    if (Number.isFinite(numeric)) {
      return Math.max(0, numeric);
    }
  }
  return Math.max(0, fallback);
}

function toTrimmedString(value) {
  if (typeof value !== 'string') {
    return '';
  }
  return value.trim();
}

function resolveSkillQualityMeta(skill) {
  const skillId = skill && typeof skill.id === 'string' ? skill.id : '';
  const definition = skillId && SKILL_MAP ? SKILL_MAP[skillId] : null;
  const qualityFromSkill = toTrimmedString(skill && skill.quality);
  const qualityFromDefinition = toTrimmedString(definition && definition.quality);
  const quality = qualityFromSkill || qualityFromDefinition || 'linggan';
  const labelFromSkill = toTrimmedString(skill && skill.qualityLabel);
  const qualityLabel = labelFromSkill || toTrimmedString(resolveSkillQualityLabel(quality));
  const colorFromSkill = toTrimmedString(skill && skill.qualityColor);
  const qualityColor = colorFromSkill || toTrimmedString(resolveSkillQualityColor(quality));
  return {
    quality,
    qualityLabel,
    qualityColor
  };
}

function resolveResourceSetup({ combatant, stats, special }) {
  const summary = (combatant && combatant.resource) || combatant || {};
  const resourceCandidates = [
    summary.max,
    summary.maxResource,
    summary.resourceMax,
    stats && stats.resourceMax,
    stats && stats.rageMax,
    stats && stats.qiMax,
    special && special.resourceMax,
    special && special.rageMax,
    special && special.qiMax
  ];
  let resolvedMax = RESOURCE_CONFIG.baseMax;
  for (let i = 0; i < resourceCandidates.length; i += 1) {
    const candidate = Number(resourceCandidates[i]);
    if (Number.isFinite(candidate) && candidate > 0) {
      resolvedMax = Math.max(1, Math.round(candidate));
      break;
    }
  }

  const startCandidates = [
    summary.start,
    summary.initial,
    summary.initialResource,
    summary.resourceStart,
    special && special.resourceStart,
    special && special.rageStart,
    special && special.qiStart
  ];
  let resolvedStart = Number.NaN;
  for (let i = 0; i < startCandidates.length; i += 1) {
    const candidate = startCandidates[i];
    if (candidate === undefined || candidate === null) {
      continue;
    }
    const numeric = Number(candidate);
    if (Number.isFinite(numeric)) {
      if (numeric > 0 && numeric <= 1) {
        resolvedStart = Math.round(resolvedMax * clamp(numeric, 0, 1));
      } else {
        resolvedStart = Math.round(numeric);
      }
      break;
    }
  }
  if (!Number.isFinite(resolvedStart)) {
    resolvedStart = Math.round(resolvedMax * clamp(RESOURCE_CONFIG.startFraction, 0, 1));
  }
  const resourceTypeCandidate =
    (summary && summary.type) ||
    (combatant && combatant.resourceType) ||
    (special && special.resourceType) ||
    RESOURCE_CONFIG.type;
  const resourceType = typeof resourceTypeCandidate === 'string' && resourceTypeCandidate.trim()
    ? resourceTypeCandidate.trim()
    : RESOURCE_CONFIG.type;
  const turnGain = resolveResourceNumber(
    [
      summary.turnGain,
      summary.perTurnGain,
      summary.regen,
      summary.gainPerTurn,
      stats && stats.resourceTurnGain,
      stats && stats.rageTurnGain,
      stats && stats.qiTurnGain,
      special && special.resourceTurnGain,
      special && special.rageTurnGain,
      special && special.qiTurnGain
    ],
    RESOURCE_CONFIG.turnGain
  );
  const basicAttackGain = resolveResourceNumber(
    [
      summary.basicAttackGain,
      summary.basicGain,
      summary.onAttackGain,
      summary.attackGain,
      stats && stats.basicAttackResourceGain,
      stats && stats.resourceAttackGain,
      stats && stats.attackGain,
      special && special.basicAttackResourceGain,
      special && special.resourceAttackGain,
      special && special.attackGain
    ],
    RESOURCE_CONFIG.basicAttackGain
  );
  const damageTakenGain = resolveResourceNumber(
    [
      summary.damageTakenGain,
      summary.onDamageGain,
      summary.damageGain,
      summary.beingHitGain,
      stats && stats.damageTakenResourceGain,
      stats && stats.resourceDamageGain,
      stats && stats.damageTakenGain,
      special && special.damageTakenResourceGain,
      special && special.resourceDamageGain,
      special && special.damageTakenGain
    ],
    RESOURCE_CONFIG.damageTakenGain
  );
  return {
    max: Math.max(1, resolvedMax),
    start: clamp(resolvedStart, 0, Math.max(1, resolvedMax)),
    type: resourceType,
    turnGain,
    basicAttackGain,
    damageTakenGain
  };
}

function clampResource(actor, value) {
  if (!actor) {
    return 0;
  }
  const max = Math.max(0, Math.round(actor.resourceMax || RESOURCE_CONFIG.baseMax));
  return Math.max(0, Math.min(max, Math.round(value)));
}

function resolveActorResourceGain(actor, key) {
  if (!actor) {
    return RESOURCE_CONFIG[key];
  }
  const propertyMap = {
    turnGain: 'resourceTurnGain',
    basicAttackGain: 'resourceBasicGain',
    damageTakenGain: 'resourceDamageTakenGain'
  };
  const property = propertyMap[key];
  if (property && Number.isFinite(actor[property])) {
    return Math.max(0, Number(actor[property]));
  }
  return RESOURCE_CONFIG[key];
}

function calculateDamageTakenResourceGain(actor, damage) {
  if (!actor || !Number.isFinite(damage) || damage <= 0) {
    return 0;
  }
  const maxHp = Math.max(1, Math.round(actor.maxHp || actor.hpMax || DEFAULT_COMBAT_STATS.maxHp));
  const percentLost = Math.max(0, damage) / maxHp;
  if (percentLost <= 0) {
    return 0;
  }
  const resourceMax = Math.max(1, Math.round(actor.resourceMax || RESOURCE_CONFIG.baseMax));
  const multiplier = resolveActorResourceGain(actor, 'damageTakenGain');
  if (multiplier <= 0) {
    return 0;
  }
  return percentLost * multiplier * resourceMax;
}

function applyResourceDelta(actor, delta, { events, summary, source, includeSummary = false } = {}) {
  if (!actor || !Number.isFinite(delta) || delta === 0) {
    return 0;
  }
  const before = Math.round(Number(actor.resource) || 0);
  const target = before + delta;
  const after = clampResource(actor, target);
  const applied = after - before;
  if (!applied) {
    return 0;
  }
  actor.resource = after;
  if (Array.isArray(events)) {
    events.push({
      type: 'resource',
      targetId: actor.id,
      targetSide: actor.side,
      resourceType: actor.resourceType || RESOURCE_CONFIG.type,
      before,
      change: applied,
      after,
      max: Math.max(0, Math.round(actor.resourceMax || RESOURCE_CONFIG.baseMax)),
      source
    });
  }
  if (includeSummary && Array.isArray(summary)) {
    summary.push(
      applied > 0
        ? `${actor.name}恢复${applied}点真气`
        : `${actor.name}消耗${Math.abs(applied)}点真气`
    );
  }
  return applied;
}

function resolveResourceGainMultiplier(actor, stats) {
  if (!actor) {
    return 0;
  }
  let rageGain = 0;
  if (stats && Number.isFinite(stats.rageGain)) {
    rageGain = Number(stats.rageGain);
  } else {
    const snapshot = resolveEffectiveStats(actor, { mode: 'attack' });
    rageGain = Number(snapshot.stats && snapshot.stats.rageGain ? snapshot.stats.rageGain : 0);
  }
  return Math.max(0, 1 + rageGain);
}

function gainResource(actor, baseAmount, { events, summary, source, stats } = {}) {
  if (!actor || !Number.isFinite(baseAmount) || baseAmount <= 0) {
    return 0;
  }
  const multiplier = resolveResourceGainMultiplier(actor, stats);
  const amount = Math.round(Math.max(0, baseAmount) * multiplier);
  if (amount <= 0) {
    return 0;
  }
  return applyResourceDelta(actor, amount, { events, summary, source });
}

function spendResource(actor, amount, { events, summary, source, includeSummary = true } = {}) {
  if (!actor || !Number.isFinite(amount) || amount <= 0) {
    return { success: true, spent: 0 };
  }
  const cost = Math.round(Math.max(0, amount));
  const available = Math.round(Number(actor.resource) || 0);
  if (available < cost) {
    return { success: false, spent: 0 };
  }
  const applied = applyResourceDelta(actor, -cost, {
    events,
    summary,
    source,
    includeSummary
  });
  return { success: applied !== 0 || cost === 0, spent: Math.abs(applied) };
}

function applyTurnStartResourceGain(actor, { events, summary } = {}) {
  const amount = resolveActorResourceGain(actor, 'turnGain');
  return gainResource(actor, amount, {
    events,
    summary,
    source: 'turn_start'
  });
}

function resolveSkillResource(skill) {
  if (!skill || typeof skill !== 'object') {
    return { type: RESOURCE_CONFIG.type, cost: 0 };
  }
  const resource = skill.resource || {};
  const type = typeof resource.type === 'string' && resource.type ? resource.type : RESOURCE_CONFIG.type;
  let cost = 0;
  if (Number.isFinite(resource.cost)) {
    cost = Math.max(0, Math.round(resource.cost));
  } else if (Number.isFinite(skill.cost)) {
    cost = Math.max(0, Math.round(skill.cost));
  }
  return { type, cost };
}

function resolveSkillCost(skill) {
  const resource = resolveSkillResource(skill);
  return resource.cost || 0;
}

function normalizeCombatantStats(combatant = {}) {
  const stats = resolveCombatStats(combatant, {
    defaults: DEFAULT_COMBAT_STATS,
    convertLegacyPercentages: true
  });
  const special = resolveSpecialStats(combatant.special || combatant.skillSummary || {}, {
    defaults: DEFAULT_SPECIAL_STATS,
    convertLegacyPercentages: true
  });
  return { stats, special };
}

function createActorRuntime({
  id,
  name,
  side,
  combatant,
  skills,
  rng,
  mode
}) {
  const { stats, special } = normalizeCombatantStats(combatant);
  const baseStats = { ...stats };
  const baseSpecial = { ...special };
  const maxHp = Math.max(1, Math.round(stats.maxHp || DEFAULT_COMBAT_STATS.maxHp));
  const shield = Math.max(0, Math.round(special.shield || 0));
  const loadout = Array.isArray(skills) && skills.length ? skills : buildSkillLoadout({}, {});
  const resourceSetup = resolveResourceSetup({ combatant, stats, special });
  return {
    id: typeof id === 'string' && id ? id : side === 'opponent' ? 'opponent' : 'player',
    name: typeof name === 'string' && name ? name : side === 'opponent' ? '敌方' : '我方',
    side: side || 'player',
    stats,
    special,
    baseStats,
    baseSpecial,
    maxHp,
    hp: maxHp + shield,
    resourceType: resourceSetup.type,
    resourceMax: resourceSetup.max,
    resource: resourceSetup.start,
    resourceTurnGain: resourceSetup.turnGain,
    resourceBasicGain: resourceSetup.basicAttackGain,
    resourceDamageTakenGain: resourceSetup.damageTakenGain,
    skillLoadout: loadout.length ? loadout : [{ ...BASIC_ATTACK, level: 1 }],
    cooldowns: {},
    statuses: [],
    rng: typeof rng === 'function' ? rng : null,
    mode: mode || 'pve',
    history: [],
    defeated: false
  };
}

function decrementCooldowns(actor) {
  if (!actor || !actor.cooldowns) {
    return;
  }
  Object.keys(actor.cooldowns).forEach((skillId) => {
    const value = actor.cooldowns[skillId];
    if (Number.isFinite(value) && value > 0) {
      actor.cooldowns[skillId] = Math.max(0, value - 1);
    }
  });
}

function hasActiveStatus(actor, predicate) {
  if (!actor || !Array.isArray(actor.statuses)) {
    return false;
  }
  return actor.statuses.some((status) => status && status.remaining > 0 && predicate(status));
}

function getBaseStat(actor, key) {
  if (!actor) {
    return 0;
  }
  if (Object.prototype.hasOwnProperty.call(actor.baseStats, key)) {
    return actor.baseStats[key];
  }
  if (Object.prototype.hasOwnProperty.call(actor.baseSpecial, key)) {
    return actor.baseSpecial[key];
  }
  return 0;
}

function applyStatDelta(target, key, delta) {
  if (Object.prototype.hasOwnProperty.call(target.stats, key)) {
    target.stats[key] += delta;
    return;
  }
  if (Object.prototype.hasOwnProperty.call(target.special, key)) {
    target.special[key] += delta;
  }
}

function resolveEffectiveStats(actor, { mode = 'attack' } = {}) {
  const stats = { ...actor.stats };
  const special = { ...actor.special };
  const extra = {
    extraDamageRatio: 0,
    reflectRatio: 0,
    followUp: []
  };
  const modifiers = Array.isArray(actor.statuses) ? actor.statuses : [];
  modifiers.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    const params = status.params || {};
    switch (status.type) {
      case 'stat': {
        applyStatDelta({ stats, special }, status.key, status.delta);
        break;
      }
      case 'extraDamage':
        if (mode === 'attack') {
          extra.extraDamageRatio += params.ratio || 0;
        }
        break;
      case 'reflect':
        if (mode === 'defense') {
          extra.reflectRatio += params.ratio || 0;
        }
        break;
      case 'shield':
        if (mode === 'defense' && params.reflectRatio) {
          extra.reflectRatio += params.reflectRatio;
        }
        if (mode === 'attack' && params.burstRatio) {
          extra.followUp.push({ type: 'burst', ratio: params.burstRatio, kind: params.kind || 'magic' });
        }
        break;
      case 'domain':
        if (mode === 'attack') {
          extra.extraDamageRatio += params.ratio || 0;
        }
        break;
      default:
        break;
    }
  });
  return { stats, special, extra };
}

function createStatus(base) {
  const status = {
    id: base && base.id ? base.id : `status_${Date.now()}_${Math.random().toString(16).slice(2)}`,
    source: base && base.source,
    type: base && base.type,
    remaining: Math.max(0, Math.floor(base && base.remaining ? base.remaining : 0)),
    params: base && base.params ? { ...base.params } : {},
    key: base && base.key ? base.key : null,
    delta: base && typeof base.delta === 'number' ? base.delta : 0
  };
  return status;
}

function addStatus(target, descriptor, options = {}) {
  if (!target || !descriptor) {
    return null;
  }
  const duration = Math.max(0, Math.floor(descriptor.duration || 0));
  if (duration <= 0 && descriptor.type !== 'shield') {
    return null;
  }
  const status = createStatus({
    source: options.source,
    type: descriptor.type,
    remaining: duration,
    params: descriptor.params || {}
  });

  if (descriptor.type === 'stat') {
    const key = descriptor.stat;
    if (!key) {
      return null;
    }
    const baseValue = getBaseStat(target, key);
    const mode = descriptor.mode || 'flat';
    const value = toNumber(descriptor.value, 0);
    const delta = mode === 'percent' ? baseValue * value : value;
    status.key = key;
    status.delta = delta;
    status.params.mode = mode;
  } else if (descriptor.type === 'shield') {
    const ratio = descriptor.ratioOfMaxHp || 0;
    const bonus = Math.max(0, target.maxHp * ratio);
    status.params.shieldValue = bonus;
    status.params.maxShield = bonus;
    status.params.removeOnExpire = true;
    status.remaining = Math.max(1, duration || descriptor.duration || 1);
    target.hp += bonus;
  } else if (descriptor.type === 'reflect') {
    const ratio = descriptor.ratio || (descriptor.params && descriptor.params.ratio) || 0;
    status.params.ratio = ratio;
    status.remaining = Math.max(1, duration || 2);
  } else if (descriptor.type === 'extraDamage') {
    const ratio = descriptor.ratio || (descriptor.params && descriptor.params.ratio) || 0;
    status.params.ratio = ratio;
    status.type = 'domain';
    status.remaining = Math.max(1, duration || 1);
  } else if (descriptor.type === 'control') {
    status.params.effect = descriptor.effect || 'stun';
    status.remaining = Math.max(1, duration || 1);
  } else if (descriptor.type === 'dot') {
    status.params.attribute = descriptor.attribute || 'magicAttack';
    status.params.ratio = descriptor.ratio || 0;
    status.params.kind = descriptor.dotType || descriptor.typeLabel || 'dot';
    status.remaining = Math.max(1, duration || 1);
  }

  target.statuses = Array.isArray(target.statuses) ? target.statuses : [];
  target.statuses.push(status);
  return status;
}

function removeStatus(target, status) {
  if (!target || !Array.isArray(target.statuses)) {
    return;
  }
  const index = target.statuses.indexOf(status);
  if (index >= 0) {
    target.statuses.splice(index, 1);
  }
}

function applyShieldExpiration(actor, status) {
  if (!actor || !status || status.type !== 'shield') {
    return;
  }
  const params = status.params || {};
  const shieldValue = Math.max(0, params.shieldValue || 0);
  if (shieldValue <= 0) {
    return;
  }
  const excess = Math.max(0, actor.hp - actor.maxHp);
  if (excess > 0) {
    const reduction = Math.min(excess, shieldValue);
    actor.hp = Math.max(actor.maxHp, actor.hp - reduction);
  }
}

function processStartStatuses({ actor, opponent, rng, events = [], summary = [] }) {
  let skip = false;
  let defeated = false;
  let cachedResourceStats = null;
  const resolveActorResourceStats = () => {
    if (!cachedResourceStats) {
      cachedResourceStats = resolveEffectiveStats(actor, { mode: 'attack' }).stats;
    }
    return cachedResourceStats;
  };
  const statuses = Array.isArray(actor.statuses) ? actor.statuses.slice() : [];
  statuses.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    const params = status.params || {};
    switch (status.type) {
      case 'control': {
        if (params.effect === 'stun') {
          skip = true;
        } else if (params.effect === 'silence') {
          actor.silenced = true;
        }
        break;
      }
      case 'dot': {
        const attribute = params.attribute || 'magicAttack';
        const ratio = params.ratio || 0;
        if (ratio <= 0) {
          break;
        }
        const attackerStats = resolveEffectiveStats(opponent || actor, { mode: 'attack' }).stats;
        const sourceStat = attribute && attribute in attackerStats ? attackerStats[attribute] : attackerStats.magicAttack;
        let damage = Math.max(0, sourceStat * ratio);
        const defenderStats = resolveEffectiveStats(actor, { mode: 'defense' });
        const finalBonus = defenderStats.stats.finalDamageBonus || 0;
        const finalReduction = defenderStats.stats.finalDamageReduction || 0;
        const finalMultiplier = Math.max(0.1, 1 + finalBonus - finalReduction);
        damage *= finalMultiplier;
        damage = Math.max(1, damage);
        actor.hp = Math.max(0, actor.hp - damage);
        events.push({
          type: 'damage',
          targetId: actor.id,
          targetSide: actor.side,
          value: Math.round(damage),
          source: status.source || 'dot'
        });
        summary.push(`${actor.name}受到持续伤害 ${Math.round(damage)} 点`);
        const damageGain = calculateDamageTakenResourceGain(actor, damage);
        gainResource(actor, damageGain, {
          events,
          summary,
          source: status.source || 'dot',
          stats: resolveActorResourceStats()
        });
        if (actor.hp <= 0) {
          defeated = true;
        }
        break;
      }
      default:
        break;
    }
  });
  return { skip, defeated };
}

function hasStatusEffect(actor, effect) {
  return hasActiveStatus(actor, (status) => status && status.type === 'control' && status.params && status.params.effect === effect);
}

function chooseSkill(actor) {
  if (!actor || !Array.isArray(actor.skillLoadout) || !actor.skillLoadout.length) {
    return { ...BASIC_ATTACK, level: 1 };
  }
  const silenced = hasStatusEffect(actor, 'silence');
  const availableResource = Math.max(0, Math.round(Number(actor.resource) || 0));
  for (let i = 0; i < actor.skillLoadout.length; i += 1) {
    const skill = actor.skillLoadout[i];
    if (!skill || skill.id === BASIC_ATTACK.id) {
      continue;
    }
    const cooldown = actor.cooldowns[skill.id] || 0;
    if (cooldown > 0) {
      continue;
    }
    if (silenced && skill.type && skill.type !== 'passive' && skill.type !== 'basic') {
      continue;
    }
    const cost = resolveSkillCost(skill);
    if (cost > availableResource) {
      continue;
    }
    return skill;
  }
  const basic = actor.skillLoadout.find((skill) => skill && skill.id === BASIC_ATTACK.id);
  return basic || { ...BASIC_ATTACK, level: 1 };
}

function applyControl(opponent, controlDescriptor, skillId, level, rng) {
  if (!opponent || !controlDescriptor) {
    return false;
  }
  const chance = (controlDescriptor.chance || 0) + (controlDescriptor.perLevel || 0) * Math.max(0, level - 1);
  const random = rng ? rng() : Math.random();
  if (random > clamp(chance, 0, 1)) {
    return false;
  }
  const effect = controlDescriptor.type === 'silence' ? 'silence' : 'stun';
  addStatus(opponent, {
    type: 'control',
    duration: controlDescriptor.duration || 1,
    params: { effect }
  }, { source: skillId });
  return true;
}

function applyDot(opponent, descriptor, skillId, level) {
  const ratio = (descriptor.ratio || 0) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
  if (ratio <= 0) {
    return;
  }
  addStatus(opponent, {
    type: 'dot',
    duration: descriptor.duration || 1,
    attribute: descriptor.attribute || 'magicAttack',
    ratio,
    dotType: descriptor.type || 'dot'
  }, { source: skillId });
}

function applyStatDebuffs(target, list, skillId, level) {
  if (!target || !Array.isArray(list)) {
    return;
  }
  list.forEach((entry) => {
    if (!entry) {
      return;
    }
    const value = (entry.value || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
    if (!value) {
      return;
    }
    addStatus(target, {
      type: 'stat',
      stat: entry.stat,
      mode: entry.mode || 'flat',
      value,
      duration: entry.duration || 1
    }, { source: skillId });
  });
}

function applyBuffs(target, list, skillId, level) {
  if (!target || !Array.isArray(list)) {
    return;
  }
  list.forEach((entry) => {
    if (!entry) {
      return;
    }
    switch (entry.type) {
      case 'stat': {
        const value = (entry.value || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, {
          type: 'stat',
          stat: entry.stat,
          mode: entry.mode || 'flat',
          value,
          duration: entry.duration || 1
        }, { source: skillId });
        break;
      }
      case 'shield': {
        const ratio = (entry.ratioOfMaxHp || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        const status = addStatus(target, {
          type: 'shield',
          ratioOfMaxHp: ratio,
          duration: entry.duration || 1
        }, { source: skillId });
        if (status && entry.reflectRatio) {
          status.params.reflectRatio = (entry.reflectRatio || 0) + (entry.reflectPerLevel || 0) * Math.max(0, level - 1);
        }
        if (status && entry.burstRatio) {
          status.params.burstRatio = entry.burstRatio;
          status.params.kind = entry.kind || 'magic';
        }
        break;
      }
      case 'reflect': {
        const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, { type: 'reflect', duration: entry.duration || 2, params: { ratio } }, { source: skillId });
        break;
      }
      case 'extraDamage': {
        const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, { type: 'extraDamage', duration: entry.duration || 2, params: { ratio } }, { source: skillId });
        break;
      }
      default:
        break;
    }
  });
}

function calculateBonusDamage(baseDamage, ratio) {
  if (!baseDamage || !ratio) {
    return 0;
  }
  return Math.max(0, baseDamage * ratio);
}

function executeSkill({ actor, opponent, skill, rng }) {
  const events = [];
  const summary = [];
  const level = Math.max(1, Math.floor(skill.level || 1));
  const random = pickRng(actor, rng);
  const { stats: attackerStats, special: attackerSpecial, extra: attackerExtra } = resolveEffectiveStats(actor, {
    mode: 'attack'
  });
  const { stats: defenderStats, special: defenderSpecial, extra: defenderExtra } = resolveEffectiveStats(opponent, {
    mode: 'defense'
  });
  const opponentAttackStats = opponent ? resolveEffectiveStats(opponent, { mode: 'attack' }).stats : null;

  let totalDamage = 0;
  let totalHeal = 0;
  let dodged = false;
  let crit = false;

  const damageDescriptors = Array.isArray(skill.damage) && skill.damage.length ? skill.damage : [{ kind: 'auto', ratio: 1 }];
  const followUpDescriptors = [];
  if (skill.followUp) {
    const followDescriptor = { ...skill.followUp };
    if (!followDescriptor.type) {
      followDescriptor.type = 'burst';
    }
    followDescriptor.ratio =
      (followDescriptor.ratio || 0) + (followDescriptor.perLevel || 0) * Math.max(0, level - 1);
    followDescriptor.kind = followDescriptor.kind || 'magic';
    followDescriptor.source = skill.id;
    followUpDescriptors.push(followDescriptor);
  }
  if (Array.isArray(attackerExtra.followUp)) {
    attackerExtra.followUp.forEach((descriptor) => {
      if (!descriptor) {
        return;
      }
      const followDescriptor = {
        ...descriptor,
        ratio: descriptor.ratio || 0,
        kind: descriptor.kind || 'magic',
        type: descriptor.type || 'burst',
        source: descriptor.source || 'status'
      };
      followUpDescriptors.push(followDescriptor);
    });
  }

  damageDescriptors.forEach((descriptor) => {
    const hits = Math.max(1, Math.floor(descriptor.hits || 1));
    for (let i = 0; i < hits; i += 1) {
      const attackStats = { ...attackerStats };
      const defenseStats = { ...defenderStats };
      if (descriptor.kind === 'physical') {
        const ratio = (descriptor.ratio || 1) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
        attackStats.physicalAttack = Math.max(0, attackStats.physicalAttack * ratio);
      } else if (descriptor.kind === 'magic') {
        const ratio = (descriptor.ratio || 1) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
        attackStats.magicAttack = Math.max(0, attackStats.magicAttack * ratio);
      }
      const result = executeAttack(attackStats, attackerSpecial, defenseStats, defenderSpecial, random);
      dodged = dodged || result.dodged;
      if (result.dodged) {
        events.push({ type: 'dodge', targetId: opponent.id, targetSide: opponent.side });
        summary.push(`${opponent.name}闪避了攻击`);
        continue;
      }
      crit = crit || result.crit;
      let damage = Math.max(1, result.damage);
      if (descriptor.extraOnCritRatio && result.crit) {
        const extraRatio = descriptor.extraOnCritRatio + (descriptor.extraOnCritPerLevel || 0) * Math.max(0, level - 1);
        damage += calculateBonusDamage(result.damage, extraRatio);
      }
      if (attackerExtra.extraDamageRatio) {
        damage += calculateBonusDamage(result.damage, attackerExtra.extraDamageRatio);
      }
      damage = Math.max(1, damage);
      opponent.hp = Math.max(0, opponent.hp - damage);
      totalDamage += damage;
      events.push({
        type: 'damage',
        targetId: opponent.id,
        targetSide: opponent.side,
        value: Math.round(damage),
        crit: !!result.crit
      });
      summary.push(`${actor.name}造成 ${Math.round(damage)} 点伤害${result.crit ? '（暴击）' : ''}`);
      const opponentDamageGain = calculateDamageTakenResourceGain(opponent, damage);
      gainResource(opponent, opponentDamageGain, {
        events,
        source: skill.id || 'damage',
        stats: opponentAttackStats
      });
      if (result.heal > 0) {
        const healValue = Math.max(0, result.heal);
        const before = actor.hp;
        actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + healValue);
        const applied = Math.max(0, actor.hp - before);
        if (applied > 0) {
          totalHeal += applied;
          events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied) });
          summary.push(`${actor.name}回复 ${Math.round(applied)} 点生命`);
        }
      }
      if (defenderExtra.reflectRatio) {
        const reflected = calculateBonusDamage(damage, defenderExtra.reflectRatio);
        if (reflected > 0) {
          actor.hp = Math.max(0, actor.hp - reflected);
          events.push({ type: 'damage', targetId: actor.id, targetSide: actor.side, value: Math.round(reflected), source: 'reflect' });
          summary.push(`${actor.name}受到反伤 ${Math.round(reflected)} 点`);
          const reflectDamageGain = calculateDamageTakenResourceGain(actor, reflected);
          gainResource(actor, reflectDamageGain, {
            events,
            source: 'reflect',
            stats: attackerStats
          });
        }
      }
    }
  });

  if (Array.isArray(skill.conditionalDamage)) {
    skill.conditionalDamage.forEach((entry) => {
      if (!entry) {
        return;
      }
      const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
      if (!ratio) {
        return;
      }
      const conditionMet = entry.condition === 'burning' ? hasActiveStatus(opponent, (status) => status.type === 'dot' && status.params && status.params.kind === 'burning') : false;
      if (!conditionMet) {
        return;
      }
      const baseDamage = entry.kind === 'physical' ? attackerStats.physicalAttack : attackerStats.magicAttack;
      const bonusDamage = Math.max(1, baseDamage * ratio);
      opponent.hp = Math.max(0, opponent.hp - bonusDamage);
      totalDamage += bonusDamage;
      events.push({ type: 'damage', targetId: opponent.id, targetSide: opponent.side, value: Math.round(bonusDamage) });
      summary.push(`${actor.name}引燃弱点，追加 ${Math.round(bonusDamage)} 点伤害`);
      const conditionalDamageGain = calculateDamageTakenResourceGain(opponent, bonusDamage);
      gainResource(opponent, conditionalDamageGain, {
        events,
        source: skill.id || 'conditional',
        stats: opponentAttackStats
      });
    });
  }

  if (Array.isArray(skill.dots)) {
    skill.dots.forEach((dot) => applyDot(opponent, dot, skill.id, level));
  }

  if (Array.isArray(skill.debuffs)) {
    applyStatDebuffs(opponent, skill.debuffs, skill.id, level);
  }

  if (skill.control) {
    const applied = applyControl(opponent, skill.control, skill.id, level, random);
    if (applied) {
      summary.push(`${opponent.name}被控制`);
    }
  }

  if (Array.isArray(skill.buffs)) {
    applyBuffs(actor, skill.buffs, skill.id, level);
  }

  const followUpResults = followUpDescriptors.filter((descriptor) => descriptor.ratio > 0);
  followUpResults.forEach((descriptor) => {
    if (descriptor.source === skill.id && totalDamage <= 0) {
      return;
    }
    const attackStats = { ...attackerStats };
    const defenseStats = { ...defenderStats };
    if (descriptor.kind === 'physical') {
      attackStats.physicalAttack = Math.max(0, attackStats.physicalAttack * descriptor.ratio);
    } else {
      attackStats.magicAttack = Math.max(0, attackStats.magicAttack * descriptor.ratio);
    }
    const result = executeAttack(attackStats, attackerSpecial, defenseStats, defenderSpecial, random);
    if (result.dodged) {
      dodged = true;
      events.push({ type: 'dodge', targetId: opponent.id, targetSide: opponent.side, source: descriptor.source || 'followUp' });
      summary.push(`${opponent.name}闪避了后续打击`);
      return;
    }
    let damage = Math.max(1, result.damage);
    crit = crit || result.crit;
    if (attackerExtra.extraDamageRatio) {
      damage += calculateBonusDamage(result.damage, attackerExtra.extraDamageRatio);
    }
    damage = Math.max(1, damage);
    opponent.hp = Math.max(0, opponent.hp - damage);
    totalDamage += damage;
    events.push({
      type: 'damage',
      targetId: opponent.id,
      targetSide: opponent.side,
      value: Math.round(damage),
      crit: !!result.crit,
      source: descriptor.source || 'followUp'
    });
    summary.push(`${actor.name}追加打击造成 ${Math.round(damage)} 点伤害${result.crit ? '（暴击）' : ''}`);
    if (result.heal > 0) {
      const healValue = Math.max(0, result.heal);
      const before = actor.hp;
      actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + healValue);
      const applied = Math.max(0, actor.hp - before);
      if (applied > 0) {
        totalHeal += applied;
        events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied), source: 'followUp' });
        summary.push(`${actor.name}追加打击吸取 ${Math.round(applied)} 点生命`);
      }
    }
    if (defenderExtra.reflectRatio) {
      const reflected = calculateBonusDamage(damage, defenderExtra.reflectRatio);
      if (reflected > 0) {
        actor.hp = Math.max(0, actor.hp - reflected);
        events.push({ type: 'damage', targetId: actor.id, targetSide: actor.side, value: Math.round(reflected), source: 'reflect' });
        summary.push(`${actor.name}因反伤承受 ${Math.round(reflected)} 点伤害`);
        const followUpReflectGain = calculateDamageTakenResourceGain(actor, reflected);
        gainResource(actor, followUpReflectGain, {
          events,
          source: 'reflect',
          stats: attackerStats
        });
      }
    }
    const followUpDamageGain = calculateDamageTakenResourceGain(opponent, damage);
    gainResource(opponent, followUpDamageGain, {
      events,
      source: descriptor.source || 'followUp',
      stats: opponentAttackStats
    });
  });

  if (skill.healSelf) {
    const ratio = (skill.healSelf.ratioOfMaxHp || 0) + (skill.healSelf.perLevel || 0) * Math.max(0, level - 1);
    const amount = Math.max(0, actor.maxHp * ratio);
    const before = actor.hp;
    actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + amount);
    const applied = Math.max(0, actor.hp - before);
    if (applied > 0) {
      totalHeal += applied;
      events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied) });
      summary.push(`${actor.name}回复 ${Math.round(applied)} 点生命`);
    }
  }

  if ((skill.id === BASIC_ATTACK.id || skill.type === 'basic') && totalDamage > 0) {
    const basicGain = resolveActorResourceGain(actor, 'basicAttackGain');
    gainResource(actor, basicGain, {
      events,
      source: skill.id || BASIC_ATTACK.id,
      stats: attackerStats
    });
  }

  return {
    events,
    summary,
    totalDamage,
    totalHeal,
    dodged,
    crit
  };
}

function finalizeStatuses(actor) {
  if (!actor || !Array.isArray(actor.statuses)) {
    return;
  }
  actor.statuses.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    status.remaining -= 1;
    if (status.remaining <= 0) {
      if (status.type === 'shield') {
        applyShieldExpiration(actor, status);
      }
    }
  });
  actor.statuses = actor.statuses.filter((status) => status && status.remaining > 0);
  actor.silenced = false;
}

function takeTurn({ actor, opponent, rng }) {
  const random = pickRng(actor, rng);
  const preEvents = [];
  const summary = [];
  decrementCooldowns(actor);
  applyTurnStartResourceGain(actor, { events: preEvents });
  const start = processStartStatuses({ actor, opponent, rng: random, events: preEvents, summary });
  if (actor.hp <= 0) {
    actor.defeated = true;
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: '无法行动', type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }
  if (start.defeated) {
    actor.defeated = true;
    finalizeStatuses(actor);
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: '重创倒地', type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }
  if (start.skip) {
    finalizeStatuses(actor);
    actor.cooldowns = actor.cooldowns || {};
    actor.cooldowns.stunned = Math.max(0, (actor.cooldowns.stunned || 0) - 1);
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: '被控制', type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }

  let skill = chooseSkill(actor);
  let resourceCost = resolveSkillCost(skill);
  let spentCost = 0;
  if (resourceCost > 0) {
    const spendResult = spendResource(actor, resourceCost, {
      events: preEvents,
      source: skill.id,
      includeSummary: false
    });
    if (!spendResult.success) {
      const basic = actor.skillLoadout.find((entry) => entry && entry.id === BASIC_ATTACK.id);
      skill = basic || { ...BASIC_ATTACK, level: 1 };
      resourceCost = resolveSkillCost(skill);
      spentCost = 0;
    } else {
      spentCost = spendResult.spent;
    }
  }
  const result = executeSkill({ actor, opponent, skill, rng: random });
  actor.cooldowns = actor.cooldowns || {};
  actor.cooldowns[skill.id] = skill.cooldown || 0;
  finalizeStatuses(actor);
  const skillResource = resolveSkillResource(skill);
  const { quality, qualityLabel, qualityColor } = resolveSkillQualityMeta(skill);
  return {
    actor,
    opponent,
    skipped: false,
    preEvents,
    events: result.events,
    summary: summary.concat(result.summary),
    skill: {
      id: skill.id,
      name: skill.name,
      type: skill.type || 'active',
      animation: skill.animation || '',
      quality,
      qualityLabel,
      qualityColor,
      skillQuality: quality,
      skillQualityColor: qualityColor,
      rarity: quality,
      rarityLabel: qualityLabel,
      rarityColor: qualityColor,
      resource: {
        type: skillResource.type,
        cost: spentCost || 0
      }
    },
    totalDamage: result.totalDamage,
    totalHeal: result.totalHeal,
    dodged: result.dodged,
    crit: result.crit
  };
}

function decorateSkillLoadout(skillsState, options = {}) {
  return buildSkillLoadout(skillsState, options);
}

function resolveSkillName(skillId) {
  if (!skillId) {
    return '';
  }
  if (skillId === BASIC_ATTACK.id) {
    return BASIC_ATTACK.name;
  }
  const runtime = resolveRuntimeSkill(skillId);
  if (runtime && runtime.name) {
    return runtime.name;
  }
  const definition = SKILL_MAP[skillId];
  return (definition && definition.name) || skillId;
}

module.exports = {
  BASIC_ATTACK,
  buildSkillLoadout,
  decorateSkillLoadout,
  createActorRuntime,
  takeTurn,
  resolveSkillName
};
