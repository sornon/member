'use strict';

const {
  clamp,
  executeAttack,
  resolveCombatStats,
  resolveSpecialStats,
  DEFAULT_COMBAT_STATS,
  DEFAULT_SPECIAL_STATS
} = require('combat-system');
const {
  SKILL_MAP,
  resolveSkillQualityColor,
  resolveSkillQualityLabel,
  resolveSkillElementLabel
} = require('skill-model');
const { BASIC_ATTACK, resolveRuntimeSkill } = require('./config');
const { getSkillCurveConfig } = require('../../balance/config-loader');

const RESOURCE_CONFIG_FALLBACK = {
  type: 'qi',
  baseMax: 100,
  startFraction: 0,
  startValue: 0,
  turnGain: 20,
  basicAttackGain: 10,
  damageTakenGain: 1.5,
  critGain: 1,
  critTakenGain: 1
};
let resourceOverrides = {};

function getResourceConfig() {
  const curves = getSkillCurveConfig();
  const defaults = (curves.resource && curves.resource.defaults) || {};
  return { ...RESOURCE_CONFIG_FALLBACK, ...defaults, ...resourceOverrides };
}

const DEFAULT_RESOURCE_TYPE = RESOURCE_CONFIG_FALLBACK.type;

const CONTROL_EFFECT_CONFIG_FALLBACK = {
  stun: { summary: '眩晕', skip: true, disableBasic: true, disableActive: true, disableDodge: true },
  silence: { summary: '沉默', skip: false, disableBasic: false, disableActive: true, disableDodge: false },
  freeze: {
    summary: '冰冻',
    skip: true,
    disableBasic: true,
    disableActive: true,
    disableDodge: true,
    breakOnFire: true,
    fireDamageMultiplier: 0.1
  },
  sleep: {
    summary: '陷入沉睡',
    skip: true,
    disableBasic: true,
    disableActive: true,
    disableDodge: true,
    wakeOnDamage: true,
    turnResourceGain: 10
  }
};
function getControlEffectConfig() {
  const curves = getSkillCurveConfig();
  const overrides = (curves && curves.controlEffects) || {};
  return { ...CONTROL_EFFECT_CONFIG_FALLBACK, ...overrides };
}
const CONTROL_EFFECT_ALIASES = {
  frozen: 'freeze',
  freezing: 'freeze',
  iced: 'freeze',
  silence: 'silence',
  silenced: 'silence',
  mute: 'silence',
  muted: 'silence',
  sleeping: 'sleep',
  asleep: 'sleep'
};
const CONTROL_FALLBACK_SUMMARY = '被控制';

function normalizeControlEffect(effect) {
  const key = typeof effect === 'string' ? effect.trim().toLowerCase() : '';
  const config = getControlEffectConfig();
  if (config[key]) {
    return key;
  }
  if (CONTROL_EFFECT_ALIASES[key]) {
    return CONTROL_EFFECT_ALIASES[key];
  }
  return 'stun';
}

function mergeControlConfig(target, effectKey, remaining = 0) {
  const effectConfig = getControlEffectConfig()[effectKey];
  const config = effectConfig;
  if (!config) {
    return target;
  }
  if (!target.effects.includes(effectKey)) {
    target.effects.push(effectKey);
  }
  target.skip = target.skip || !!config.skip;
  target.disableBasic = target.disableBasic || !!config.disableBasic;
  target.disableActive = target.disableActive || !!config.disableActive;
  target.disableDodge = target.disableDodge || !!config.disableDodge;
  const normalizedRemaining = Math.max(0, Math.floor(Number(remaining) || 0));
  if (normalizedRemaining > 0) {
    target.remainingByEffect = target.remainingByEffect || {};
    const previous = target.remainingByEffect[effectKey] || 0;
    const updated = Math.max(previous, normalizedRemaining);
    target.remainingByEffect[effectKey] = updated;
    target.remainingTurns = Math.max(target.remainingTurns || 0, updated);
  }
  if (target.summaries && !target.summaries[effectKey]) {
    target.summaries[effectKey] = resolveControlSummary(effectKey);
  }
  return target;
}

function resolveControlState(actor) {
  const state = {
    effects: [],
    skip: false,
    disableBasic: false,
    disableActive: false,
    disableDodge: false,
    remainingTurns: 0,
    remainingByEffect: {},
    summaries: {}
  };
  const statuses = Array.isArray(actor && actor.statuses) ? actor.statuses : [];
  statuses.forEach((status) => {
    if (!status || status.remaining <= 0 || status.type !== 'control') {
      return;
    }
    const params = status.params || {};
    const effect = normalizeControlEffect(params.effect);
    mergeControlConfig(state, effect, status.remaining || 0);
  });
  return state.effects.length ? state : null;
}

function updateActorControlSnapshot(actor) {
  if (!actor) {
    return null;
  }
  const controlState = resolveControlState(actor);
  if (controlState) {
    actor.controlState = controlState;
    actor.controlRuntime = {
      effects: controlState.effects.slice(),
      skip: !!controlState.skip,
      disableBasic: !!controlState.disableBasic,
      disableActive: !!controlState.disableActive,
      disableDodge: !!controlState.disableDodge,
      remainingTurns: controlState.remainingTurns || 0,
      remainingByEffect: { ...controlState.remainingByEffect },
      summaries: { ...controlState.summaries }
    };
  } else {
    actor.controlState = null;
    actor.controlRuntime = {
      effects: [],
      skip: false,
      disableBasic: false,
      disableActive: false,
      disableDodge: false,
      remainingTurns: 0,
      remainingByEffect: {},
      summaries: {}
    };
  }
  return controlState;
}

function resolveControlSummary(effect) {
  if (!effect) {
    return CONTROL_FALLBACK_SUMMARY;
  }
  const key = normalizeControlEffect(effect);
  const config = getControlEffectConfig();
  return (config[key] && config[key].summary) || CONTROL_FALLBACK_SUMMARY;
}

function controlEffectCausesSkip(effect) {
  const key = normalizeControlEffect(effect);
  const config = getControlEffectConfig();
  return config && config[key] ? !!config[key].skip : true;
}

function toNumber(value, fallback = 0) {
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : fallback;
}

function pickRng(actor, fallback) {
  if (actor && typeof actor.rng === 'function') {
    return actor.rng;
  }
  if (typeof fallback === 'function') {
    return fallback;
  }
  return Math.random;
}

function createForcedHitRng(base) {
  const fallback = typeof base === 'function' ? base : Math.random;
  const forced = [0, 0.999999];
  let index = 0;
  return () => {
    if (index < forced.length) {
      const value = forced[index];
      index += 1;
      fallback();
      return value;
    }
    return fallback();
  };
}

function resolveSkillElementMeta(skillId, runtime = {}) {
  const definition = skillId && SKILL_MAP ? SKILL_MAP[skillId] : null;
  const runtimeElement = typeof runtime.element === 'string' && runtime.element ? runtime.element : '';
  const definitionElement = definition && typeof definition.element === 'string' ? definition.element : '';
  const element = runtimeElement || definitionElement || 'none';
  const elementLabel = resolveSkillElementLabel ? resolveSkillElementLabel(element) : '';
  return { element, elementLabel };
}

function buildSkillLoadout(skillsState, options = {}) {
  const loadout = [];
  const equipped = Array.isArray(skillsState && skillsState.equipped) ? skillsState.equipped : [];
  const inventory = new Map();
  const entries = Array.isArray(skillsState && skillsState.inventory) ? skillsState.inventory : [];
  entries.forEach((entry) => {
    if (!entry || typeof entry !== 'object') {
      return;
    }
    const skillId = typeof entry.skillId === 'string' ? entry.skillId.trim() : '';
    if (!skillId) {
      return;
    }
    inventory.set(skillId, Math.max(1, Math.floor(Number(entry.level) || 1)));
  });

  equipped.forEach((rawId) => {
    const skillId = typeof rawId === 'string' ? rawId.trim() : '';
    if (!skillId) {
      return;
    }
    const runtime = resolveRuntimeSkill(skillId);
    if (!runtime || runtime === BASIC_ATTACK) {
      return;
    }
    const level = inventory.get(skillId) || 1;
    const elementMeta = resolveSkillElementMeta(skillId, runtime);
    loadout.push({ ...runtime, ...elementMeta, level });
  });

  const includeBasic = options && options.includeBasic !== false;
  if (includeBasic) {
    const elementMeta = resolveSkillElementMeta(BASIC_ATTACK.id, BASIC_ATTACK);
    loadout.push({ ...BASIC_ATTACK, ...elementMeta, level: 1 });
  }
  return loadout;
}

function resolveResourceNumber(candidates, fallback) {
  for (let i = 0; i < candidates.length; i += 1) {
    const candidate = candidates[i];
    if (candidate === undefined || candidate === null) {
      continue;
    }
    const numeric = Number(candidate);
    if (Number.isFinite(numeric)) {
      return Math.max(0, numeric);
    }
  }
  return Math.max(0, fallback);
}

function toTrimmedString(value) {
  if (typeof value !== 'string') {
    return '';
  }
  return value.trim();
}

function resolveSkillQualityMeta(skill) {
  const skillId = skill && typeof skill.id === 'string' ? skill.id : '';
  const definition = skillId && SKILL_MAP ? SKILL_MAP[skillId] : null;
  const qualityFromSkill = toTrimmedString(skill && skill.quality);
  const qualityFromDefinition = toTrimmedString(definition && definition.quality);
  const quality = qualityFromSkill || qualityFromDefinition || 'linggan';
  const labelFromSkill = toTrimmedString(skill && skill.qualityLabel);
  const qualityLabel = labelFromSkill || toTrimmedString(resolveSkillQualityLabel(quality));
  const colorFromSkill = toTrimmedString(skill && skill.qualityColor);
  const qualityColor = colorFromSkill || toTrimmedString(resolveSkillQualityColor(quality));
  return {
    quality,
    qualityLabel,
    qualityColor
  };
}

function resolveResourceSetup({ combatant, stats, special }) {
  const resourceConfig = getResourceConfig();
  const summary = (combatant && combatant.resource) || combatant || {};
  const resourceCandidates = [
    summary.max,
    summary.maxResource,
    summary.resourceMax,
    stats && stats.resourceMax,
    stats && stats.rageMax,
    stats && stats.qiMax,
    special && special.resourceMax,
    special && special.rageMax,
    special && special.qiMax
  ];
  let resolvedMax = resourceConfig.baseMax;
  for (let i = 0; i < resourceCandidates.length; i += 1) {
    const candidate = Number(resourceCandidates[i]);
    if (Number.isFinite(candidate) && candidate > 0) {
      resolvedMax = Math.max(1, Math.round(candidate));
      break;
    }
  }

  const startCandidates = [
    summary.start,
    summary.initial,
    summary.initialResource,
    summary.resourceStart,
    special && special.resourceStart,
    special && special.rageStart,
    special && special.qiStart
  ];
  let resolvedStart = Number.NaN;
  for (let i = 0; i < startCandidates.length; i += 1) {
    const candidate = startCandidates[i];
    if (candidate === undefined || candidate === null) {
      continue;
    }
    const numeric = Number(candidate);
    if (Number.isFinite(numeric)) {
      if (numeric > 0 && numeric <= 1) {
        resolvedStart = Math.round(resolvedMax * clamp(numeric, 0, 1));
      } else {
        resolvedStart = Math.round(numeric);
      }
      break;
    }
  }
  if (!Number.isFinite(resolvedStart)) {
    if (Number.isFinite(resourceConfig.startValue)) {
      resolvedStart = Math.round(Math.max(0, resourceConfig.startValue));
    } else {
      resolvedStart = Math.round(resolvedMax * clamp(resourceConfig.startFraction, 0, 1));
    }
  }
  const resourceTypeCandidate =
    (summary && summary.type) ||
    (combatant && combatant.resourceType) ||
    (special && special.resourceType) ||
    resourceConfig.type;
  const resourceType = typeof resourceTypeCandidate === 'string' && resourceTypeCandidate.trim()
    ? resourceTypeCandidate.trim()
    : resourceConfig.type;
  const turnGain = resolveResourceNumber(
    [
      summary.turnGain,
      summary.perTurnGain,
      summary.regen,
      summary.gainPerTurn,
      stats && stats.resourceTurnGain,
      stats && stats.rageTurnGain,
      stats && stats.qiTurnGain,
      special && special.resourceTurnGain,
      special && special.rageTurnGain,
      special && special.qiTurnGain
    ],
    resourceConfig.turnGain
  );
  const basicAttackGain = resolveResourceNumber(
    [
      summary.basicAttackGain,
      summary.basicGain,
      summary.onAttackGain,
      summary.attackGain,
      stats && stats.basicAttackResourceGain,
      stats && stats.resourceAttackGain,
      stats && stats.attackGain,
      special && special.basicAttackResourceGain,
      special && special.resourceAttackGain,
      special && special.attackGain
    ],
    resourceConfig.basicAttackGain
  );
  const damageTakenGain = resolveResourceNumber(
    [
      summary.damageTakenGain,
      summary.onDamageGain,
      summary.damageGain,
      summary.beingHitGain,
      stats && stats.damageTakenResourceGain,
      stats && stats.resourceDamageGain,
      stats && stats.damageTakenGain,
      special && special.damageTakenResourceGain,
      special && special.resourceDamageGain,
      special && special.damageTakenGain
    ],
    resourceConfig.damageTakenGain
  );
  const critGain = resolveResourceNumber(
    [
      summary.critGain,
      summary.onCritGain,
      stats && stats.resourceCritGain,
      stats && stats.critResourceGain,
      special && special.resourceCritGain
    ],
    resourceConfig.critGain
  );
  const critTakenGain = resolveResourceNumber(
    [
      summary.critTakenGain,
      summary.onCritTakenGain,
      stats && stats.resourceCritTakenGain,
      stats && stats.critTakenResourceGain,
      special && special.resourceCritTakenGain
    ],
    resourceConfig.critTakenGain
  );
  return {
    max: Math.max(1, resolvedMax),
    start: clamp(resolvedStart, 0, Math.max(1, resolvedMax)),
    type: resourceType,
    turnGain,
    basicAttackGain,
    damageTakenGain,
    critGain,
    critTakenGain
  };
}

function clampResource(actor, value) {
  if (!actor) {
    return 0;
  }
  const resourceConfig = getResourceConfig();
  const max = Math.max(0, Math.round(actor.resourceMax || resourceConfig.baseMax));
  return Math.max(0, Math.min(max, Math.round(value)));
}

function resolveActorResourceGain(actor, key) {
  const resourceConfig = getResourceConfig();
  if (!actor) {
    return resourceConfig[key];
  }
  const propertyMap = {
    turnGain: 'resourceTurnGain',
    basicAttackGain: 'resourceBasicGain',
    damageTakenGain: 'resourceDamageTakenGain',
    critGain: 'resourceCritGain',
    critTakenGain: 'resourceCritTakenGain'
  };
  const property = propertyMap[key];
  if (property && Number.isFinite(actor[property])) {
    return Math.max(0, Number(actor[property]));
  }
  return resourceConfig[key];
}

function calculateDamageTakenResourceGain(actor, damage) {
  if (!actor || !Number.isFinite(damage) || damage <= 0) {
    return 0;
  }
  const maxHp = Math.max(1, Math.round(actor.maxHp || actor.hpMax || DEFAULT_COMBAT_STATS.maxHp));
  const percentLost = Math.max(0, damage) / maxHp;
  if (percentLost <= 0) {
    return 0;
  }
  const resourceConfig = getResourceConfig();
  const resourceMax = Math.max(1, Math.round(actor.resourceMax || resourceConfig.baseMax));
  const multiplier = resolveActorResourceGain(actor, 'damageTakenGain');
  if (multiplier <= 0) {
    return 0;
  }
  return percentLost * multiplier * resourceMax;
}

function configureResourceDefaults(overrides = {}) {
  if (!overrides || typeof overrides !== 'object') {
    resourceOverrides = {};
    return getResourceConfig();
  }
  const nextOverrides = { ...resourceOverrides };
  if (Number.isFinite(overrides.baseMax) && overrides.baseMax > 0) {
    nextOverrides.baseMax = Math.max(1, Math.round(overrides.baseMax));
  }
  if (Number.isFinite(overrides.startFraction)) {
    nextOverrides.startFraction = clamp(overrides.startFraction, 0, 1);
  }
  if (Number.isFinite(overrides.startValue)) {
    nextOverrides.startValue = Math.max(0, overrides.startValue);
  }
  if (Number.isFinite(overrides.turnGain)) {
    nextOverrides.turnGain = Math.max(0, overrides.turnGain);
  }
  if (Number.isFinite(overrides.basicAttackGain)) {
    nextOverrides.basicAttackGain = Math.max(0, overrides.basicAttackGain);
  }
  if (Number.isFinite(overrides.damageTakenGain)) {
    nextOverrides.damageTakenGain = Math.max(0, overrides.damageTakenGain);
  }
  if (Number.isFinite(overrides.critGain)) {
    nextOverrides.critGain = Math.max(0, overrides.critGain);
  }
  if (Number.isFinite(overrides.critTakenGain)) {
    nextOverrides.critTakenGain = Math.max(0, overrides.critTakenGain);
  }
  if (typeof overrides.type === 'string' && overrides.type.trim()) {
    nextOverrides.type = overrides.type.trim();
  }
  resourceOverrides = nextOverrides;
  return getResourceConfig();
}

function applyResourceDelta(actor, delta, { events, summary, source, includeSummary = false } = {}) {
  if (!actor || !Number.isFinite(delta) || delta === 0) {
    return 0;
  }
  const before = Math.round(Number(actor.resource) || 0);
  const target = before + delta;
  const after = clampResource(actor, target);
  const applied = after - before;
  if (!applied) {
    return 0;
  }
  actor.resource = after;
  const resourceConfig = getResourceConfig();
  if (Array.isArray(events)) {
    events.push({
      type: 'resource',
      targetId: actor.id,
      targetSide: actor.side,
      resourceType: actor.resourceType || resourceConfig.type,
      before,
      change: applied,
      after,
      max: Math.max(0, Math.round(actor.resourceMax || resourceConfig.baseMax)),
      source
    });
  }
  if (includeSummary && Array.isArray(summary)) {
    summary.push(
      applied > 0
        ? `${actor.name}恢复${applied}点真气`
        : `${actor.name}消耗${Math.abs(applied)}点真气`
    );
  }
  return applied;
}

function resolveResourceGainMultiplier(actor, stats) {
  if (!actor) {
    return 0;
  }
  let rageGain = 0;
  if (stats && Number.isFinite(stats.rageGain)) {
    rageGain = Number(stats.rageGain);
  } else {
    const snapshot = resolveEffectiveStats(actor, { mode: 'attack' });
    rageGain = Number(snapshot.stats && snapshot.stats.rageGain ? snapshot.stats.rageGain : 0);
  }
  return Math.max(0, 1 + rageGain);
}

function gainResource(actor, baseAmount, { events, summary, source, stats } = {}) {
  if (!actor || !Number.isFinite(baseAmount) || baseAmount <= 0) {
    return 0;
  }
  const multiplier = resolveResourceGainMultiplier(actor, stats);
  const amount = Math.round(Math.max(0, baseAmount) * multiplier);
  if (amount <= 0) {
    return 0;
  }
  return applyResourceDelta(actor, amount, { events, summary, source });
}

function spendResource(actor, amount, { events, summary, source, includeSummary = true } = {}) {
  if (!actor || !Number.isFinite(amount) || amount <= 0) {
    return { success: true, spent: 0 };
  }
  const cost = Math.round(Math.max(0, amount));
  const available = Math.round(Number(actor.resource) || 0);
  if (available < cost) {
    return { success: false, spent: 0 };
  }
  const applied = applyResourceDelta(actor, -cost, {
    events,
    summary,
    source,
    includeSummary
  });
  return { success: applied !== 0 || cost === 0, spent: Math.abs(applied) };
}

function applyTurnStartResourceGain(actor, { events, summary } = {}) {
  const amount = resolveActorResourceGain(actor, 'turnGain');
  return gainResource(actor, amount, {
    events,
    summary,
    source: 'turn_start'
  });
}

function resolveSkillResource(skill) {
  if (!skill || typeof skill !== 'object') {
    return { type: getResourceConfig().type, cost: 0 };
  }
  const resourceConfig = getResourceConfig();
  const resource = skill.resource || {};
  const type = typeof resource.type === 'string' && resource.type ? resource.type : resourceConfig.type;
  let cost = 0;
  if (Number.isFinite(resource.cost)) {
    cost = Math.max(0, Math.round(resource.cost));
  } else if (Number.isFinite(skill.cost)) {
    cost = Math.max(0, Math.round(skill.cost));
  }
  return { type, cost };
}

function resolveSkillCost(skill) {
  const resource = resolveSkillResource(skill);
  return resource.cost || 0;
}

function normalizeCombatantStats(combatant = {}) {
  const stats = resolveCombatStats(combatant, {
    defaults: DEFAULT_COMBAT_STATS,
    convertLegacyPercentages: true
  });
  const special = resolveSpecialStats(combatant.special || combatant.skillSummary || {}, {
    defaults: DEFAULT_SPECIAL_STATS,
    convertLegacyPercentages: true
  });
  return { stats, special };
}

function createActorRuntime({
  id,
  name,
  side,
  combatant,
  skills,
  rng,
  mode
}) {
  const { stats, special } = normalizeCombatantStats(combatant);
  const baseStats = { ...stats };
  const baseSpecial = { ...special };
  const maxHp = Math.max(1, Math.round(stats.maxHp || DEFAULT_COMBAT_STATS.maxHp));
  const shield = Math.max(0, Math.round(special.shield || 0));
  const loadout = Array.isArray(skills) && skills.length ? skills : buildSkillLoadout({}, {});
  const resourceSetup = resolveResourceSetup({ combatant, stats, special });
  const actor = {
    id: typeof id === 'string' && id ? id : side === 'opponent' ? 'opponent' : 'player',
    name: typeof name === 'string' && name ? name : side === 'opponent' ? '敌方' : '我方',
    side: side || 'player',
    stats,
    special,
    baseStats,
    baseSpecial,
    maxHp,
    hp: maxHp + shield,
    resourceType: resourceSetup.type,
    resourceMax: resourceSetup.max,
    resource: resourceSetup.start,
    resourceTurnGain: resourceSetup.turnGain,
    resourceBasicGain: resourceSetup.basicAttackGain,
    resourceDamageTakenGain: resourceSetup.damageTakenGain,
    resourceCritGain: resourceSetup.critGain,
    resourceCritTakenGain: resourceSetup.critTakenGain,
    skillLoadout: loadout.length ? loadout : [{ ...BASIC_ATTACK, level: 1 }],
    cooldowns: {},
    statuses: [],
    rng: typeof rng === 'function' ? rng : null,
    mode: mode || 'pve',
    history: [],
    defeated: false,
    controlRuntime: {
      effects: [],
      skip: false,
      disableBasic: false,
      disableActive: false,
      disableDodge: false,
      remainingTurns: 0,
      remainingByEffect: {},
      summaries: {}
    }
  };
  updateActorControlSnapshot(actor);
  return actor;
}

function decrementCooldowns(actor) {
  if (!actor || !actor.cooldowns) {
    return;
  }
  Object.keys(actor.cooldowns).forEach((skillId) => {
    const value = actor.cooldowns[skillId];
    if (Number.isFinite(value) && value > 0) {
      actor.cooldowns[skillId] = Math.max(0, value - 1);
    }
  });
}

function hasActiveStatus(actor, predicate) {
  if (!actor || !Array.isArray(actor.statuses)) {
    return false;
  }
  return actor.statuses.some((status) => status && status.remaining > 0 && predicate(status));
}

function getActiveStatuses(actor, predicate) {
  if (!actor || !Array.isArray(actor.statuses)) {
    return [];
  }
  return actor.statuses.filter((status) => status && status.remaining > 0 && predicate(status));
}

function clearControlEffects(actor, effect) {
  if (!actor || !effect) {
    return 0;
  }
  const normalized = normalizeControlEffect(effect);
  const matches = getActiveStatuses(
    actor,
    (status) => status.type === 'control' && normalizeControlEffect(status.params && status.params.effect) === normalized
  );
  if (!matches.length) {
    return 0;
  }
  matches.forEach((status) => removeStatus(actor, status));
  updateActorControlSnapshot(actor);
  return matches.length;
}

function applyIncomingDamageModifiers(target, damage, { element, summary } = {}) {
  let adjusted = Math.max(0, damage);
  if (!target || adjusted <= 0) {
    return { damage: adjusted };
  }
  const elementKey = typeof element === 'string' ? element : '';
  const freezeConfig = getControlEffectConfig().freeze;
  if (elementKey === 'fire' && freezeConfig && freezeConfig.breakOnFire) {
    const cleared = clearControlEffects(target, 'freeze');
    if (cleared > 0) {
      const multiplier = Number.isFinite(freezeConfig.fireDamageMultiplier)
        ? Math.max(0, freezeConfig.fireDamageMultiplier)
        : 0.1;
      adjusted *= multiplier;
      if (Array.isArray(summary)) {
        const reductionPercent = Math.round((1 - multiplier) * 100);
        summary.push(`${target.name}身上的冰冻被火系攻击击碎，所受伤害降低${reductionPercent}%`);
      }
    }
  }
  return { damage: adjusted };
}

function handleDamageWakeEffects(target, damage, { summary, reason } = {}) {
  if (!target || !Number.isFinite(damage) || damage <= 0) {
    return;
  }
  const sleepConfig = getControlEffectConfig().sleep;
  if (!sleepConfig || !sleepConfig.wakeOnDamage) {
    return;
  }
  const cleared = clearControlEffects(target, 'sleep');
  if (cleared > 0 && Array.isArray(summary)) {
    const wakeReason = reason === 'dot' ? '持续伤害' : '伤害';
    summary.push(`${target.name}在${wakeReason}中惊醒，沉睡被打断`);
  }
}

function getBaseStat(actor, key) {
  if (!actor) {
    return 0;
  }
  if (Object.prototype.hasOwnProperty.call(actor.baseStats, key)) {
    return actor.baseStats[key];
  }
  if (Object.prototype.hasOwnProperty.call(actor.baseSpecial, key)) {
    return actor.baseSpecial[key];
  }
  return 0;
}

function applyStatDelta(target, key, delta) {
  if (Object.prototype.hasOwnProperty.call(target.stats, key)) {
    target.stats[key] += delta;
    return;
  }
  if (Object.prototype.hasOwnProperty.call(target.special, key)) {
    target.special[key] += delta;
  }
}

function resolveEffectiveStats(actor, { mode = 'attack' } = {}) {
  const stats = { ...actor.stats };
  const special = { ...actor.special };
  const extra = {
    extraDamageRatio: 0,
    reflectRatio: 0,
    followUp: []
  };
  const modifiers = Array.isArray(actor.statuses) ? actor.statuses : [];
  modifiers.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    const params = status.params || {};
    switch (status.type) {
      case 'stat': {
        applyStatDelta({ stats, special }, status.key, status.delta);
        break;
      }
      case 'extraDamage':
        if (mode === 'attack') {
          extra.extraDamageRatio += params.ratio || 0;
        }
        break;
      case 'reflect':
        if (mode === 'defense') {
          extra.reflectRatio += params.ratio || 0;
        }
        break;
      case 'shield':
        if (mode === 'defense' && params.reflectRatio) {
          extra.reflectRatio += params.reflectRatio;
        }
        if (mode === 'attack' && params.burstRatio) {
          extra.followUp.push({ type: 'burst', ratio: params.burstRatio, kind: params.kind || 'magic' });
        }
        break;
      case 'domain':
        if (mode === 'attack') {
          extra.extraDamageRatio += params.ratio || 0;
        }
        break;
      default:
        break;
    }
  });
  if (mode === 'defense') {
    const controlState = actor && actor.controlRuntime ? actor.controlRuntime : updateActorControlSnapshot(actor);
    if (controlState && controlState.disableDodge) {
      stats.dodge = 0;
      if (Object.prototype.hasOwnProperty.call(special, 'dodgeChance')) {
        special.dodgeChance = 0;
      }
    }
  }
  return { stats, special, extra };
}

function createStatus(base) {
  const status = {
    id: base && base.id ? base.id : `status_${Date.now()}_${Math.random().toString(16).slice(2)}`,
    source: base && base.source,
    type: base && base.type,
    remaining: Math.max(0, Math.floor(base && base.remaining ? base.remaining : 0)),
    params: base && base.params ? { ...base.params } : {},
    key: base && base.key ? base.key : null,
    delta: base && typeof base.delta === 'number' ? base.delta : 0
  };
  return status;
}

function addStatus(target, descriptor, options = {}) {
  if (!target || !descriptor) {
    return null;
  }
  const duration = Math.max(0, Math.floor(descriptor.duration || 0));
  if (duration <= 0 && descriptor.type !== 'shield') {
    return null;
  }
  const status = createStatus({
    source: options.source,
    type: descriptor.type,
    remaining: duration,
    params: descriptor.params || {}
  });

  if (descriptor.type === 'stat') {
    const key = descriptor.stat;
    if (!key) {
      return null;
    }
    const baseValue = getBaseStat(target, key);
    const mode = descriptor.mode || 'flat';
    const value = toNumber(descriptor.value, 0);
    const delta = mode === 'percent' ? baseValue * value : value;
    status.key = key;
    status.delta = delta;
    status.params.mode = mode;
  } else if (descriptor.type === 'shield') {
    const ratio = descriptor.ratioOfMaxHp || 0;
    const bonus = Math.max(0, target.maxHp * ratio);
    status.params.shieldValue = bonus;
    status.params.maxShield = bonus;
    status.params.removeOnExpire = true;
    status.remaining = Math.max(1, duration || descriptor.duration || 1);
    target.hp += bonus;
  } else if (descriptor.type === 'reflect') {
    const ratio = descriptor.ratio || (descriptor.params && descriptor.params.ratio) || 0;
    status.params.ratio = ratio;
    status.remaining = Math.max(1, duration || 2);
  } else if (descriptor.type === 'extraDamage') {
    const ratio = descriptor.ratio || (descriptor.params && descriptor.params.ratio) || 0;
    status.params.ratio = ratio;
    status.type = 'domain';
    status.remaining = Math.max(1, duration || 1);
  } else if (descriptor.type === 'control') {
    const effect = descriptor.effect || status.params.effect || 'stun';
    status.params.effect = normalizeControlEffect(effect);
    status.remaining = Math.max(1, duration || 1);
  } else if (descriptor.type === 'dot') {
    status.params.attribute = descriptor.attribute || 'magicAttack';
    status.params.ratio = descriptor.ratio || 0;
    status.params.kind = descriptor.dotType || descriptor.typeLabel || 'dot';
    status.remaining = Math.max(1, duration || 1);
  }

  target.statuses = Array.isArray(target.statuses) ? target.statuses : [];
  target.statuses.push(status);
  updateActorControlSnapshot(target);
  return status;
}

function removeStatus(target, status) {
  if (!target || !Array.isArray(target.statuses)) {
    return;
  }
  const index = target.statuses.indexOf(status);
  if (index >= 0) {
    target.statuses.splice(index, 1);
    updateActorControlSnapshot(target);
  }
}

function applyShieldExpiration(actor, status) {
  if (!actor || !status || status.type !== 'shield') {
    return;
  }
  const params = status.params || {};
  const shieldValue = Math.max(0, params.shieldValue || 0);
  if (shieldValue <= 0) {
    return;
  }
  const excess = Math.max(0, actor.hp - actor.maxHp);
  if (excess > 0) {
    const reduction = Math.min(excess, shieldValue);
    actor.hp = Math.max(actor.maxHp, actor.hp - reduction);
  }
}

function processStartStatuses({ actor, opponent, rng, events = [], summary = [] }) {
  let skip = false;
  let defeated = false;
  let skipEffect = '';
  let cachedResourceStats = null;
  const controlState = updateActorControlSnapshot(actor);
  actor.silenced = false;
  if (controlState) {
    actor.silenced = controlState.effects.includes('silence');
    const skipCandidate = controlState.effects.find((effect) => controlEffectCausesSkip(effect));
    if (skipCandidate) {
      skip = true;
      skipEffect = skipCandidate;
    }
  }
  const resolveActorResourceStats = () => {
    if (!cachedResourceStats) {
      cachedResourceStats = resolveEffectiveStats(actor, { mode: 'attack' }).stats;
    }
    return cachedResourceStats;
  };
  const sleepConfig = getControlEffectConfig().sleep;
  if (controlState && controlState.effects.includes('sleep') && sleepConfig && sleepConfig.turnResourceGain > 0) {
    gainResource(actor, sleepConfig.turnResourceGain, {
      events,
      summary,
      source: 'sleep',
      stats: resolveActorResourceStats()
    });
  }
  const statuses = Array.isArray(actor.statuses) ? actor.statuses.slice() : [];
  statuses.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    const params = status.params || {};
    switch (status.type) {
      case 'control': {
        break;
      }
      case 'dot': {
        const attribute = params.attribute || 'magicAttack';
        const ratio = params.ratio || 0;
        if (ratio <= 0) {
          break;
        }
        const attackerStats = resolveEffectiveStats(opponent || actor, { mode: 'attack' }).stats;
        const sourceStat = attribute && attribute in attackerStats ? attackerStats[attribute] : attackerStats.magicAttack;
        let damage = Math.max(0, sourceStat * ratio);
        const defenderStats = resolveEffectiveStats(actor, { mode: 'defense' });
        const finalBonus = defenderStats.stats.finalDamageBonus || 0;
        const finalReduction = defenderStats.stats.finalDamageReduction || 0;
        const finalMultiplier = Math.max(0.1, 1 + finalBonus - finalReduction);
        damage *= finalMultiplier;
        damage = Math.max(1, damage);
        const dotElement = params.kind === 'burning' ? 'fire' : '';
        const mitigated = applyIncomingDamageModifiers(actor, damage, { element: dotElement, summary });
        damage = Math.max(1, mitigated.damage);
        actor.hp = Math.max(0, actor.hp - damage);
        events.push({
          type: 'damage',
          targetId: actor.id,
          targetSide: actor.side,
          value: Math.round(damage),
          source: status.source || 'dot'
        });
        summary.push(`${actor.name}受到持续伤害 ${Math.round(damage)} 点`);
        const damageGain = calculateDamageTakenResourceGain(actor, damage);
        gainResource(actor, damageGain, {
          events,
          summary,
          source: status.source || 'dot',
          stats: resolveActorResourceStats()
        });
        handleDamageWakeEffects(actor, damage, { summary, reason: params.kind || 'dot' });
        if (actor.hp <= 0) {
          defeated = true;
        }
        break;
      }
      default:
        break;
    }
  });
  return { skip, defeated, controlEffect: skipEffect };
}

function hasStatusEffect(actor, effect) {
  return hasActiveStatus(actor, (status) => status && status.type === 'control' && status.params && status.params.effect === effect);
}

function chooseSkill(actor) {
  if (!actor || !Array.isArray(actor.skillLoadout) || !actor.skillLoadout.length) {
    return { ...BASIC_ATTACK, level: 1 };
  }
  const controlState = actor.controlState || resolveControlState(actor);
  const silenced = controlState ? controlState.disableActive : hasStatusEffect(actor, 'silence');
  const basicDisabled = controlState ? controlState.disableBasic : false;
  const availableResource = Math.max(0, Math.round(Number(actor.resource) || 0));
  for (let i = 0; i < actor.skillLoadout.length; i += 1) {
    const skill = actor.skillLoadout[i];
    if (!skill || skill.id === BASIC_ATTACK.id) {
      continue;
    }
    const cooldown = actor.cooldowns[skill.id] || 0;
    if (cooldown > 0) {
      continue;
    }
    if (silenced && skill.type && skill.type !== 'passive' && skill.type !== 'basic') {
      continue;
    }
    const cost = resolveSkillCost(skill);
    if (cost > availableResource) {
      continue;
    }
    return skill;
  }
  if (!basicDisabled) {
    const basic = actor.skillLoadout.find((skill) => skill && skill.id === BASIC_ATTACK.id);
    if (basic) {
      return basic;
    }
  }
  return { ...BASIC_ATTACK, level: 1 };
}

function evaluateControlAttempt(controlDescriptor, level, rng) {
  if (!controlDescriptor) {
    return { success: false, effect: '', roll: null };
  }
  const chance = (controlDescriptor.chance || 0) + (controlDescriptor.perLevel || 0) * Math.max(0, level - 1);
  const threshold = clamp(chance, 0, 1);
  const randomValue = typeof rng === 'function' ? rng() : Math.random();
  if (randomValue > threshold) {
    return { success: false, effect: '', roll: randomValue, threshold };
  }
  const effect = normalizeControlEffect(controlDescriptor.type || controlDescriptor.effect || 'stun');
  return { success: true, effect, roll: randomValue, threshold };
}

function applyControl(opponent, controlDescriptor, skillId, level, rng, attempt) {
  if (!opponent || !controlDescriptor) {
    return '';
  }
  let outcome = attempt;
  if (!outcome || typeof outcome !== 'object' || !Object.prototype.hasOwnProperty.call(outcome, 'success')) {
    outcome = evaluateControlAttempt(controlDescriptor, level, rng);
  }
  if (!outcome.success) {
    return '';
  }
  const effect = normalizeControlEffect(outcome.effect || controlDescriptor.type || controlDescriptor.effect || 'stun');
  addStatus(opponent, {
    type: 'control',
    duration: controlDescriptor.duration || 1,
    params: { effect }
  }, { source: skillId });
  return effect;
}

function applyDot(opponent, descriptor, skillId, level) {
  const ratio = (descriptor.ratio || 0) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
  if (ratio <= 0) {
    return;
  }
  addStatus(opponent, {
    type: 'dot',
    duration: descriptor.duration || 1,
    attribute: descriptor.attribute || 'magicAttack',
    ratio,
    dotType: descriptor.type || 'dot'
  }, { source: skillId });
}

function applyStatDebuffs(target, list, skillId, level) {
  if (!target || !Array.isArray(list)) {
    return;
  }
  list.forEach((entry) => {
    if (!entry) {
      return;
    }
    const value = (entry.value || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
    if (!value) {
      return;
    }
    addStatus(target, {
      type: 'stat',
      stat: entry.stat,
      mode: entry.mode || 'flat',
      value,
      duration: entry.duration || 1
    }, { source: skillId });
  });
}

function applyBuffs(target, list, skillId, level) {
  if (!target || !Array.isArray(list)) {
    return;
  }
  list.forEach((entry) => {
    if (!entry) {
      return;
    }
    switch (entry.type) {
      case 'stat': {
        const value = (entry.value || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, {
          type: 'stat',
          stat: entry.stat,
          mode: entry.mode || 'flat',
          value,
          duration: entry.duration || 1
        }, { source: skillId });
        break;
      }
      case 'shield': {
        const ratio = (entry.ratioOfMaxHp || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        const status = addStatus(target, {
          type: 'shield',
          ratioOfMaxHp: ratio,
          duration: entry.duration || 1
        }, { source: skillId });
        if (status && entry.reflectRatio) {
          status.params.reflectRatio = (entry.reflectRatio || 0) + (entry.reflectPerLevel || 0) * Math.max(0, level - 1);
        }
        if (status && entry.burstRatio) {
          status.params.burstRatio = entry.burstRatio;
          status.params.kind = entry.kind || 'magic';
        }
        break;
      }
      case 'reflect': {
        const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, { type: 'reflect', duration: entry.duration || 2, params: { ratio } }, { source: skillId });
        break;
      }
      case 'extraDamage': {
        const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, { type: 'extraDamage', duration: entry.duration || 2, params: { ratio } }, { source: skillId });
        break;
      }
      default:
        break;
    }
  });
}

function calculateBonusDamage(baseDamage, ratio) {
  if (!baseDamage || !ratio) {
    return 0;
  }
  return Math.max(0, baseDamage * ratio);
}

function executeSkill({ actor, opponent, skill, rng }) {
  const events = [];
  const summary = [];
  const level = Math.max(1, Math.floor(skill.level || 1));
  const random = pickRng(actor, rng);
  const shouldSuppressDodge = () => {
    if (!opponent) {
      return false;
    }
    const controlState = updateActorControlSnapshot(opponent);
    if (controlState && controlState.disableDodge) {
      return true;
    }
    if (opponent && opponent.controlRuntime && opponent.controlRuntime.disableDodge) {
      return true;
    }
    return pendingControlDisable;
  };
  const skillElement = typeof skill.element === 'string' ? skill.element : '';
  const { stats: attackerStats, special: attackerSpecial, extra: attackerExtra } = resolveEffectiveStats(actor, {
    mode: 'attack'
  });
  const { stats: defenderStats, special: defenderSpecial, extra: defenderExtra } = resolveEffectiveStats(opponent, {
    mode: 'defense'
  });
  const opponentAttackStats = opponent ? resolveEffectiveStats(opponent, { mode: 'attack' }).stats : null;

  let totalDamage = 0;
  let totalHeal = 0;
  let dodged = false;
  let crit = false;

  const controlAttempt = skill.control ? evaluateControlAttempt(skill.control, level, random) : null;
  const controlEffectConfig = getControlEffectConfig();
  let pendingControlDisable = !!(
    controlAttempt &&
    controlAttempt.success &&
    controlEffectConfig[controlAttempt.effect] &&
    controlEffectConfig[controlAttempt.effect].disableDodge
  );

  const damageDescriptors = Array.isArray(skill.damage) && skill.damage.length ? skill.damage : [{ kind: 'auto', ratio: 1 }];
  const followUpDescriptors = [];
  if (skill.followUp) {
    const followDescriptor = { ...skill.followUp };
    if (!followDescriptor.type) {
      followDescriptor.type = 'burst';
    }
    followDescriptor.ratio =
      (followDescriptor.ratio || 0) + (followDescriptor.perLevel || 0) * Math.max(0, level - 1);
    followDescriptor.kind = followDescriptor.kind || 'magic';
    followDescriptor.source = skill.id;
    followUpDescriptors.push(followDescriptor);
  }
  if (Array.isArray(attackerExtra.followUp)) {
    attackerExtra.followUp.forEach((descriptor) => {
      if (!descriptor) {
        return;
      }
      const followDescriptor = {
        ...descriptor,
        ratio: descriptor.ratio || 0,
        kind: descriptor.kind || 'magic',
        type: descriptor.type || 'burst',
        source: descriptor.source || 'status'
      };
      followUpDescriptors.push(followDescriptor);
    });
  }

  damageDescriptors.forEach((descriptor) => {
    const hits = Math.max(1, Math.floor(descriptor.hits || 1));
    for (let i = 0; i < hits; i += 1) {
      const attackStats = { ...attackerStats };
      const defenseStats = { ...defenderStats };
      if (descriptor.kind === 'physical') {
        const ratio = (descriptor.ratio || 1) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
        attackStats.physicalAttack = Math.max(0, attackStats.physicalAttack * ratio);
      } else if (descriptor.kind === 'magic') {
        const ratio = (descriptor.ratio || 1) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
        attackStats.magicAttack = Math.max(0, attackStats.magicAttack * ratio);
      }
      const attackRng = shouldSuppressDodge() ? createForcedHitRng(random) : random;
      const result = executeAttack(attackStats, attackerSpecial, defenseStats, defenderSpecial, attackRng);
      dodged = dodged || result.dodged;
      if (result.dodged) {
        events.push({ type: 'dodge', targetId: opponent.id, targetSide: opponent.side });
        summary.push(`${opponent.name}闪避了攻击`);
        continue;
      }
      crit = crit || result.crit;
      let damage = Math.max(1, result.damage);
      if (descriptor.extraOnCritRatio && result.crit) {
        const extraRatio = descriptor.extraOnCritRatio + (descriptor.extraOnCritPerLevel || 0) * Math.max(0, level - 1);
        damage += calculateBonusDamage(result.damage, extraRatio);
      }
      if (attackerExtra.extraDamageRatio) {
        damage += calculateBonusDamage(result.damage, attackerExtra.extraDamageRatio);
      }
      damage = Math.max(1, damage);
      const mitigated = applyIncomingDamageModifiers(opponent, damage, { element: skillElement, summary });
      damage = Math.max(1, mitigated.damage);
      opponent.hp = Math.max(0, opponent.hp - damage);
      totalDamage += damage;
      events.push({
        type: 'damage',
        targetId: opponent.id,
        targetSide: opponent.side,
        value: Math.round(damage),
        crit: !!result.crit
      });
      summary.push(`${actor.name}造成 ${Math.round(damage)} 点伤害${result.crit ? '（暴击）' : ''}`);
      const opponentDamageGain = calculateDamageTakenResourceGain(opponent, damage);
      gainResource(opponent, opponentDamageGain, {
        events,
        source: skill.id || 'damage',
        stats: opponentAttackStats
      });
      handleDamageWakeEffects(opponent, damage, { summary, reason: 'skill' });
      if (result.crit) {
        const critGainAmount = resolveActorResourceGain(actor, 'critGain');
        gainResource(actor, critGainAmount, {
          events,
          source: 'critical_hit',
          stats: attackerStats
        });
        const critTakenGainAmount = resolveActorResourceGain(opponent, 'critTakenGain');
        gainResource(opponent, critTakenGainAmount, {
          events,
          source: 'critical_taken',
          stats: opponentAttackStats
        });
      }
      if (result.heal > 0) {
        const healValue = Math.max(0, result.heal);
        const before = actor.hp;
        actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + healValue);
        const applied = Math.max(0, actor.hp - before);
        if (applied > 0) {
          totalHeal += applied;
          events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied) });
          summary.push(`${actor.name}回复 ${Math.round(applied)} 点生命`);
        }
      }
      if (defenderExtra.reflectRatio) {
        const reflected = calculateBonusDamage(damage, defenderExtra.reflectRatio);
        if (reflected > 0) {
          actor.hp = Math.max(0, actor.hp - reflected);
          events.push({ type: 'damage', targetId: actor.id, targetSide: actor.side, value: Math.round(reflected), source: 'reflect' });
          summary.push(`${actor.name}受到反伤 ${Math.round(reflected)} 点`);
          const reflectDamageGain = calculateDamageTakenResourceGain(actor, reflected);
          gainResource(actor, reflectDamageGain, {
            events,
            source: 'reflect',
            stats: attackerStats
          });
        }
      }
    }
  });

  if (Array.isArray(skill.conditionalDamage)) {
    skill.conditionalDamage.forEach((entry) => {
      if (!entry) {
        return;
      }
      const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
      if (!ratio) {
        return;
      }
      const conditionMet = entry.condition === 'burning' ? hasActiveStatus(opponent, (status) => status.type === 'dot' && status.params && status.params.kind === 'burning') : false;
      if (!conditionMet) {
        return;
      }
      const baseDamage = entry.kind === 'physical' ? attackerStats.physicalAttack : attackerStats.magicAttack;
      const bonusDamage = Math.max(1, baseDamage * ratio);
      const mitigated = applyIncomingDamageModifiers(opponent, bonusDamage, {
        element: entry.element || skillElement,
        summary
      });
      const finalBonusDamage = Math.max(1, mitigated.damage);
      opponent.hp = Math.max(0, opponent.hp - finalBonusDamage);
      totalDamage += finalBonusDamage;
      events.push({ type: 'damage', targetId: opponent.id, targetSide: opponent.side, value: Math.round(finalBonusDamage) });
      summary.push(`${actor.name}引燃弱点，追加 ${Math.round(finalBonusDamage)} 点伤害`);
      handleDamageWakeEffects(opponent, finalBonusDamage, { summary, reason: 'conditional' });
      const conditionalDamageGain = calculateDamageTakenResourceGain(opponent, finalBonusDamage);
      gainResource(opponent, conditionalDamageGain, {
        events,
        source: skill.id || 'conditional',
        stats: opponentAttackStats
      });
    });
  }

  if (Array.isArray(skill.dots)) {
    skill.dots.forEach((dot) => applyDot(opponent, dot, skill.id, level));
  }

  if (Array.isArray(skill.debuffs)) {
    applyStatDebuffs(opponent, skill.debuffs, skill.id, level);
  }

  if (skill.control) {
    const effect = applyControl(opponent, skill.control, skill.id, level, random, controlAttempt);
    pendingControlDisable = false;
    if (effect) {
      summary.push(`${opponent.name}${resolveControlSummary(effect)}`);
    }
  }

  if (Array.isArray(skill.buffs)) {
    applyBuffs(actor, skill.buffs, skill.id, level);
  }

  const followUpResults = followUpDescriptors.filter((descriptor) => descriptor.ratio > 0);
  followUpResults.forEach((descriptor) => {
    if (descriptor.source === skill.id && totalDamage <= 0) {
      return;
    }
    const attackStats = { ...attackerStats };
    const defenseStats = { ...defenderStats };
    let descriptorElement = '';
    if (typeof descriptor.element === 'string' && descriptor.element) {
      descriptorElement = descriptor.element;
    } else if (descriptor.source === skill.id) {
      descriptorElement = skillElement;
    }
    if (descriptor.kind === 'physical') {
      attackStats.physicalAttack = Math.max(0, attackStats.physicalAttack * descriptor.ratio);
    } else {
      attackStats.magicAttack = Math.max(0, attackStats.magicAttack * descriptor.ratio);
    }
    const attackRng = shouldSuppressDodge() ? createForcedHitRng(random) : random;
    const result = executeAttack(attackStats, attackerSpecial, defenseStats, defenderSpecial, attackRng);
    if (result.dodged) {
      dodged = true;
      events.push({ type: 'dodge', targetId: opponent.id, targetSide: opponent.side, source: descriptor.source || 'followUp' });
      summary.push(`${opponent.name}闪避了后续打击`);
      return;
    }
    let damage = Math.max(1, result.damage);
    crit = crit || result.crit;
    if (attackerExtra.extraDamageRatio) {
      damage += calculateBonusDamage(result.damage, attackerExtra.extraDamageRatio);
    }
    damage = Math.max(1, damage);
    const mitigated = applyIncomingDamageModifiers(opponent, damage, { element: descriptorElement, summary });
    damage = Math.max(1, mitigated.damage);
    opponent.hp = Math.max(0, opponent.hp - damage);
    totalDamage += damage;
    events.push({
      type: 'damage',
      targetId: opponent.id,
      targetSide: opponent.side,
      value: Math.round(damage),
      crit: !!result.crit,
      source: descriptor.source || 'followUp'
    });
    summary.push(`${actor.name}追加打击造成 ${Math.round(damage)} 点伤害${result.crit ? '（暴击）' : ''}`);
    handleDamageWakeEffects(opponent, damage, { summary, reason: descriptor.source || 'followUp' });
    if (result.heal > 0) {
      const healValue = Math.max(0, result.heal);
      const before = actor.hp;
      actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + healValue);
      const applied = Math.max(0, actor.hp - before);
      if (applied > 0) {
        totalHeal += applied;
        events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied), source: 'followUp' });
        summary.push(`${actor.name}追加打击吸取 ${Math.round(applied)} 点生命`);
      }
    }
    if (defenderExtra.reflectRatio) {
      const reflected = calculateBonusDamage(damage, defenderExtra.reflectRatio);
      if (reflected > 0) {
        actor.hp = Math.max(0, actor.hp - reflected);
        events.push({ type: 'damage', targetId: actor.id, targetSide: actor.side, value: Math.round(reflected), source: 'reflect' });
        summary.push(`${actor.name}因反伤承受 ${Math.round(reflected)} 点伤害`);
        const followUpReflectGain = calculateDamageTakenResourceGain(actor, reflected);
        gainResource(actor, followUpReflectGain, {
          events,
          source: 'reflect',
          stats: attackerStats
        });
      }
    }
    const followUpDamageGain = calculateDamageTakenResourceGain(opponent, damage);
    gainResource(opponent, followUpDamageGain, {
      events,
      source: descriptor.source || 'followUp',
      stats: opponentAttackStats
    });
    if (result.crit) {
      const followUpCritGain = resolveActorResourceGain(actor, 'critGain');
      gainResource(actor, followUpCritGain, {
        events,
        source: 'critical_hit',
        stats: attackerStats
      });
      const followUpCritTakenGain = resolveActorResourceGain(opponent, 'critTakenGain');
      gainResource(opponent, followUpCritTakenGain, {
        events,
        source: 'critical_taken',
        stats: opponentAttackStats
      });
    }
  });

  if (skill.healSelf) {
    const ratio = (skill.healSelf.ratioOfMaxHp || 0) + (skill.healSelf.perLevel || 0) * Math.max(0, level - 1);
    const amount = Math.max(0, actor.maxHp * ratio);
    const before = actor.hp;
    actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + amount);
    const applied = Math.max(0, actor.hp - before);
    if (applied > 0) {
      totalHeal += applied;
      events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied) });
      summary.push(`${actor.name}回复 ${Math.round(applied)} 点生命`);
    }
  }

  if ((skill.id === BASIC_ATTACK.id || skill.type === 'basic') && totalDamage > 0) {
    const basicGain = resolveActorResourceGain(actor, 'basicAttackGain');
    gainResource(actor, basicGain, {
      events,
      source: skill.id || BASIC_ATTACK.id,
      stats: attackerStats
    });
  }

  return {
    events,
    summary,
    totalDamage,
    totalHeal,
    dodged,
    crit
  };
}

function finalizeStatuses(actor) {
  if (!actor || !Array.isArray(actor.statuses)) {
    return;
  }
  actor.statuses.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    status.remaining -= 1;
    if (status.remaining <= 0) {
      if (status.type === 'shield') {
        applyShieldExpiration(actor, status);
      }
    }
  });
  actor.statuses = actor.statuses.filter((status) => status && status.remaining > 0);
  const controlState = updateActorControlSnapshot(actor);
  actor.silenced = controlState ? controlState.effects.includes('silence') : false;
}

function takeTurn({ actor, opponent, rng }) {
  const random = pickRng(actor, rng);
  const preEvents = [];
  const summary = [];
  decrementCooldowns(actor);
  applyTurnStartResourceGain(actor, { events: preEvents });
  const start = processStartStatuses({ actor, opponent, rng: random, events: preEvents, summary });
  if (actor.hp <= 0) {
    actor.defeated = true;
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: '无法行动', type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }
  if (start.defeated) {
    actor.defeated = true;
    finalizeStatuses(actor);
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: '重创倒地', type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }
  if (start.skip) {
    finalizeStatuses(actor);
    actor.cooldowns = actor.cooldowns || {};
    actor.cooldowns.stunned = Math.max(0, (actor.cooldowns.stunned || 0) - 1);
    const skipLabel = resolveControlSummary(start.controlEffect);
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: skipLabel, type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }

  let skill = chooseSkill(actor);
  let resourceCost = resolveSkillCost(skill);
  let spentCost = 0;
  if (resourceCost > 0) {
    const spendResult = spendResource(actor, resourceCost, {
      events: preEvents,
      source: skill.id,
      includeSummary: false
    });
    if (!spendResult.success) {
      const basic = actor.skillLoadout.find((entry) => entry && entry.id === BASIC_ATTACK.id);
      skill = basic || { ...BASIC_ATTACK, level: 1 };
      resourceCost = resolveSkillCost(skill);
      spentCost = 0;
    } else {
      spentCost = spendResult.spent;
    }
  }
  const result = executeSkill({ actor, opponent, skill, rng: random });
  actor.cooldowns = actor.cooldowns || {};
  actor.cooldowns[skill.id] = skill.cooldown || 0;
  finalizeStatuses(actor);
  const skillResource = resolveSkillResource(skill);
  const { quality, qualityLabel, qualityColor } = resolveSkillQualityMeta(skill);
  return {
    actor,
    opponent,
    skipped: false,
    preEvents,
    events: result.events,
    summary: summary.concat(result.summary),
    skill: {
      id: skill.id,
      name: skill.name,
      type: skill.type || 'active',
      animation: skill.animation || '',
      quality,
      qualityLabel,
      qualityColor,
      skillQuality: quality,
      skillQualityColor: qualityColor,
      rarity: quality,
      rarityLabel: qualityLabel,
      rarityColor: qualityColor,
      resource: {
        type: skillResource.type,
        cost: spentCost || 0
      }
    },
    totalDamage: result.totalDamage,
    totalHeal: result.totalHeal,
    dodged: result.dodged,
    crit: result.crit
  };
}

function decorateSkillLoadout(skillsState, options = {}) {
  return buildSkillLoadout(skillsState, options);
}

function resolveSkillName(skillId) {
  if (!skillId) {
    return '';
  }
  if (skillId === BASIC_ATTACK.id) {
    return BASIC_ATTACK.name;
  }
  const runtime = resolveRuntimeSkill(skillId);
  if (runtime && runtime.name) {
    return runtime.name;
  }
  const definition = SKILL_MAP[skillId];
  return (definition && definition.name) || skillId;
}

module.exports = {
  BASIC_ATTACK,
  buildSkillLoadout,
  decorateSkillLoadout,
  createActorRuntime,
  takeTurn,
  resolveSkillName,
  configureResourceDefaults
};
