'use strict';

const {
  clamp,
  executeAttack,
  resolveCombatStats,
  resolveSpecialStats,
  DEFAULT_COMBAT_STATS,
  DEFAULT_SPECIAL_STATS
} = require('combat-system');
const { SKILL_MAP } = require('skill-model');
const { BASIC_ATTACK, resolveRuntimeSkill } = require('./config');

function toNumber(value, fallback = 0) {
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : fallback;
}

function pickRng(actor, fallback) {
  if (actor && typeof actor.rng === 'function') {
    return actor.rng;
  }
  if (typeof fallback === 'function') {
    return fallback;
  }
  return Math.random;
}

function buildSkillLoadout(skillsState, options = {}) {
  const loadout = [];
  const equipped = Array.isArray(skillsState && skillsState.equipped) ? skillsState.equipped : [];
  const inventory = new Map();
  const entries = Array.isArray(skillsState && skillsState.inventory) ? skillsState.inventory : [];
  entries.forEach((entry) => {
    if (!entry || typeof entry !== 'object') {
      return;
    }
    const skillId = typeof entry.skillId === 'string' ? entry.skillId.trim() : '';
    if (!skillId) {
      return;
    }
    inventory.set(skillId, Math.max(1, Math.floor(Number(entry.level) || 1)));
  });

  equipped.forEach((rawId) => {
    const skillId = typeof rawId === 'string' ? rawId.trim() : '';
    if (!skillId) {
      return;
    }
    const runtime = resolveRuntimeSkill(skillId);
    if (!runtime || runtime === BASIC_ATTACK) {
      return;
    }
    const level = inventory.get(skillId) || 1;
    loadout.push({ ...runtime, level });
  });

  const includeBasic = options && options.includeBasic !== false;
  if (includeBasic) {
    loadout.push({ ...BASIC_ATTACK, level: 1 });
  }
  return loadout;
}

function normalizeCombatantStats(combatant = {}) {
  const stats = resolveCombatStats(combatant, {
    defaults: DEFAULT_COMBAT_STATS,
    convertLegacyPercentages: true
  });
  const special = resolveSpecialStats(combatant.special || combatant.skillSummary || {}, {
    defaults: DEFAULT_SPECIAL_STATS,
    convertLegacyPercentages: true
  });
  return { stats, special };
}

function createActorRuntime({
  id,
  name,
  side,
  combatant,
  skills,
  rng,
  mode
}) {
  const { stats, special } = normalizeCombatantStats(combatant);
  const baseStats = { ...stats };
  const baseSpecial = { ...special };
  const maxHp = Math.max(1, Math.round(stats.maxHp || DEFAULT_COMBAT_STATS.maxHp));
  const shield = Math.max(0, Math.round(special.shield || 0));
  const loadout = Array.isArray(skills) && skills.length ? skills : buildSkillLoadout({}, {});
  return {
    id: typeof id === 'string' && id ? id : side === 'opponent' ? 'opponent' : 'player',
    name: typeof name === 'string' && name ? name : side === 'opponent' ? '敌方' : '我方',
    side: side || 'player',
    stats,
    special,
    baseStats,
    baseSpecial,
    maxHp,
    hp: maxHp + shield,
    skillLoadout: loadout.length ? loadout : [{ ...BASIC_ATTACK, level: 1 }],
    cooldowns: {},
    statuses: [],
    rng: typeof rng === 'function' ? rng : null,
    mode: mode || 'pve',
    history: [],
    defeated: false
  };
}

function decrementCooldowns(actor) {
  if (!actor || !actor.cooldowns) {
    return;
  }
  Object.keys(actor.cooldowns).forEach((skillId) => {
    const value = actor.cooldowns[skillId];
    if (Number.isFinite(value) && value > 0) {
      actor.cooldowns[skillId] = Math.max(0, value - 1);
    }
  });
}

function hasActiveStatus(actor, predicate) {
  if (!actor || !Array.isArray(actor.statuses)) {
    return false;
  }
  return actor.statuses.some((status) => status && status.remaining > 0 && predicate(status));
}

function getBaseStat(actor, key) {
  if (!actor) {
    return 0;
  }
  if (Object.prototype.hasOwnProperty.call(actor.baseStats, key)) {
    return actor.baseStats[key];
  }
  if (Object.prototype.hasOwnProperty.call(actor.baseSpecial, key)) {
    return actor.baseSpecial[key];
  }
  return 0;
}

function applyStatDelta(target, key, delta) {
  if (Object.prototype.hasOwnProperty.call(target.stats, key)) {
    target.stats[key] += delta;
    return;
  }
  if (Object.prototype.hasOwnProperty.call(target.special, key)) {
    target.special[key] += delta;
  }
}

function resolveEffectiveStats(actor, { mode = 'attack' } = {}) {
  const stats = { ...actor.stats };
  const special = { ...actor.special };
  const extra = {
    extraDamageRatio: 0,
    reflectRatio: 0,
    followUp: []
  };
  const modifiers = Array.isArray(actor.statuses) ? actor.statuses : [];
  modifiers.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    const params = status.params || {};
    switch (status.type) {
      case 'stat': {
        applyStatDelta({ stats, special }, status.key, status.delta);
        break;
      }
      case 'extraDamage':
        if (mode === 'attack') {
          extra.extraDamageRatio += params.ratio || 0;
        }
        break;
      case 'reflect':
        if (mode === 'defense') {
          extra.reflectRatio += params.ratio || 0;
        }
        break;
      case 'shield':
        if (mode === 'defense' && params.reflectRatio) {
          extra.reflectRatio += params.reflectRatio;
        }
        if (mode === 'attack' && params.burstRatio) {
          extra.followUp.push({ type: 'burst', ratio: params.burstRatio, kind: params.kind || 'magic' });
        }
        break;
      case 'domain':
        if (mode === 'attack') {
          extra.extraDamageRatio += params.ratio || 0;
        }
        break;
      default:
        break;
    }
  });
  return { stats, special, extra };
}

function createStatus(base) {
  const status = {
    id: base && base.id ? base.id : `status_${Date.now()}_${Math.random().toString(16).slice(2)}`,
    source: base && base.source,
    type: base && base.type,
    remaining: Math.max(0, Math.floor(base && base.remaining ? base.remaining : 0)),
    params: base && base.params ? { ...base.params } : {},
    key: base && base.key ? base.key : null,
    delta: base && typeof base.delta === 'number' ? base.delta : 0
  };
  return status;
}

function addStatus(target, descriptor, options = {}) {
  if (!target || !descriptor) {
    return null;
  }
  const duration = Math.max(0, Math.floor(descriptor.duration || 0));
  if (duration <= 0 && descriptor.type !== 'shield') {
    return null;
  }
  const status = createStatus({
    source: options.source,
    type: descriptor.type,
    remaining: duration,
    params: descriptor.params || {}
  });

  if (descriptor.type === 'stat') {
    const key = descriptor.stat;
    if (!key) {
      return null;
    }
    const baseValue = getBaseStat(target, key);
    const mode = descriptor.mode || 'flat';
    const value = toNumber(descriptor.value, 0);
    const delta = mode === 'percent' ? baseValue * value : value;
    status.key = key;
    status.delta = delta;
    status.params.mode = mode;
  } else if (descriptor.type === 'shield') {
    const ratio = descriptor.ratioOfMaxHp || 0;
    const bonus = Math.max(0, target.maxHp * ratio);
    status.params.shieldValue = bonus;
    status.params.maxShield = bonus;
    status.params.removeOnExpire = true;
    status.remaining = Math.max(1, duration || descriptor.duration || 1);
    target.hp += bonus;
  } else if (descriptor.type === 'reflect') {
    const ratio = descriptor.ratio || (descriptor.params && descriptor.params.ratio) || 0;
    status.params.ratio = ratio;
    status.remaining = Math.max(1, duration || 2);
  } else if (descriptor.type === 'extraDamage') {
    const ratio = descriptor.ratio || (descriptor.params && descriptor.params.ratio) || 0;
    status.params.ratio = ratio;
    status.type = 'domain';
    status.remaining = Math.max(1, duration || 1);
  } else if (descriptor.type === 'control') {
    status.params.effect = descriptor.effect || 'stun';
    status.remaining = Math.max(1, duration || 1);
  } else if (descriptor.type === 'dot') {
    status.params.attribute = descriptor.attribute || 'magicAttack';
    status.params.ratio = descriptor.ratio || 0;
    status.params.kind = descriptor.dotType || descriptor.typeLabel || 'dot';
    status.remaining = Math.max(1, duration || 1);
  }

  target.statuses = Array.isArray(target.statuses) ? target.statuses : [];
  target.statuses.push(status);
  return status;
}

function removeStatus(target, status) {
  if (!target || !Array.isArray(target.statuses)) {
    return;
  }
  const index = target.statuses.indexOf(status);
  if (index >= 0) {
    target.statuses.splice(index, 1);
  }
}

function applyShieldExpiration(actor, status) {
  if (!actor || !status || status.type !== 'shield') {
    return;
  }
  const params = status.params || {};
  const shieldValue = Math.max(0, params.shieldValue || 0);
  if (shieldValue <= 0) {
    return;
  }
  const excess = Math.max(0, actor.hp - actor.maxHp);
  if (excess > 0) {
    const reduction = Math.min(excess, shieldValue);
    actor.hp = Math.max(actor.maxHp, actor.hp - reduction);
  }
}

function processStartStatuses({ actor, opponent, rng, events = [], summary = [] }) {
  let skip = false;
  let defeated = false;
  const statuses = Array.isArray(actor.statuses) ? actor.statuses.slice() : [];
  statuses.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    const params = status.params || {};
    switch (status.type) {
      case 'control': {
        if (params.effect === 'stun') {
          skip = true;
        } else if (params.effect === 'silence') {
          actor.silenced = true;
        }
        break;
      }
      case 'dot': {
        const attribute = params.attribute || 'magicAttack';
        const ratio = params.ratio || 0;
        if (ratio <= 0) {
          break;
        }
        const attackerStats = resolveEffectiveStats(opponent || actor, { mode: 'attack' }).stats;
        const sourceStat = attribute && attribute in attackerStats ? attackerStats[attribute] : attackerStats.magicAttack;
        let damage = Math.max(0, sourceStat * ratio);
        const defenderStats = resolveEffectiveStats(actor, { mode: 'defense' });
        const finalBonus = defenderStats.stats.finalDamageBonus || 0;
        const finalReduction = defenderStats.stats.finalDamageReduction || 0;
        const finalMultiplier = Math.max(0.1, 1 + finalBonus - finalReduction);
        damage *= finalMultiplier;
        damage = Math.max(1, damage);
        actor.hp = Math.max(0, actor.hp - damage);
        events.push({
          type: 'damage',
          targetId: actor.id,
          targetSide: actor.side,
          value: Math.round(damage),
          source: status.source || 'dot'
        });
        summary.push(`${actor.name}受到持续伤害 ${Math.round(damage)} 点`);
        if (actor.hp <= 0) {
          defeated = true;
        }
        break;
      }
      default:
        break;
    }
  });
  return { skip, defeated };
}

function hasStatusEffect(actor, effect) {
  return hasActiveStatus(actor, (status) => status && status.type === 'control' && status.params && status.params.effect === effect);
}

function chooseSkill(actor) {
  if (!actor || !Array.isArray(actor.skillLoadout) || !actor.skillLoadout.length) {
    return { ...BASIC_ATTACK, level: 1 };
  }
  const silenced = hasStatusEffect(actor, 'silence');
  for (let i = 0; i < actor.skillLoadout.length; i += 1) {
    const skill = actor.skillLoadout[i];
    if (!skill || skill.id === BASIC_ATTACK.id) {
      continue;
    }
    const cooldown = actor.cooldowns[skill.id] || 0;
    if (cooldown > 0) {
      continue;
    }
    if (silenced && skill.type && skill.type !== 'passive' && skill.type !== 'basic') {
      continue;
    }
    return skill;
  }
  const basic = actor.skillLoadout.find((skill) => skill && skill.id === BASIC_ATTACK.id);
  return basic || { ...BASIC_ATTACK, level: 1 };
}

function applyControl(opponent, controlDescriptor, skillId, level, rng) {
  if (!opponent || !controlDescriptor) {
    return false;
  }
  const chance = (controlDescriptor.chance || 0) + (controlDescriptor.perLevel || 0) * Math.max(0, level - 1);
  const random = rng ? rng() : Math.random();
  if (random > clamp(chance, 0, 1)) {
    return false;
  }
  const effect = controlDescriptor.type === 'silence' ? 'silence' : 'stun';
  addStatus(opponent, {
    type: 'control',
    duration: controlDescriptor.duration || 1,
    params: { effect }
  }, { source: skillId });
  return true;
}

function applyDot(opponent, descriptor, skillId, level) {
  const ratio = (descriptor.ratio || 0) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
  if (ratio <= 0) {
    return;
  }
  addStatus(opponent, {
    type: 'dot',
    duration: descriptor.duration || 1,
    attribute: descriptor.attribute || 'magicAttack',
    ratio,
    dotType: descriptor.type || 'dot'
  }, { source: skillId });
}

function applyStatDebuffs(target, list, skillId, level) {
  if (!target || !Array.isArray(list)) {
    return;
  }
  list.forEach((entry) => {
    if (!entry) {
      return;
    }
    const value = (entry.value || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
    if (!value) {
      return;
    }
    addStatus(target, {
      type: 'stat',
      stat: entry.stat,
      mode: entry.mode || 'flat',
      value,
      duration: entry.duration || 1
    }, { source: skillId });
  });
}

function applyBuffs(target, list, skillId, level) {
  if (!target || !Array.isArray(list)) {
    return;
  }
  list.forEach((entry) => {
    if (!entry) {
      return;
    }
    switch (entry.type) {
      case 'stat': {
        const value = (entry.value || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, {
          type: 'stat',
          stat: entry.stat,
          mode: entry.mode || 'flat',
          value,
          duration: entry.duration || 1
        }, { source: skillId });
        break;
      }
      case 'shield': {
        const ratio = (entry.ratioOfMaxHp || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        const status = addStatus(target, {
          type: 'shield',
          ratioOfMaxHp: ratio,
          duration: entry.duration || 1
        }, { source: skillId });
        if (status && entry.reflectRatio) {
          status.params.reflectRatio = (entry.reflectRatio || 0) + (entry.reflectPerLevel || 0) * Math.max(0, level - 1);
        }
        if (status && entry.burstRatio) {
          status.params.burstRatio = entry.burstRatio;
          status.params.kind = entry.kind || 'magic';
        }
        break;
      }
      case 'reflect': {
        const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, { type: 'reflect', duration: entry.duration || 2, params: { ratio } }, { source: skillId });
        break;
      }
      case 'extraDamage': {
        const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
        addStatus(target, { type: 'extraDamage', duration: entry.duration || 2, params: { ratio } }, { source: skillId });
        break;
      }
      default:
        break;
    }
  });
}

function calculateBonusDamage(baseDamage, ratio) {
  if (!baseDamage || !ratio) {
    return 0;
  }
  return Math.max(0, baseDamage * ratio);
}

function executeSkill({ actor, opponent, skill, rng }) {
  const events = [];
  const summary = [];
  const level = Math.max(1, Math.floor(skill.level || 1));
  const random = pickRng(actor, rng);
  const { stats: attackerStats, special: attackerSpecial, extra: attackerExtra } = resolveEffectiveStats(actor, {
    mode: 'attack'
  });
  const { stats: defenderStats, special: defenderSpecial, extra: defenderExtra } = resolveEffectiveStats(opponent, {
    mode: 'defense'
  });

  let totalDamage = 0;
  let totalHeal = 0;
  let dodged = false;
  let crit = false;

  const damageDescriptors = Array.isArray(skill.damage) && skill.damage.length ? skill.damage : [{ kind: 'auto', ratio: 1 }];
  const followUpDescriptors = [];
  if (skill.followUp) {
    const followDescriptor = { ...skill.followUp };
    if (!followDescriptor.type) {
      followDescriptor.type = 'burst';
    }
    followDescriptor.ratio =
      (followDescriptor.ratio || 0) + (followDescriptor.perLevel || 0) * Math.max(0, level - 1);
    followDescriptor.kind = followDescriptor.kind || 'magic';
    followDescriptor.source = skill.id;
    followUpDescriptors.push(followDescriptor);
  }
  if (Array.isArray(attackerExtra.followUp)) {
    attackerExtra.followUp.forEach((descriptor) => {
      if (!descriptor) {
        return;
      }
      const followDescriptor = {
        ...descriptor,
        ratio: descriptor.ratio || 0,
        kind: descriptor.kind || 'magic',
        type: descriptor.type || 'burst',
        source: descriptor.source || 'status'
      };
      followUpDescriptors.push(followDescriptor);
    });
  }

  damageDescriptors.forEach((descriptor) => {
    const hits = Math.max(1, Math.floor(descriptor.hits || 1));
    for (let i = 0; i < hits; i += 1) {
      const attackStats = { ...attackerStats };
      const defenseStats = { ...defenderStats };
      if (descriptor.kind === 'physical') {
        const ratio = (descriptor.ratio || 1) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
        attackStats.physicalAttack = Math.max(0, attackStats.physicalAttack * ratio);
      } else if (descriptor.kind === 'magic') {
        const ratio = (descriptor.ratio || 1) + (descriptor.perLevel || 0) * Math.max(0, level - 1);
        attackStats.magicAttack = Math.max(0, attackStats.magicAttack * ratio);
      }
      const result = executeAttack(attackStats, attackerSpecial, defenseStats, defenderSpecial, random);
      dodged = dodged || result.dodged;
      if (result.dodged) {
        events.push({ type: 'dodge', targetId: opponent.id, targetSide: opponent.side });
        summary.push(`${opponent.name}闪避了攻击`);
        continue;
      }
      crit = crit || result.crit;
      let damage = Math.max(1, result.damage);
      if (descriptor.extraOnCritRatio && result.crit) {
        const extraRatio = descriptor.extraOnCritRatio + (descriptor.extraOnCritPerLevel || 0) * Math.max(0, level - 1);
        damage += calculateBonusDamage(result.damage, extraRatio);
      }
      if (attackerExtra.extraDamageRatio) {
        damage += calculateBonusDamage(result.damage, attackerExtra.extraDamageRatio);
      }
      damage = Math.max(1, damage);
      opponent.hp = Math.max(0, opponent.hp - damage);
      totalDamage += damage;
      events.push({
        type: 'damage',
        targetId: opponent.id,
        targetSide: opponent.side,
        value: Math.round(damage),
        crit: !!result.crit
      });
      summary.push(`${actor.name}造成 ${Math.round(damage)} 点伤害${result.crit ? '（暴击）' : ''}`);
      if (result.heal > 0) {
        const healValue = Math.max(0, result.heal);
        const before = actor.hp;
        actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + healValue);
        const applied = Math.max(0, actor.hp - before);
        if (applied > 0) {
          totalHeal += applied;
          events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied) });
          summary.push(`${actor.name}回复 ${Math.round(applied)} 点生命`);
        }
      }
      if (defenderExtra.reflectRatio) {
        const reflected = calculateBonusDamage(damage, defenderExtra.reflectRatio);
        if (reflected > 0) {
          actor.hp = Math.max(0, actor.hp - reflected);
          events.push({ type: 'damage', targetId: actor.id, targetSide: actor.side, value: Math.round(reflected), source: 'reflect' });
          summary.push(`${actor.name}受到反伤 ${Math.round(reflected)} 点`);
        }
      }
    }
  });

  if (Array.isArray(skill.conditionalDamage)) {
    skill.conditionalDamage.forEach((entry) => {
      if (!entry) {
        return;
      }
      const ratio = (entry.ratio || 0) + (entry.perLevel || 0) * Math.max(0, level - 1);
      if (!ratio) {
        return;
      }
      const conditionMet = entry.condition === 'burning' ? hasActiveStatus(opponent, (status) => status.type === 'dot' && status.params && status.params.kind === 'burning') : false;
      if (!conditionMet) {
        return;
      }
      const baseDamage = entry.kind === 'physical' ? attackerStats.physicalAttack : attackerStats.magicAttack;
      const bonusDamage = Math.max(1, baseDamage * ratio);
      opponent.hp = Math.max(0, opponent.hp - bonusDamage);
      totalDamage += bonusDamage;
      events.push({ type: 'damage', targetId: opponent.id, targetSide: opponent.side, value: Math.round(bonusDamage) });
      summary.push(`${actor.name}引燃弱点，追加 ${Math.round(bonusDamage)} 点伤害`);
    });
  }

  if (Array.isArray(skill.dots)) {
    skill.dots.forEach((dot) => applyDot(opponent, dot, skill.id, level));
  }

  if (Array.isArray(skill.debuffs)) {
    applyStatDebuffs(opponent, skill.debuffs, skill.id, level);
  }

  if (skill.control) {
    const applied = applyControl(opponent, skill.control, skill.id, level, random);
    if (applied) {
      summary.push(`${opponent.name}被控制`);
    }
  }

  if (Array.isArray(skill.buffs)) {
    applyBuffs(actor, skill.buffs, skill.id, level);
  }

  const followUpResults = followUpDescriptors.filter((descriptor) => descriptor.ratio > 0);
  followUpResults.forEach((descriptor) => {
    if (descriptor.source === skill.id && totalDamage <= 0) {
      return;
    }
    const attackStats = { ...attackerStats };
    const defenseStats = { ...defenderStats };
    if (descriptor.kind === 'physical') {
      attackStats.physicalAttack = Math.max(0, attackStats.physicalAttack * descriptor.ratio);
    } else {
      attackStats.magicAttack = Math.max(0, attackStats.magicAttack * descriptor.ratio);
    }
    const result = executeAttack(attackStats, attackerSpecial, defenseStats, defenderSpecial, random);
    if (result.dodged) {
      dodged = true;
      events.push({ type: 'dodge', targetId: opponent.id, targetSide: opponent.side, source: descriptor.source || 'followUp' });
      summary.push(`${opponent.name}闪避了后续打击`);
      return;
    }
    let damage = Math.max(1, result.damage);
    crit = crit || result.crit;
    if (attackerExtra.extraDamageRatio) {
      damage += calculateBonusDamage(result.damage, attackerExtra.extraDamageRatio);
    }
    damage = Math.max(1, damage);
    opponent.hp = Math.max(0, opponent.hp - damage);
    totalDamage += damage;
    events.push({
      type: 'damage',
      targetId: opponent.id,
      targetSide: opponent.side,
      value: Math.round(damage),
      crit: !!result.crit,
      source: descriptor.source || 'followUp'
    });
    summary.push(`${actor.name}追加打击造成 ${Math.round(damage)} 点伤害${result.crit ? '（暴击）' : ''}`);
    if (result.heal > 0) {
      const healValue = Math.max(0, result.heal);
      const before = actor.hp;
      actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + healValue);
      const applied = Math.max(0, actor.hp - before);
      if (applied > 0) {
        totalHeal += applied;
        events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied), source: 'followUp' });
        summary.push(`${actor.name}追加打击吸取 ${Math.round(applied)} 点生命`);
      }
    }
    if (defenderExtra.reflectRatio) {
      const reflected = calculateBonusDamage(damage, defenderExtra.reflectRatio);
      if (reflected > 0) {
        actor.hp = Math.max(0, actor.hp - reflected);
        events.push({ type: 'damage', targetId: actor.id, targetSide: actor.side, value: Math.round(reflected), source: 'reflect' });
        summary.push(`${actor.name}因反伤承受 ${Math.round(reflected)} 点伤害`);
      }
    }
  });

  if (skill.healSelf) {
    const ratio = (skill.healSelf.ratioOfMaxHp || 0) + (skill.healSelf.perLevel || 0) * Math.max(0, level - 1);
    const amount = Math.max(0, actor.maxHp * ratio);
    const before = actor.hp;
    actor.hp = Math.min(actor.maxHp + Math.max(0, actor.hp - actor.maxHp), actor.hp + amount);
    const applied = Math.max(0, actor.hp - before);
    if (applied > 0) {
      totalHeal += applied;
      events.push({ type: 'heal', targetId: actor.id, targetSide: actor.side, value: Math.round(applied) });
      summary.push(`${actor.name}回复 ${Math.round(applied)} 点生命`);
    }
  }

  return {
    events,
    summary,
    totalDamage,
    totalHeal,
    dodged,
    crit
  };
}

function finalizeStatuses(actor) {
  if (!actor || !Array.isArray(actor.statuses)) {
    return;
  }
  actor.statuses.forEach((status) => {
    if (!status || status.remaining <= 0) {
      return;
    }
    status.remaining -= 1;
    if (status.remaining <= 0) {
      if (status.type === 'shield') {
        applyShieldExpiration(actor, status);
      }
    }
  });
  actor.statuses = actor.statuses.filter((status) => status && status.remaining > 0);
  actor.silenced = false;
}

function takeTurn({ actor, opponent, rng }) {
  const random = pickRng(actor, rng);
  const preEvents = [];
  const summary = [];
  decrementCooldowns(actor);
  const start = processStartStatuses({ actor, opponent, rng: random, events: preEvents, summary });
  if (actor.hp <= 0) {
    actor.defeated = true;
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: '无法行动', type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }
  if (start.defeated) {
    actor.defeated = true;
    finalizeStatuses(actor);
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: '重创倒地', type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }
  if (start.skip) {
    finalizeStatuses(actor);
    actor.cooldowns = actor.cooldowns || {};
    actor.cooldowns.stunned = Math.max(0, (actor.cooldowns.stunned || 0) - 1);
    return {
      actor,
      opponent,
      skipped: true,
      preEvents,
      events: [],
      summary,
      skill: { id: 'skip', name: '被控制', type: 'control' },
      totalDamage: 0,
      totalHeal: 0,
      dodged: false,
      crit: false
    };
  }

  const skill = chooseSkill(actor);
  const result = executeSkill({ actor, opponent, skill, rng: random });
  actor.cooldowns = actor.cooldowns || {};
  actor.cooldowns[skill.id] = skill.cooldown || 0;
  finalizeStatuses(actor);
  return {
    actor,
    opponent,
    skipped: false,
    preEvents,
    events: result.events,
    summary: summary.concat(result.summary),
    skill: { id: skill.id, name: skill.name, type: skill.type || 'active', animation: skill.animation || '' },
    totalDamage: result.totalDamage,
    totalHeal: result.totalHeal,
    dodged: result.dodged,
    crit: result.crit
  };
}

function decorateSkillLoadout(skillsState, options = {}) {
  return buildSkillLoadout(skillsState, options);
}

function resolveSkillName(skillId) {
  if (!skillId) {
    return '';
  }
  if (skillId === BASIC_ATTACK.id) {
    return BASIC_ATTACK.name;
  }
  const runtime = resolveRuntimeSkill(skillId);
  if (runtime && runtime.name) {
    return runtime.name;
  }
  const definition = SKILL_MAP[skillId];
  return (definition && definition.name) || skillId;
}

module.exports = {
  BASIC_ATTACK,
  buildSkillLoadout,
  decorateSkillLoadout,
  createActorRuntime,
  takeTurn,
  resolveSkillName
};
