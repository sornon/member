const subLevelLabels = ['一层', '二层', '三层', '四层', '五层', '六层', '七层', '八层', '九层', '圆满'];

const EXPERIENCE_PER_YUAN = 100;

const CLOUD_ASSET_BASE_PATH =
  'cloud://cloud1-8gyoxq651fcc92c2.636c-cloud1-8gyoxq651fcc92c2-1380371219/assets';

function buildCloudAssetUrl(...segments) {
  return [CLOUD_ASSET_BASE_PATH, ...segments]
    .map((segment) => `${segment}`.replace(/(^\/+|\/+$)/g, ''))
    .filter(Boolean)
    .join('/');
}

const AVATAR_IMAGE_BASE_PATH = buildCloudAssetUrl('avatar');
const AVATAR_FRAME_IMAGE_BASE_PATH = buildCloudAssetUrl('border');
const BACKGROUND_IMAGE_BASE_PATH = buildCloudAssetUrl('background');
const BACKGROUND_VIDEO_BASE_PATH = buildCloudAssetUrl('background');
const CHARACTER_IMAGE_BASE_PATH = buildCloudAssetUrl('character');
const TITLE_IMAGE_BASE_PATH = buildCloudAssetUrl('title');

const COLLECTIONS = Object.freeze({
  MEMBERS: 'members',
  LEVELS: 'membershipLevels',
  MEMBERSHIP_LEVELS: 'membershipLevels',
  RIGHTS_MASTER: 'membershipRights',
  MEMBERSHIP_RIGHTS: 'membershipRights',
  MEMBER_RIGHTS: 'memberRights',
  MEMBER_EXTRAS: 'memberExtras',
  MEMBER_TIMELINE: 'memberTimeline',
  ADMIN_PROXY_SESSIONS: 'adminProxySessions',
  ADMIN_PROXY_LOGS: 'adminProxyLogs',
  MEMBER_PVE_HISTORY: 'memberPveHistory',
  MEMBER_BATTLE_ARCHIVE: 'memberBattleArchive',
  ACTIVITIES: 'activities',
  MENU_ORDERS: 'menuOrders',
  MENU_SECTIONS: 'menuSections',
  MENU_CATEGORIES: 'menuCategories',
  MENU_ITEMS: 'menuItems',
  CHARGE_ORDERS: 'chargeOrders',
  RESERVATIONS: 'reservations',
  ROOMS: 'rooms',
  TASKS: 'tasks',
  TASK_RECORDS: 'taskRecords',
  COUPONS: 'coupons',
  COUPON_RECORDS: 'couponRecords',
  STONE_TRANSACTIONS: 'stoneTransactions',
  WALLET_TRANSACTIONS: 'walletTransactions',
  TRANSACTIONS: 'walletTransactions',
  AVATAR_CATEGORIES: 'avatarCategories',
  AVATARS: 'avatars',
  PVP_PROFILES: 'pvpProfiles',
  PVP_SEASONS: 'pvpSeasons',
  PVP_MATCHES: 'pvpMatches',
  PVP_LEADERBOARD: 'pvpLeaderboard',
  PVP_INVITES: 'pvpInvites',
  SYSTEM_SETTINGS: 'systemSettings',
  ERROR_LOGS: 'errorlogs',
  TRADE_LISTINGS: 'tradeListings',
  TRADE_ORDERS: 'tradeOrders',
  TRADE_BIDS: 'tradeBids',
  TRADE_METRICS: 'tradeMetrics',
  TRADE_SETTINGS: 'tradeSettings'
});

const TRADING_CONFIG = Object.freeze({
  feeRate: 0.05,
  minDurationHours: 24,
  maxDurationHours: 168,
  maxListingsPerMember: 10,
  maxActiveBidsPerMember: 50,
  minBidIncrementRate: 0.05
});

const EXCLUDED_TRANSACTION_STATUSES = Object.freeze([
  'pending',
  'processing',
  'failed',
  'cancelled',
  'refunded',
  'closed'
]);

const DEFAULT_ADMIN_ROLES = Object.freeze(['admin', 'developer']);

const RAW_BACKGROUNDS = [
  { id: 'realm_refining', realmOrder: 1, realmName: '炼气期', name: '炼气之地', unlockType: 'realm' },
  {
    id: 'trial_spirit_test',
    realmOrder: 1,
    realmName: '炼气期',
    name: '灵根测试',
    unlockType: 'manual',
    mediaKey: 'bg-free-1'
  },
  { id: 'realm_foundation', realmOrder: 2, realmName: '筑基期', name: '筑基之地', unlockType: 'realm' },
  { id: 'realm_core', realmOrder: 3, realmName: '结丹期', name: '结丹之地', unlockType: 'realm' },
  { id: 'realm_nascent', realmOrder: 4, realmName: '元婴期', name: '元婴之地', unlockType: 'realm' },
  { id: 'realm_divine', realmOrder: 5, realmName: '化神期', name: '化神之地', unlockType: 'realm' },
  { id: 'realm_void', realmOrder: 6, realmName: '炼虚期', name: '炼虚之地', unlockType: 'realm' },
  { id: 'realm_unity', realmOrder: 7, realmName: '合体期', name: '合体之地', unlockType: 'realm' },
  { id: 'realm_great_vehicle', realmOrder: 8, realmName: '大乘期', name: '大乘之地', unlockType: 'realm' },
  { id: 'realm_tribulation', realmOrder: 9, realmName: '真仙期', name: '真仙之地', unlockType: 'realm' },
  { id: 'realm_ascension', realmOrder: 10, realmName: '金仙期', name: '金仙之地', unlockType: 'realm' }
];

function resolveMediaKey(realmOrder) {
  const order = Number(realmOrder);
  if (!Number.isFinite(order) || order <= 0) {
    return '1';
  }
  const normalizedOrder = Math.max(1, Math.floor(order));
  return `${normalizedOrder}`;
}

function buildBackgroundDefinition(item = {}) {
  const mediaKey = item.mediaKey || resolveMediaKey(item.realmOrder);
  const image = item.image || `${BACKGROUND_IMAGE_BASE_PATH}/${mediaKey}.jpg`;
  const video = item.video || `${BACKGROUND_VIDEO_BASE_PATH}/${mediaKey}.mp4`;
  return {
    ...item,
    mediaKey,
    image,
    video
  };
}

const BASE_BACKGROUNDS = RAW_BACKGROUNDS.map((item) => buildBackgroundDefinition(item));
const BASE_BACKGROUND_MAP = new Map(BASE_BACKGROUNDS.map((background) => [background.id, background]));
const CUSTOM_BACKGROUND_MAP = new Map();

function cloneBackground(background) {
  return background ? { ...background } : null;
}

function normalizeBackgroundMediaKey(value) {
  if (typeof value !== 'string') {
    return '';
  }
  let sanitized = value.trim().toLowerCase();
  if (!sanitized) {
    return '';
  }
  sanitized = sanitized.replace(/\.(jpg|jpeg|png|mp4)$/g, '');
  sanitized = sanitized.replace(/[^a-z0-9_-]+/g, '_');
  sanitized = sanitized.replace(/_{2,}/g, '_');
  sanitized = sanitized.replace(/^_+|_+$/g, '');
  return sanitized;
}

function generateCustomBackgroundId(base, existingIds) {
  const normalizedBase = normalizeBackgroundMediaKey(base) || 'background';
  const existing = existingIds || new Set();
  let candidate = normalizedBase.startsWith('background_') ? normalizedBase : `background_${normalizedBase}`;
  let suffix = 1;
  let finalId = candidate;
  while (existing.has(finalId)) {
    suffix += 1;
    finalId = `${candidate}_${suffix}`;
  }
  existing.add(finalId);
  return finalId;
}

function normalizeBackgroundCatalogEntry(entry, existingIds) {
  if (!entry || typeof entry !== 'object') {
    return null;
  }
  const ids = existingIds || new Set();
  let id = typeof entry.id === 'string' ? entry.id.trim() : '';
  let mediaKey = normalizeBackgroundMediaKey(
    entry.mediaKey || entry.fileName || entry.file || entry.imageFile || entry.id || entry.name
  );
  if (!id) {
    id = generateCustomBackgroundId(mediaKey || entry.name || '', ids);
  }
  if (ids.has(id)) {
    id = generateCustomBackgroundId(id, ids);
  }
  const name = typeof entry.name === 'string' && entry.name.trim() ? entry.name.trim() : id;
  if (!mediaKey) {
    mediaKey = normalizeBackgroundMediaKey(id);
  }
  const normalized = {
    id,
    name,
    mediaKey
  };
  if (typeof entry.realmOrder === 'number' && Number.isFinite(entry.realmOrder)) {
    normalized.realmOrder = Math.max(0, Math.floor(entry.realmOrder));
  }
  if (typeof entry.realmName === 'string' && entry.realmName.trim()) {
    normalized.realmName = entry.realmName.trim();
  }
  if (typeof entry.unlockType === 'string' && entry.unlockType.trim()) {
    normalized.unlockType = entry.unlockType.trim();
  }
  if (typeof entry.videoFile === 'string' && entry.videoFile.trim()) {
    normalized.videoFile = normalizeBackgroundMediaKey(entry.videoFile);
  }
  if (typeof entry.dynamic === 'boolean') {
    normalized.dynamic = entry.dynamic;
  }
  if (entry.createdAt) {
    normalized.createdAt = entry.createdAt;
  }
  if (entry.createdBy) {
    normalized.createdBy = entry.createdBy;
  }
  ids.add(id);
  return normalized;
}

function normalizeBackgroundCatalog(list = []) {
  const baseIds = new Set(BASE_BACKGROUNDS.map((item) => item.id));
  const normalized = [];
  (Array.isArray(list) ? list : []).forEach((entry) => {
    const normalizedEntry = normalizeBackgroundCatalogEntry(entry, baseIds);
    if (normalizedEntry) {
      normalized.push(normalizedEntry);
    }
  });
  return normalized;
}

function areBackgroundCatalogsEqual(a = [], b = []) {
  if (a === b) {
    return true;
  }
  if (!Array.isArray(a) || !Array.isArray(b)) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i += 1) {
    const left = a[i] || {};
    const right = b[i] || {};
    if (left.id !== right.id || left.name !== right.name || left.mediaKey !== right.mediaKey) {
      return false;
    }
  }
  return true;
}

function decorateCustomBackground(entry) {
  const realmOrder = Number.isFinite(entry.realmOrder) ? Math.max(0, Math.floor(entry.realmOrder)) : 0;
  const unlockType = entry.unlockType || 'manual';
  const mediaKey = normalizeBackgroundMediaKey(entry.mediaKey || entry.id);
  const videoKey = normalizeBackgroundMediaKey(entry.videoFile || mediaKey);
  return buildBackgroundDefinition({
    id: entry.id,
    name: entry.name,
    realmOrder,
    realmName: entry.realmName || '',
    unlockType,
    mediaKey,
    image: `${BACKGROUND_IMAGE_BASE_PATH}/${mediaKey}.jpg`,
    video: `${BACKGROUND_VIDEO_BASE_PATH}/${videoKey}.mp4`
  });
}

function registerCustomBackgrounds(list = [], options = {}) {
  const normalized = normalizeBackgroundCatalog(list);
  if (!options || options.reset !== false) {
    CUSTOM_BACKGROUND_MAP.clear();
  }
  normalized.forEach((entry) => {
    CUSTOM_BACKGROUND_MAP.set(entry.id, decorateCustomBackground(entry));
  });
  return normalized;
}

function getBackgroundRegistry() {
  return BASE_BACKGROUNDS.concat(Array.from(CUSTOM_BACKGROUND_MAP.values()));
}

function listBackgrounds() {
  return getBackgroundRegistry().map((background) => cloneBackground(background));
}

function resolveBackgroundById(id) {
  if (typeof id !== 'string') {
    return null;
  }
  const trimmed = id.trim();
  if (CUSTOM_BACKGROUND_MAP.has(trimmed)) {
    return cloneBackground(CUSTOM_BACKGROUND_MAP.get(trimmed));
  }
  if (BASE_BACKGROUND_MAP.has(trimmed)) {
    return cloneBackground(BASE_BACKGROUND_MAP.get(trimmed));
  }
  return null;
}

function resolveBackgroundByRealmName(realmName) {
  if (typeof realmName !== 'string' || !realmName.trim()) {
    return null;
  }
  const trimmed = realmName.trim();
  const registry = getBackgroundRegistry();
  const found = registry.find((background) => background.realmName === trimmed);
  return cloneBackground(found);
}

function normalizeBackgroundId(id) {
  if (typeof id !== 'string') {
    return '';
  }
  const trimmed = id.trim();
  return resolveBackgroundById(trimmed) ? trimmed : '';
}

function getDefaultBackgroundId() {
  return BASE_BACKGROUNDS[0].id;
}

function isBackgroundUnlocked(id, realmOrder, unlockedList = []) {
  const background = resolveBackgroundById(id);
  if (!background) {
    return false;
  }
  if (background.unlockType === 'manual') {
    if (!Array.isArray(unlockedList)) {
      return false;
    }
    return unlockedList.includes(id);
  }
  const numericRealmOrder = Number(realmOrder);
  if (!Number.isFinite(numericRealmOrder)) {
    return background.realmOrder <= 1;
  }
  return Math.max(1, Math.floor(numericRealmOrder)) >= background.realmOrder;
}

function resolveHighestUnlockedBackgroundByRealmOrder(realmOrder) {
  const numericRealmOrder = Number(realmOrder);
  const registry = getBackgroundRegistry();
  if (!Number.isFinite(numericRealmOrder)) {
    return cloneBackground(registry[0]);
  }
  const unlocked = registry.filter(
    (background) => background.unlockType !== 'manual' && numericRealmOrder >= background.realmOrder
  );
  const target = unlocked.length ? unlocked[unlocked.length - 1] : registry[0];
  return cloneBackground(target);
}

const realmConfigs = [
  {
    id: 'realm_qi_refining',
    name: '炼气期',
    shortName: '炼气',
    description: '入门境界，通过吸纳天地灵气淬炼肉身，正式踏上修行大道。',
    increment: 100,
    thresholds: [0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800],
    discount: 1,
    virtualRewards: [
      '称号「炼气新人」，纳戒领取后可在档案展示',
      '背景「灵根测试」，纳戒道具使用后解锁',
      '武器「青竹练气杖」，强化炼气初期输出',
      '技能「烈炽火弹」，开启火系远程打击',
      '装备「初阳布袍」，提升入门阶段防护',
      '装备「翎痕轻履」，带来自如身法与闪避',
      '装备「知风木环」，提供治疗增益',
      '装备「回鸣臂缚」，拓展反击流派',
      '装备「清魂定珠」，稳固控制命中',
      '道具「技能 5 连抽」'
    ],
    milestone: {
      type: '虚拟礼遇',
      summary: '突破奖励：背景「筑基背景」 + 任意 120 元内饮品一杯',
      items: [
        {
          type: 'consumable',
          storageItemId: 'reward_voucher_qi_drink',
          storageCategory: 'consumable',
          usage: {
            type: 'grantRight',
            rightId: 'right_realm_qi_drink',
            amountLimit: 12000,
            categoryType: 'drinks'
          },
          name: '饮品券·任意 120 元内饮品',
          description:
            '使用后获得「任意饮品券（120 元内）」权益，点餐时自动抵扣最贵的一件酒水。',
          slotLabel: '道具',
          quality: 'epic',
          qualityLabel: '权益券',
          qualityColor: '#f2a546'
        }
      ]
    }
  },
  {
    id: 'realm_foundation',
    name: '筑基期',
    shortName: '筑基',
    description: '稳固根基，凝练真元，寿元翻倍，为结丹做足准备。',
    increment: 200,
    thresholds: [2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800],
    discount: 1,
    virtualRewards: [
      '称号「筑基·初成」',
      '凡品头部装备「羊皮束额」，强化+2，缓解筑基入门的物理冲击',
      '凡品鞋履装备「踪风布鞋」，强化+2，巩固灵动身法',
      '凡品腰带装备「绳结束带」，强化+2，提升基础生命底座',
      '凡品护腕装备「砭石护腕」，强化+2，夯实初段输出手感',
      '凡品宝珠装备「琥珀聚灵」，强化+2，稳固术法灵息',
      '凡品项链装备「灵纹索坠」，强化+2，保障控制命中',
      '凡品信物装备「初悟令符」，强化+2，均衡六维成长',
      '凡品傀儡装备「木魈守偶」，强化+2，辅助反击流派',
      '凡品秘宝「破晓灵盘」，强化+2，提前突破暴击线'
    ],
    milestone: {
      type: '包房体验',
      summary: '突破奖励：背景「结丹背景」 + 私人包房券 1 次',
      items: [
        {
          type: 'consumable',
          storageItemId: 'reward_voucher_foundation_room',
          storageCategory: 'consumable',
          usage: { type: 'grantRight', rightId: 'right_realm_foundation_room' },
          name: '包房体验券',
          description: '使用后获得「筑基专属包房券」权益，可预约包房体验 1 次。',
          slotLabel: '道具',
          quality: 'epic',
          qualityLabel: '权益券',
          qualityColor: '#f2a546',
          icon: buildCloudAssetUrl('item', 'item-5.png')
        }
      ]
    }
  },
  {
    id: 'realm_core',
    name: '结丹期',
    shortName: '结丹',
    description: '真元凝结成丹，神识内敛，迈入修行中阶的关键阶段。',
    increment: 400,
    thresholds: [5000, 5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500],
    discount: 1,
    virtualRewards: [
      '称号「结丹·初凝」，获得结丹称号',
      '下品武器「青竹剑」，轻巧易上手',
      '下品头部装备「护灵冠」，缓冲灵识冲击',
      '下品衣袍「灵纹道袍」，抵御初阶灵力',
      '下品鞋履「轻跃靴」，稳固腾挪身法',
      '下品腰带「聚灵束带」，调理气血灵息',
      '下品护腕「练骨护腕」，强化腕力输出',
      '下品法器「启明灵珠」，凝聚术法灵光',
      '下品项链「聚灵戒」，辅助修行者聚气',
      '突破即领：上品武器与技能 5 连抽大礼'
    ],
    milestone: {
      type: '酒品礼遇',
      summary: '突破奖励：上品武器「灵光剑」 + 技能 5 连抽 + 古巴邑 10 年兑换券',
      items: [
        {
          type: 'consumable',
          storageItemId: 'reward_voucher_core_cubaney',
          storageCategory: 'consumable',
          usage: { type: 'grantRight', rightId: 'right_realm_core_cubaney_voucher' },
          name: '古巴邑 10 年兑换券',
          description: '使用后获得「古巴邑 10 年兑换券」权益，到店点单时可兑换 1 瓶。',
          slotLabel: '道具',
          quality: 'epic',
          qualityLabel: '权益券',
          qualityColor: '#f2a546',
          icon: buildCloudAssetUrl('item', 'item-6.png')
        },
        {
          type: 'equipment',
          itemId: 'spirit_blade',
          quality: 'superior',
          qualityLabel: '上品',
          qualityColor: '#6A4DF5',
          description: '突破结丹圆满，赠上品武器「灵光剑」。'
        },
        {
          type: 'consumable',
          storageItemId: 'reward_skill_draw_bundle',
          storageCategory: 'consumable',
          usage: { type: 'skillDraw', drawCount: 5 },
          name: '技能 5 连抽',
          description: '结丹圆满突破礼包，额外赠送一次技能 5 连抽。',
          slotLabel: '道具'
        }
      ]
    }
  },
  {
    id: 'realm_nascent',
    name: '元婴期',
    shortName: '元婴',
    description: '结丹化婴，元神可离体而存，寿元再度提升。',
    increment: 800,
    thresholds: [20000, 21000, 22000, 23000, 24000, 25000, 26000, 27000, 28000, 29000],
    discount: 1,
    virtualRewards: [
      '称号「元婴·初现」，展示元神光影；累计充值 ¥10,000 解锁元婴一层，赠元婴背景与包房使用次数 1 次',
      '下品武器「玄霜灵刃」，强化+2，凝练元婴剑意爆发',
      '下品头部装备「凝魂云冠」，强化+2，稳固元神护持',
      '下品衣袍「太初星袍」，强化+2，护佑元婴法体',
      '下品鞋履「凌霄风履」，强化+2，增益分身驰行',
      '下品腰带「真元束带」，强化+2，扩容灵力周天',
      '下品护腕「御婴龙腕」，强化+2，强势稳固攻势',
      '下品宝珠「悬婴星珠」，强化+2，蕴蓄分身灵光',
      '下品项链「玄婴坠饰」，强化+2，稳定元神呼应',
      '下品信物「婴灵契符」，强化+2，指引元婴共鸣'
    ],
    milestone: {
      type: '精品雪茄',
      summary: '精品雪茄「云雾上品」 + 元婴分身主题',
      rights: [
        {
          rightId: 'right_realm_nascent_cigar',
          quantity: 1,
          description: '元婴精品雪茄 1 支'
        }
      ]
    }
  },
  {
    id: 'realm_divine',
    name: '化神期',
    shortName: '化神',
    description: '感应法则之力，法力不绝，立于人界巅峰门槛。',
    increment: 1600,
    thresholds: [30000, 32000, 34000, 36000, 38000, 40000, 42000, 44000, 46000, 48000],
    discount: 1,
    virtualRewards: [
      '称号「化神·初悟」，获得法则光纹；累计充值 ¥20,000 解锁化神一层，赠化神背景（权益待定，可随时调整）',
      '灵石积分 +1600，可兑换化神法则碎片',
      '头像框「化神神光」解锁',
      '服饰「星辉法衣」上线',
      '法宝「九霄神剑」虚拟特效',
      '聊天气泡「神识寰宇」',
      '消费积分加成提升至 +25%',
      '动作「法则降临」解锁',
      '灵宠晋升为「碧灵狐·化神」',
      '解锁金仙试炼场主题'
    ],
    milestone: {
      type: '珍藏红酒',
      summary: '珍藏红酒「神霖年份」 + 化神法则光翼',
      rights: [
        {
          rightId: 'right_realm_divine_wine',
          quantity: 1,
          description: '化神珍藏红酒 1 瓶'
        }
      ]
    }
  },
  {
    id: 'realm_void',
    name: '炼虚期',
    shortName: '炼虚',
    description: '元婴化虚，可凝练分身，调动更广阔的天地之力。',
    increment: 3200,
    thresholds: [50000, 54000, 58000, 62000, 66000, 70000, 74000, 78000, 82000, 86000],
    discount: 1,
    virtualRewards: [
      '称号「炼虚·洞明」，附带虚化光影；累计充值 ¥50,000 解锁炼虚一层，赠炼虚背景（权益待定，可随时调整）',
      '灵石积分 +3200，用于兑换虚空晶石',
      '头像框「虚空流光」解锁',
      '服饰「雾隐斗篷」上线',
      '法宝「虚影分身」特效挂件',
      '聊天气泡「虚实交汇」',
      '消费积分加成提升至 +30%',
      '动作「虚空步」解锁',
      '灵宠化虚为「碧灵狐·虚灵」',
      '获得尊贵徽记「炼虚印记」'
    ],
    milestone: {
      type: '尊贵标识',
      summary: '尊贵标识礼包 + 虚空行走特效',
      rights: [
        {
          rightId: 'right_realm_void_badge',
          quantity: 1,
          description: '炼虚尊贵标识礼包'
        }
      ]
    }
  },
  {
    id: 'realm_unity',
    name: '合体期',
    shortName: '合体',
    description: '元神与分身合一，显化法相真身，掌控磅礴灵力。',
    increment: 6400,
    thresholds: [100000, 108000, 116000, 124000, 132000, 140000, 148000, 156000, 164000, 172000],
    discount: 1,
    virtualRewards: [
      '称号「合体·初合」，显化合体光环；累计充值 ¥100,000 解锁合体一层，赠合体背景（权益待定，可随时调整）',
      '灵石积分 +6400，兑换合体灵材',
      '头像框「合体法相」解锁',
      '服饰「鸿蒙战铠」上线',
      '法宝「法相金身」虚拟模型',
      '聊天气泡「天地同调」',
      '消费积分加成提升至 +35%',
      '动作「法相显圣」解锁',
      '灵宠晋阶为「碧灵狐·法相」',
      '专属动态光环「合体真身」'
    ],
    milestone: {
      type: '钻石形象与尊享服务',
      summary: '专属虚拟形象套装 + 钻石级尊享服务礼遇',
      rights: [
        {
          rightId: 'right_realm_unity_avatar',
          quantity: 1,
          description: '合体专属形象套装'
        }
      ]
    }
  },
  {
    id: 'realm_great_vehicle',
    name: '大乘期',
    shortName: '大乘',
    description: '修为圆满，掌控更高层次法则之力，距离真仙只差临门一脚。',
    increment: 12800,
    thresholds: [200000, 212000, 224000, 236000, 248000, 260000, 272000, 284000, 296000, 308000],
    discount: 1,
    virtualRewards: [
      '称号「大乘·初悟」，获得道韵光芒；累计充值 ¥200,000 解锁大乘一层，赠大乘背景（权益待定，可随时调整）',
      '灵石积分 +12800，可兑换真仙宝材',
      '头像框「大乘法象」解锁',
      '服饰「苍穹霞衣」上线',
      '法宝「鸿蒙界扇」虚拟特效',
      '聊天气泡「道音回响」',
      '消费积分加成提升至 +40%',
      '动作「道韵加身」解锁',
      '灵宠化为「碧灵狐·玄极」',
      '专属场景「大乘天宫」背景'
    ],
    milestone: {
      type: '贵宾宴请',
      summary: '贵宾宴请券 + 大乘天宫场景永久解锁',
      rights: [
        {
          rightId: 'right_realm_great_vehicle_banquet',
          quantity: 1,
          description: '大乘贵宾宴请券'
        }
      ]
    }
  },
  {
    id: 'realm_tribulation',
    name: '真仙期',
    shortName: '真仙',
    description: '仙骨初成，真灵蜕变，正式踏入仙阶序列。',
    increment: 25600,
    thresholds: [500000, 520000, 540000, 560000, 580000, 600000, 620000, 640000, 660000, 680000],
    discount: 1,
    virtualRewards: [
      '称号「真仙·初证」，点亮仙辉特效；累计充值 ¥500,000 解锁真仙一层，赠真仙背景（权益待定，可随时调整）',
      '灵石积分 +25600，用于兑换真仙法源',
      '头像框「真仙仙辉」解锁',
      '服饰「仙霄云衣」上线',
      '法宝「太清仙灯」虚拟特效',
      '聊天气泡「仙辉缭绕」',
      '消费积分加成提升至 +45%',
      '动作「仙灵御空」解锁',
      '灵宠蜕变为「碧灵狐·仙魄」',
      '专属特效「仙辉护体」'
    ],
    milestone: {
      type: '整店欢聚夜',
      summary: '整店欢聚夜包场券 + 真仙云霄动态场景',
      rights: [
        {
          rightId: 'right_realm_tribulation_fullhouse',
          quantity: 1,
          description: '真仙整店欢聚夜 1 次'
        }
      ]
    }
  },
  {
    id: 'realm_ascension',
    name: '金仙期',
    shortName: '金仙',
    description: '金光环身，位列仙班，掌控无上金仙法则。',
    increment: 51200,
    thresholds: [1000000, 1050000, 1100000, 1150000, 1200000, 1250000, 1300000, 1350000, 1400000, 1450000],
    discount: 1,
    virtualRewards: [
      '称号「金仙·初耀」，获得仙羽光效；累计充值 ¥1,000,000 解锁金仙一层，赠金仙背景（权益待定，可随时调整）',
      '灵石积分 +51200，可兑换金仙仙材',
      '头像框「金仙圣环」解锁',
      '服饰「金仙羽衣」上线',
      '法宝「九霄云辇」虚拟座驾',
      '聊天气泡「仙韵缭绕」',
      '消费积分加成提升至 +50%',
      '动作「金仙之姿」解锁',
      '灵宠圆满为「碧灵狐·仙灵」',
      '终极虚拟形象套装「金仙降世」'
    ],
    milestone: {
      type: '至尊黑卡',
      summary: '至尊黑卡 + 终极金仙虚拟套装',
      rights: [
        {
          rightId: 'right_realm_immortal_blackcard',
          quantity: 1,
          description: '金仙至尊黑卡'
        }
      ]
    }
  }
];

const membershipRights = [
  {
    _id: 'right_realm_qi_drink',
    name: '任意饮品券（120 元内）',
    description: '炼气圆满突破奖励，可兑换店内任意 120 元内饮品 1 杯',
    applyReservation: false,
    validDays: 60
  },
  {
    _id: 'right_realm_foundation_room',
    name: '筑基专属包房券',
    description: '非高峰时段私人包房 3 小时，需提前预约',
    applyReservation: true,
    applyTimeRanges: [
      { start: '12:00', end: '24:00' },
      { start: '00:00', end: '06:00' }
    ],
    validDays: 120,
    meta: {
      roomUsageCount: 1,
      icon: buildCloudAssetUrl('item', 'item-5.png')
    }
  },
  {
    _id: 'right_realm_core_cubaney_voucher',
    name: '古巴邑 10 年兑换券',
    description: '点餐古巴邑 10 年（瓶装）可全额抵扣，价值 ¥980',
    applyReservation: false,
    validDays: 180,
    meta: {
      icon: buildCloudAssetUrl('item', 'item-6.png'),
      categoryType: 'drinks',
      amount: 98000
    }
  },
  {
    _id: 'right_realm_nascent_cigar',
    name: '元婴精品雪茄',
    description: '甄选雪茄 1 支，需到店核验身份后领取',
    applyReservation: false,
    validDays: 365
  },
  {
    _id: 'right_realm_divine_wine',
    name: '化神珍藏红酒',
    description: '珍藏红酒 1 瓶，可预约到店领取',
    applyReservation: false,
    validDays: 365
  },
  {
    _id: 'right_realm_void_badge',
    name: '炼虚尊贵标识包',
    description: '发放实体徽章与虚拟标识，永久生效',
    applyReservation: false
  },
  {
    _id: 'right_realm_unity_avatar',
    name: '合体专属形象套装',
    description: '钻石级专属头像、光环与服饰整套',
    applyReservation: false
  },
  {
    _id: 'right_realm_great_vehicle_banquet',
    name: '大乘贵宾宴请券',
    description: '年度贵宾宴席邀请 1 次，需提前预约',
    applyReservation: false,
    validDays: 365
  },
  {
    _id: 'right_realm_tribulation_fullhouse',
    name: '真仙整店欢聚夜',
    description: '整店包场券 1 次，提前 7 日预约',
    applyReservation: false,
    validDays: 180
  },
  {
    _id: 'right_realm_immortal_blackcard',
    name: '金仙至尊黑卡',
    description: '终身尊享黑卡服务与专属顾问',
    applyReservation: false
  },
  {
    _id: 'right_daytime_room',
    name: '日间包房体验券',
    description: '免费预订一次日间非高峰包房',
    applyReservation: true,
    applyTimeRanges: [{ start: '12:00', end: '18:00' }],
    validDays: 90,
    meta: { roomUsageCount: 1 }
  },
  {
    _id: 'right_full_day_room',
    name: '全天包房体验券',
    description: '免费预订一次全天任意时段包房',
    applyReservation: true,
    applyTimeRanges: [{ start: '00:00', end: '24:00' }],
    validDays: 120,
    meta: { roomUsageCount: 1 }
  },
  {
    _id: 'right_full_house',
    name: '整店包场券',
    description: '尊享整店包场特权一次，需提前预约',
    applyReservation: false,
    validDays: 180
  },
  {
    _id: 'right_premium_gift',
    name: '精品礼盒',
    description: '10 支雪茄 BHK56 礼盒',
    applyReservation: false,
    validDays: 365
  }
];

// avatar-catalog，原云函数member/avatar-catalog.local.js
const RAW_AVATARS = [
  { gender: 'male', rarity: 'c', index: 1 },
  { gender: 'male', rarity: 'c', index: 2 },
  { gender: 'male', rarity: 'c', index: 3 },
  { gender: 'male', rarity: 'b', index: 1 },
  { gender: 'male', rarity: 'b', index: 2 },
  { gender: 'male', rarity: 'b', index: 3 },
  { gender: 'male', rarity: 'b', index: 4 },
  { gender: 'male', rarity: 'b', index: 5 },
  { gender: 'male', rarity: 'b', index: 6 },
  { gender: 'male', rarity: 'a', index: 1 },
  { gender: 'male', rarity: 'a', index: 2 },
  { gender: 'male', rarity: 'a', index: 3 },
  { gender: 'male', rarity: 'a', index: 4 },
  { gender: 'male', rarity: 'a', index: 5 },
  { gender: 'male', rarity: 'a', index: 6 },
  { gender: 'male', rarity: 's', index: 1 },
  { gender: 'male', rarity: 's', index: 2 },
  { gender: 'male', rarity: 's', index: 3 },
  { gender: 'male', rarity: 'ss', index: 1 },
  { gender: 'male', rarity: 'ss', index: 2 },
  { gender: 'male', rarity: 'ss', index: 3 },
  { gender: 'male', rarity: 'sss', index: 1 },
  { gender: 'male', rarity: 'sss', index: 2 },
  { gender: 'male', rarity: 'sss', index: 3 },
  { gender: 'female', rarity: 'c', index: 1 },
  { gender: 'female', rarity: 'c', index: 2 },
  { gender: 'female', rarity: 'c', index: 3 },
  { gender: 'female', rarity: 'b', index: 1 },
  { gender: 'female', rarity: 'b', index: 2 },
  { gender: 'female', rarity: 'b', index: 3 },
  { gender: 'female', rarity: 'b', index: 4 },
  { gender: 'female', rarity: 'b', index: 5 },
  { gender: 'female', rarity: 'b', index: 6 },
  { gender: 'female', rarity: 'a', index: 1 },
  { gender: 'female', rarity: 'a', index: 2 },
  { gender: 'female', rarity: 'a', index: 3 },
  { gender: 'female', rarity: 's', index: 1 },
  { gender: 'female', rarity: 's', index: 2 },
  { gender: 'female', rarity: 's', index: 3 },
  { gender: 'female', rarity: 'ss', index: 1 },
  { gender: 'female', rarity: 'ss', index: 2 },
  { gender: 'female', rarity: 'ss', index: 3 },
  { gender: 'female', rarity: 'sss', index: 1 },
  { gender: 'female', rarity: 'sss', index: 2 },
  { gender: 'female', rarity: 'sss', index: 3 }
];

const AVATAR_RARITIES = ['c', 'b', 'a', 's', 'ss', 'sss'];
const AVATAR_RARITY_ATTRIBUTE_BONUS = {
  s: 5,
  ss: 10,
  sss: 15
};

function buildAvatarId({ gender, rarity, index }) {
  return `${gender}-${rarity}-${index}`;
}

function normalizeAvatarGender(value) {
  const normalized = typeof value === 'string' ? value.trim().toLowerCase() : '';
  if (normalized === 'female') {
    return 'female';
  }
  return 'male';
}

function normalizeAvatarRarity(value) {
  const normalized = typeof value === 'string' ? value.trim().toLowerCase() : '';
  if (AVATAR_RARITIES.includes(normalized)) {
    return normalized;
  }
  return 'c';
}

function normalizeAvatarFileName(value) {
  if (typeof value !== 'string') {
    return '';
  }
  let sanitized = value.trim().toLowerCase();
  if (!sanitized) {
    return '';
  }
  sanitized = sanitized.replace(/\.(png|jpg|jpeg)$/g, '');
  sanitized = sanitized.replace(/[^a-z0-9_-]+/g, '_');
  sanitized = sanitized.replace(/_{2,}/g, '_');
  sanitized = sanitized.replace(/^_+|_+$/g, '');
  return sanitized;
}

function decorateAvatarMeta(item) {
  const id = buildAvatarId(item);
  const gender = normalizeAvatarGender(item.gender);
  const rarity = normalizeAvatarRarity(item.rarity);
  const file = normalizeAvatarFileName(item.file || id) || id;
  const characterFile = normalizeAvatarFileName(item.characterFile || file) || file;
  return {
    ...item,
    id,
    gender,
    rarity,
    file,
    characterFile,
    attributeBonus: AVATAR_RARITY_ATTRIBUTE_BONUS[rarity] || 0
  };
}

const BASE_AVATARS = RAW_AVATARS.map((item) => decorateAvatarMeta(item));
const BASE_AVATAR_MAP = new Map(BASE_AVATARS.map((avatar) => [avatar.id, avatar]));
const CUSTOM_AVATAR_MAP = new Map();

let ALLOWED_AVATAR_IDS = new Set(BASE_AVATARS.map((avatar) => avatar.id));
let AVATAR_FILE_INDEX = new Map(BASE_AVATARS.map((avatar) => [avatar.file, avatar.id]));

function cloneAvatarMeta(meta) {
  if (!meta) {
    return null;
  }
  return { ...meta };
}

function refreshAvatarRegistry() {
  const allMetas = BASE_AVATARS.concat(Array.from(CUSTOM_AVATAR_MAP.values()));
  ALLOWED_AVATAR_IDS = new Set(allMetas.map((meta) => meta.id));
  AVATAR_FILE_INDEX = new Map();
  allMetas.forEach((meta) => {
    if (meta && meta.file) {
      AVATAR_FILE_INDEX.set(meta.file, meta.id);
    }
  });
}

function resolveAvatarMetaById(id) {
  if (!id) {
    return null;
  }
  if (CUSTOM_AVATAR_MAP.has(id)) {
    return cloneAvatarMeta(CUSTOM_AVATAR_MAP.get(id));
  }
  if (BASE_AVATAR_MAP.has(id)) {
    return cloneAvatarMeta(BASE_AVATAR_MAP.get(id));
  }
  return null;
}

function listRegisteredAvatars() {
  return BASE_AVATARS.concat(Array.from(CUSTOM_AVATAR_MAP.values())).map((meta) => cloneAvatarMeta(meta));
}

function listAvatarIds() {
  return listRegisteredAvatars().map((meta) => meta.id);
}

function buildAvatarImageUrlByMeta(meta) {
  if (!meta) {
    return '';
  }
  const file = meta.file || meta.id;
  if (!file) {
    return '';
  }
  return `${AVATAR_IMAGE_BASE_PATH}/${file}.png`;
}

function buildCharacterImageUrlByMeta(meta) {
  if (!meta) {
    return '';
  }
  const file = meta.characterFile || meta.file || meta.id;
  if (!file) {
    return '';
  }
  return `${CHARACTER_IMAGE_BASE_PATH}/${file}.png`;
}

function buildAvatarUrl(id) {
  const meta = resolveAvatarMetaById(id);
  if (!meta) {
    return '';
  }
  return buildAvatarImageUrlByMeta(meta);
}

function buildCharacterUrlById(id) {
  const meta = resolveAvatarMetaById(id);
  if (!meta) {
    return '';
  }
  return buildCharacterImageUrlByMeta(meta);
}

function normalizeAvatarId(value) {
  if (typeof value !== 'string') {
    return '';
  }
  const normalized = value.trim().toLowerCase();
  if (!normalized) {
    return '';
  }
  if (!ALLOWED_AVATAR_IDS.has(normalized)) {
    return '';
  }
  return normalized;
}

function generateCustomAvatarId(base, gender, rarity, existingIds) {
  const slug = normalizeAvatarFileName(base) || 'custom';
  const ids = existingIds || new Set();
  let candidate = `${gender}-${rarity}-${slug}`;
  let suffix = 1;
  while (ids.has(candidate)) {
    suffix += 1;
    candidate = `${gender}-${rarity}-${slug}-${suffix}`;
  }
  ids.add(candidate);
  return candidate;
}

function normalizeAvatarCatalogEntry(entry, existingIds) {
  if (!entry || typeof entry !== 'object') {
    return null;
  }
  const ids = existingIds || new Set();
  const gender = normalizeAvatarGender(entry.gender);
  const rarity = normalizeAvatarRarity(entry.rarity);
  const name = typeof entry.name === 'string' && entry.name.trim() ? entry.name.trim() : '';
  const file = normalizeAvatarFileName(entry.file || entry.fileName || entry.avatarFile || entry.id || entry.name);
  if (!file) {
    return null;
  }
  let id = typeof entry.id === 'string' ? entry.id.trim().toLowerCase() : '';
  if (!id) {
    id = generateCustomAvatarId(file, gender, rarity, ids);
  } else if (ids.has(id)) {
    id = generateCustomAvatarId(id, gender, rarity, ids);
  } else {
    ids.add(id);
  }
  const characterFile = normalizeAvatarFileName(entry.characterFile || file);
  return {
    id,
    name: name || id,
    gender,
    rarity,
    file,
    characterFile,
    attributeBonus: AVATAR_RARITY_ATTRIBUTE_BONUS[rarity] || 0
  };
}

function normalizeAvatarCatalog(list = []) {
  const baseIds = new Set(BASE_AVATARS.map((avatar) => avatar.id));
  const normalized = [];
  (Array.isArray(list) ? list : []).forEach((entry) => {
    const normalizedEntry = normalizeAvatarCatalogEntry(entry, baseIds);
    if (normalizedEntry) {
      normalized.push(normalizedEntry);
    }
  });
  return normalized;
}

function registerCustomAvatars(list = [], options = {}) {
  const normalized = normalizeAvatarCatalog(list);
  if (!options || options.reset !== false) {
    CUSTOM_AVATAR_MAP.clear();
  }
  normalized.forEach((entry) => {
    CUSTOM_AVATAR_MAP.set(entry.id, entry);
  });
  refreshAvatarRegistry();
  return normalized;
}

function normalizeAvatarUnlocks(unlocks = []) {
  if (!Array.isArray(unlocks)) {
    return [];
  }
  const seen = new Set();
  const result = [];
  unlocks.forEach((value) => {
    const id = normalizeAvatarId(value);
    if (!id || seen.has(id)) {
      return;
    }
    seen.add(id);
    result.push(id);
  });
  return result;
}

function calculateAvatarAttributeBonus(unlocks = [], catalog = []) {
  const normalizedUnlocks = normalizeAvatarUnlocks(unlocks);
  if (!normalizedUnlocks.length) {
    return 0;
  }
  const customMap = new Map(normalizeAvatarCatalog(catalog).map((entry) => [entry.id, entry]));
  let total = 0;
  normalizedUnlocks.forEach((id) => {
    let rarity = null;
    if (customMap.has(id)) {
      rarity = customMap.get(id).rarity;
    } else {
      const meta = resolveAvatarMetaById(id);
      rarity = meta ? meta.rarity : null;
    }
    if (rarity && AVATAR_RARITY_ATTRIBUTE_BONUS[rarity]) {
      total += AVATAR_RARITY_ATTRIBUTE_BONUS[rarity];
    }
  });
  return total;
}

function ensureCustomAvatarsUnlocked(entries = [], unlocks = []) {
  const normalizedEntries = normalizeAvatarCatalog(entries);
  const unlockList = normalizeAvatarUnlocks(unlocks);
  const unlockSet = new Set(unlockList);
  let changed = false;
  normalizedEntries.forEach((entry) => {
    if (!unlockSet.has(entry.id)) {
      unlockSet.add(entry.id);
      unlockList.push(entry.id);
      changed = true;
    }
  });
  return changed ? unlockList : unlockList;
}

function buildAvatarImageUrlByFile(file) {
  const normalized = normalizeAvatarFileName(file);
  if (!normalized) {
    return '';
  }
  return `${AVATAR_IMAGE_BASE_PATH}/${normalized}.png`;
}

function buildCharacterImageUrlByFile(file) {
  const normalized = normalizeAvatarFileName(file);
  if (!normalized) {
    return '';
  }
  return `${CHARACTER_IMAGE_BASE_PATH}/${normalized}.png`;
}

function resolveAvatarIdByFile(file) {
  const normalized = normalizeAvatarFileName(file);
  if (!normalized) {
    return '';
  }
  return AVATAR_FILE_INDEX.get(normalized) || '';
}

const DEFAULT_CHARACTER_IMAGE_BASE_PATH = CLOUD_ASSET_BASE_PATH + '/character';

const AVATAR_URL_PATTERN = /\/assets\/avatar\/([a-z0-9_-]+)\.png(?:\?.*)?$/i;

function extractAvatarFileFromUrl(url) {
  if (typeof url !== 'string') {
    return '';
  }
  const match = url.trim().toLowerCase().match(AVATAR_URL_PATTERN);
  if (!match) {
    return '';
  }
  return match[1];
}

function extractAvatarIdFromUrl(url) {
  const file = extractAvatarFileFromUrl(url);
  if (!file) {
    return '';
  }
  const byFile = resolveAvatarIdByFile(file);
  if (byFile) {
    return byFile;
  }
  return normalizeAvatarId(file);
}

function resolveCharacterPortraitFromAvatarUrl(url) {
  const avatarId = extractAvatarIdFromUrl(url);
  if (avatarId) {
    const portrait = buildCharacterUrlById(avatarId);
    if (portrait) {
      return portrait;
    }
  }
  const file = extractAvatarFileFromUrl(url);
  if (file) {
    return buildCharacterImageUrlByFile(file);
  }
  return '';
}

function normalizePortraitUrl(candidate) {
  if (!candidate) {
    return '';
  }
  if (typeof candidate === 'string') {
    const trimmed = candidate.trim();
    if (!trimmed) {
      return '';
    }
    const portrait = resolveCharacterPortraitFromAvatarUrl(trimmed);
    return portrait || trimmed;
  }
  if (typeof candidate === 'object') {
    const directPortrait = normalizePortraitUrl(candidate.portrait);
    if (directPortrait) {
      return directPortrait;
    }
    return normalizePortraitUrl(candidate.avatarUrl);
  }
  return '';
}

function pickPortraitUrl(...candidates) {
  for (let i = 0; i < candidates.length; i += 1) {
    const resolved = normalizePortraitUrl(candidates[i]);
    if (resolved) {
      return resolved;
    }
  }
  return '';
}
// 从member/shared/avatar-frames.local.js中提取为公共模块
const AVATAR_FRAME_BASE_PATH = AVATAR_FRAME_IMAGE_BASE_PATH;
const AVATAR_FRAME_IDS = ['1', '2', '3'];

const AVATAR_FRAME_URLS = AVATAR_FRAME_IDS.map((id) => `${AVATAR_FRAME_BASE_PATH}/${id}.png`);

function listAvatarFrameUrls() {
  return AVATAR_FRAME_URLS.slice();
}

function buildAvatarFrameUrlById(id) {
  if (typeof id !== 'string') {
    return '';
  }
  const trimmed = id.trim();
  if (!trimmed) {
    return '';
  }
  if (!AVATAR_FRAME_IDS.includes(trimmed)) {
    return '';
  }
  return `${AVATAR_FRAME_BASE_PATH}/${trimmed}.png`;
}

function isValidAvatarFrameUrl(url) {
  if (typeof url !== 'string') {
    return false;
  }
  const trimmed = url.trim();
  if (!trimmed) {
    return false;
  }
  return AVATAR_FRAME_URLS.includes(trimmed);
}

function normalizeAvatarFrameValue(value) {
  if (typeof value !== 'string') {
    return '';
  }
  const trimmed = value.trim();
  if (!trimmed) {
    return '';
  }
  if (AVATAR_FRAME_URLS.includes(trimmed)) {
    return trimmed;
  }
  const byId = buildAvatarFrameUrlById(trimmed);
  if (byId) {
    return byId;
  }
  return '';
}

const SUB_LEVEL_COUNT =
  Array.isArray(subLevelLabels) && subLevelLabels.length ? subLevelLabels.length : 10;

function collectRightIdsFromRewards(list, targetSet) {
  if (!Array.isArray(list) || !targetSet) {
    return;
  }
  list.forEach((entry) => {
    if (!entry || typeof entry !== 'object') {
      return;
    }
    const rightId = typeof entry.rightId === 'string' ? entry.rightId.trim() : '';
    if (rightId) {
      targetSet.add(rightId);
    }
  });
}

function collectRightIdsFromInventory(list, targetSet) {
  if (!Array.isArray(list) || !targetSet) {
    return;
  }
  list.forEach((item) => {
    if (!item || typeof item !== 'object') {
      return;
    }
    if (typeof item.rightId === 'string' && item.rightId.trim()) {
      targetSet.add(item.rightId.trim());
      return;
    }
    const usage = item.usage && typeof item.usage === 'object' ? item.usage : null;
    if (!usage) {
      return;
    }
    const usageType = typeof usage.type === 'string' ? usage.type.trim().toLowerCase() : '';
    if (!usageType) {
      return;
    }
    if (usageType === 'grantright' || usageType === 'grantcoupon' || usageType === 'coupon') {
      const usageRightId = typeof usage.rightId === 'string' ? usage.rightId.trim() : '';
      if (usageRightId) {
        targetSet.add(usageRightId);
      }
    }
  });
}

function resolveBreakthroughRightIdSet(level) {
  const ids = new Set();
  if (!level || typeof level !== 'object') {
    return ids;
  }
  collectRightIdsFromRewards(level.breakthroughRewards, ids);
  collectRightIdsFromRewards(level.milestoneRewards, ids);
  collectRightIdsFromRewards(level.breakthroughRights, ids);
  collectRightIdsFromRewards(level.milestoneRights, ids);

  const inventorySources = [
    level.breakthroughInventory,
    level.milestoneInventory,
    level.milestoneItems,
    level.breakthroughItems
  ];
  inventorySources.forEach((items) => collectRightIdsFromInventory(items, ids));

  return ids;
}

function resolveRegularLevelRights(level) {
  if (!level || !Array.isArray(level.rewards)) {
    return [];
  }
  const milestoneRightIds = resolveBreakthroughRightIdSet(level);
  if (!milestoneRightIds.size) {
    return level.rewards.slice();
  }
  return level.rewards.filter((reward) => {
    if (!reward || typeof reward.rightId !== 'string') {
      return true;
    }
    const trimmed = reward.rightId.trim();
    if (!trimmed) {
      return true;
    }
    return !milestoneRightIds.has(trimmed);
  });
}

function normalizeLevels(levels = []) {
  return levels
    .filter((level) => level && level._id)
    .sort((a, b) => {
      const orderA = typeof a.order === 'number' ? a.order : Number.POSITIVE_INFINITY;
      const orderB = typeof b.order === 'number' ? b.order : Number.POSITIVE_INFINITY;
      if (orderA === orderB) {
        return String(a._id).localeCompare(String(b._id));
      }
      return orderA - orderB;
    });
}

function resolveSubLevel(level) {
  if (!level) {
    return 1;
  }
  if (typeof level.subLevel === 'number' && Number.isFinite(level.subLevel)) {
    return Math.max(1, Math.floor(level.subLevel));
  }
  if (typeof level.order === 'number' && Number.isFinite(level.order)) {
    const perRealm = SUB_LEVEL_COUNT > 0 ? SUB_LEVEL_COUNT : 10;
    return Math.max(1, ((Math.floor(level.order) - 1) % perRealm) + 1);
  }
  return 1;
}

function resolveRealmOrderFromLevel(level) {
  if (!level) {
    return 1;
  }
  const { realmOrder, order } = level;
  if (typeof realmOrder === 'number' && Number.isFinite(realmOrder)) {
    return Math.max(1, Math.floor(realmOrder));
  }
  if (typeof order === 'number' && Number.isFinite(order)) {
    const perRealm = SUB_LEVEL_COUNT > 0 ? SUB_LEVEL_COUNT : 10;
    return Math.max(1, Math.floor((order - 1) / perRealm) + 1);
  }
  return 1;
}

function requiresBreakthrough(currentLevel, nextLevel) {
  if (!currentLevel || !nextLevel) {
    return false;
  }
  const currentRealm = resolveRealmOrderFromLevel(currentLevel);
  const nextRealm = resolveRealmOrderFromLevel(nextLevel);
  if (nextRealm <= currentRealm) {
    return false;
  }
  return resolveSubLevel(currentLevel) >= SUB_LEVEL_COUNT;
}

function getNextLevel(sortedLevels, currentLevel) {
  if (!currentLevel) {
    return null;
  }
  const idx = sortedLevels.findIndex((item) => item && item._id === currentLevel._id);
  if (idx < 0 || idx >= sortedLevels.length - 1) {
    return null;
  }
  return sortedLevels[idx + 1];
}

function getPreviousLevel(sortedLevels, currentLevel) {
  if (!currentLevel) {
    return null;
  }
  const idx = sortedLevels.findIndex((item) => item && item._id === currentLevel._id);
  if (idx <= 0) {
    return null;
  }
  return sortedLevels[idx - 1];
}

function getLevelThreshold(level) {
  if (!level || typeof level.threshold !== 'number') {
    return Number.POSITIVE_INFINITY;
  }
  const value = Number(level.threshold);
  return Number.isFinite(value) ? value : Number.POSITIVE_INFINITY;
}

function normalizePendingId(member) {
  if (member && typeof member.pendingBreakthroughLevelId === 'string') {
    return member.pendingBreakthroughLevelId;
  }
  return '';
}

function analyzeMemberLevelProgress(member, levels = []) {
  const sortedLevels = normalizeLevels(levels);
  if (!member || !sortedLevels.length) {
    return {
      levelId: member && member.levelId ? member.levelId : '',
      pendingBreakthroughLevelId: normalizePendingId(member),
      currentLevel: null,
      levelsToGrant: []
    };
  }

  let currentLevel =
    sortedLevels.find((level) => level && level._id === member.levelId) || sortedLevels[0];
  let resolvedLevelId = currentLevel ? currentLevel._id : '';
  let pendingBreakthroughLevelId = normalizePendingId(member);
  const experience = Number(member.experience || 0);
  const levelsToGrant = [];

  if (currentLevel) {
    let downgradeTarget = currentLevel;
    while (downgradeTarget && experience < getLevelThreshold(downgradeTarget)) {
      const previous = getPreviousLevel(sortedLevels, downgradeTarget);
      if (!previous) {
        break;
      }
      downgradeTarget = previous;
    }
    if (downgradeTarget && downgradeTarget._id !== currentLevel._id) {
      currentLevel = downgradeTarget;
      resolvedLevelId = downgradeTarget._id;
      pendingBreakthroughLevelId = '';
    }
  }

  if (pendingBreakthroughLevelId) {
    const pendingLevel = sortedLevels.find((level) => level && level._id === pendingBreakthroughLevelId);
    if (
      !pendingLevel ||
      !requiresBreakthrough(currentLevel, pendingLevel) ||
      experience < getLevelThreshold(pendingLevel)
    ) {
      pendingBreakthroughLevelId = '';
    }
  }

  while (true) {
    const nextLevel = getNextLevel(sortedLevels, currentLevel);
    if (!nextLevel) {
      break;
    }
    const threshold = getLevelThreshold(nextLevel);
    if (experience < threshold) {
      break;
    }
    if (requiresBreakthrough(currentLevel, nextLevel)) {
      pendingBreakthroughLevelId = nextLevel._id;
      break;
    }
    levelsToGrant.push(nextLevel);
    resolvedLevelId = nextLevel._id;
    currentLevel = nextLevel;
    pendingBreakthroughLevelId = '';
  }

  return {
    levelId: resolvedLevelId,
    pendingBreakthroughLevelId,
    currentLevel,
    levelsToGrant
  };
}


module.exports = {
  EXPERIENCE_PER_YUAN,
  COLLECTIONS,
  TRADING_CONFIG,
  EXCLUDED_TRANSACTION_STATUSES,
  DEFAULT_ADMIN_ROLES,
  subLevelLabels,
  realmConfigs,
  membershipRights,
  CLOUD_ASSET_BASE_PATH,
  AVATAR_IMAGE_BASE_PATH,
  AVATAR_FRAME_IMAGE_BASE_PATH,
  BACKGROUND_IMAGE_BASE_PATH,
  BACKGROUND_VIDEO_BASE_PATH,
  CHARACTER_IMAGE_BASE_PATH,
  TITLE_IMAGE_BASE_PATH,
  buildCloudAssetUrl,
  listBackgrounds,
  resolveBackgroundById,
  resolveBackgroundByRealmName,
  normalizeBackgroundId,
  getDefaultBackgroundId,
  isBackgroundUnlocked,
  resolveHighestUnlockedBackgroundByRealmOrder,
  normalizeBackgroundCatalogEntry,
  normalizeBackgroundCatalog,
  normalizeBackgroundMediaKey,
  generateCustomBackgroundId,
  areBackgroundCatalogsEqual,
  registerCustomBackgrounds,
  // avatar-catalog，原云函数member/avatar-catalog.local.js
  RAW_AVATARS,
  AVATAR_RARITIES,
  AVATAR_RARITY_ATTRIBUTE_BONUS,
  buildAvatarId,
  listAvatarIds,
  registerCustomAvatars,
  normalizeAvatarCatalog,
  normalizeAvatarCatalogEntry,
  normalizeAvatarFileName,
  normalizeAvatarGender,
  normalizeAvatarRarity,
  normalizeAvatarUnlocks,
  resolveAvatarMetaById,
  listRegisteredAvatars,
  buildAvatarUrl,
  buildCharacterUrlById,
  buildAvatarImageUrlByFile,
  buildCharacterImageUrlByFile,
  resolveAvatarIdByFile,
  calculateAvatarAttributeBonus,
  ensureCustomAvatarsUnlocked,
  // shared/avatar-utils.js提取到公共模块
  resolveCharacterPortraitFromAvatarUrl,
  normalizePortraitUrl,
  pickPortraitUrl,
  extractAvatarIdFromUrl,
  // member/shared/avatar-frames.local.js
  AVATAR_FRAME_BASE_PATH,
  AVATAR_FRAME_IDS,
  AVATAR_FRAME_URLS,
  listAvatarFrameUrls,
  buildAvatarFrameUrlById,
  isValidAvatarFrameUrl,
  normalizeAvatarFrameValue,
  analyzeMemberLevelProgress,
  resolveBreakthroughRightIdSet,
  resolveRegularLevelRights,
  requiresBreakthrough,
  resolveRealmOrderFromLevel,
  resolveSubLevel
};
