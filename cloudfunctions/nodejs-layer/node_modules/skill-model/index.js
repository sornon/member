'use strict';

const BASE_ATTRIBUTE_KEYS = ['constitution', 'strength', 'spirit', 'root', 'agility', 'insight'];
const COMBAT_STAT_KEYS = [
  'maxHp',
  'physicalAttack',
  'magicAttack',
  'physicalDefense',
  'magicDefense',
  'speed',
  'accuracy',
  'dodge',
  'critRate',
  'critDamage',
  'critResist',
  'finalDamageBonus',
  'finalDamageReduction',
  'lifeSteal',
  'healingBonus',
  'healingReduction',
  'controlHit',
  'controlResist',
  'physicalPenetration',
  'magicPenetration',
  'comboRate',
  'block',
  'counterRate',
  'damageReduction',
  'healingReceived',
  'rageGain',
  'controlStrength',
  'shieldPower',
  'summonPower',
  'elementalVulnerability'
];

const SPECIAL_STAT_KEYS = [
  'shield',
  'bonusDamage',
  'dodgeChance',
  'healOnHit',
  'healOnKill',
  'damageReflection',
  'healPerRound',
  'healOnTrigger'
];

const SKILL_EFFECT_TYPES = {
  damage: { key: 'damage', label: '伤害' },
  crit: { key: 'crit', label: '暴击' },
  shield: { key: 'shield', label: '护盾' },
  reflect: { key: 'reflect', label: '反伤' },
  heal: { key: 'heal', label: '治疗' },
  dot: { key: 'dot', label: '持续伤害' },
  control: { key: 'control', label: '控制' },
  slow: { key: 'slow', label: '减速' },
  debuff: { key: 'debuff', label: '削弱' },
  buff: { key: 'buff', label: '增益' },
  resource: { key: 'resource', label: '资源' },
  stacking: { key: 'stacking', label: '叠层' },
  cooldown: { key: 'cooldown', label: '冷却' },
  defense: { key: 'defense', label: '防御' },
  utility: { key: 'utility', label: '通用' },
  generic: { key: 'generic', label: '其他' }
};

const SKILL_EFFECT_LABEL_CONFIG = {
  主倍率: { type: SKILL_EFFECT_TYPES.damage.key, template: '主倍率 {{value}}' },
  暴击追加伤害: { type: SKILL_EFFECT_TYPES.crit.key, template: '暴击追加伤害 {{value}}' },
  命中倍率: { type: SKILL_EFFECT_TYPES.damage.key, template: '命中倍率 {{value}}' },
  灼烧伤害: { type: SKILL_EFFECT_TYPES.dot.key, template: '灼烧伤害 {{value}}' },
  持续回合: { type: SKILL_EFFECT_TYPES.control.key, template: '持续 {{value}}' },
  减速幅度: { type: SKILL_EFFECT_TYPES.slow.key, template: '减速 {{value}}', transform: 'abs' },
  触发减伤: { type: SKILL_EFFECT_TYPES.defense.key, template: '触发减伤 {{value}}' },
  即时回复: { type: SKILL_EFFECT_TYPES.heal.key, template: '即时回复 {{value}}' },
  反震比例: { type: SKILL_EFFECT_TYPES.reflect.key, template: '反震 {{value}}' },
  灵兽攻击力加成: { type: SKILL_EFFECT_TYPES.buff.key, template: '灵兽攻击力加成 {{value}}' },
  触发回复: { type: SKILL_EFFECT_TYPES.heal.key, template: '触发回复 {{value}}' },
  触发冷却: { type: SKILL_EFFECT_TYPES.cooldown.key, template: '触发冷却 {{value}}' },
  眩晕命中率: { type: SKILL_EFFECT_TYPES.control.key, template: '眩晕命中率 {{value}}' },
  控制时长: { type: SKILL_EFFECT_TYPES.control.key, template: '控制时长 {{value}}' },
  防御削减: { type: SKILL_EFFECT_TYPES.debuff.key, template: '防御降低 {{value}}', transform: 'abs' },
  中毒伤害: { type: SKILL_EFFECT_TYPES.dot.key, template: '中毒伤害 {{value}}' },
  真气上限: { type: SKILL_EFFECT_TYPES.resource.key, template: '真气上限 {{value}}' },
  回合回复: { type: SKILL_EFFECT_TYPES.heal.key, template: '每回合回复 {{value}}' },
  单段倍率: { type: SKILL_EFFECT_TYPES.damage.key, template: '单段倍率 {{value}}' },
  段数: { type: SKILL_EFFECT_TYPES.damage.key, template: '段数 {{value}}' },
  剑气附加倍率: { type: SKILL_EFFECT_TYPES.damage.key, template: '剑气附加倍率 {{value}}' },
  易伤幅度: { type: SKILL_EFFECT_TYPES.debuff.key, template: '易伤 {{value}}', transform: 'abs' },
  连锁上限: { type: SKILL_EFFECT_TYPES.utility.key, template: '连锁上限 {{value}}' },
  护盾吸收: {
    type: SKILL_EFFECT_TYPES.shield.key,
    template: '护盾吸收 {{value}} 生命',
    groups: {
      body_furnace_of_ruin: { group: 'body_furnace_of_ruin.core', connector: '', groupSuffix: '' }
    }
  },
  反射灼烧: {
    type: SKILL_EFFECT_TYPES.reflect.key,
    template: '对近战者反射 {{value}} 真实灼烧',
    groups: {
      body_furnace_of_ruin: { group: 'body_furnace_of_ruin.core', connector: '并' }
    }
  },
  爆裂伤害: {
    type: SKILL_EFFECT_TYPES.damage.key,
    template: '破裂时爆发 {{value}} 火伤',
    groups: {
      body_furnace_of_ruin: { group: 'body_furnace_of_ruin.core', connector: '；', groupSuffix: '。' }
    }
  },
  每层攻速: { type: SKILL_EFFECT_TYPES.buff.key, template: '每层攻速 {{value}}' },
  每层回气: { type: SKILL_EFFECT_TYPES.resource.key, template: '每层回气 {{value}}' },
  层数上限: { type: SKILL_EFFECT_TYPES.stacking.key, template: '层数上限 {{value}}' },
  灵兽伤害加成: { type: SKILL_EFFECT_TYPES.buff.key, template: '灵兽伤害加成 {{value}}' },
  技能冷却缩减: { type: SKILL_EFFECT_TYPES.cooldown.key, template: '技能冷却 {{value}}' },
  主人下次技能增伤: { type: SKILL_EFFECT_TYPES.damage.key, template: '主人下次技能增伤 {{value}}' },
  沉默命中率: { type: SKILL_EFFECT_TYPES.control.key, template: '沉默命中率 {{value}}' },
  真气回复压制: {
    type: SKILL_EFFECT_TYPES.debuff.key,
    template: '真气回复压制 {{value}}',
    transform: 'abs'
  },
  抗性提升: { type: SKILL_EFFECT_TYPES.buff.key, template: '抗性提升 {{value}}' },
  敏捷加成: { type: SKILL_EFFECT_TYPES.buff.key, template: '敏捷加成 {{value}}' },
  单格倍率: { type: SKILL_EFFECT_TYPES.damage.key, template: '单格倍率 {{value}}' },
  目标数量: { type: SKILL_EFFECT_TYPES.utility.key, template: '目标数量 {{value}}' },
  攻速降低: {
    type: SKILL_EFFECT_TYPES.debuff.key,
    template: '攻速降低 {{value}}',
    transform: 'abs'
  },
  基础倍率: { type: SKILL_EFFECT_TYPES.damage.key, template: '基础倍率 {{value}}' },
  灼烧追加: { type: SKILL_EFFECT_TYPES.dot.key, template: '灼烧追加 {{value}}' },
  生命回复: { type: SKILL_EFFECT_TYPES.heal.key, template: '生命回复 {{value}}' },
  额外火伤: { type: SKILL_EFFECT_TYPES.damage.key, template: '额外火伤 {{value}}' },
  即时治疗: { type: SKILL_EFFECT_TYPES.heal.key, template: '即时治疗 {{value}}' },
  治疗量加成: { type: SKILL_EFFECT_TYPES.heal.key, template: '治疗量加成 {{value}}' },
  触发冷却缩减: { type: SKILL_EFFECT_TYPES.cooldown.key, template: '触发冷却 {{value}}' },
  触发间隔: { type: SKILL_EFFECT_TYPES.cooldown.key, template: '触发间隔 {{value}}' },
  妖气回复压制: {
    type: SKILL_EFFECT_TYPES.debuff.key,
    template: '妖气回复压制 {{value}}',
    transform: 'abs'
  },
  冷却时间: { type: SKILL_EFFECT_TYPES.cooldown.key, template: '冷却时间 {{value}}' },
  剑炎爆发: { type: SKILL_EFFECT_TYPES.damage.key, template: '剑炎爆发 {{value}}' },
  冻结命中率: { type: SKILL_EFFECT_TYPES.control.key, template: '冻结命中率 {{value}}' },
  破冰伤害: { type: SKILL_EFFECT_TYPES.damage.key, template: '破冰伤害 {{value}}' },
  火势每层加成: { type: SKILL_EFFECT_TYPES.buff.key, template: '火势每层加成 {{value}}' },
  反射伤害: { type: SKILL_EFFECT_TYPES.reflect.key, template: '反射伤害 {{value}}' },
  减伤幅度: { type: SKILL_EFFECT_TYPES.defense.key, template: '减伤 {{value}}' },
  反击伤害: { type: SKILL_EFFECT_TYPES.reflect.key, template: '反击伤害 {{value}}' },
  触发回气: { type: SKILL_EFFECT_TYPES.resource.key, template: '触发回气 {{value}}' },
  增益延长: { type: SKILL_EFFECT_TYPES.utility.key, template: '增益延长 {{value}}' },
  连锁目标: { type: SKILL_EFFECT_TYPES.utility.key, template: '连锁目标 {{value}}' },
  范围减速: {
    type: SKILL_EFFECT_TYPES.slow.key,
    template: '范围减速 {{value}}',
    transform: 'abs'
  },
  治疗压制: {
    type: SKILL_EFFECT_TYPES.debuff.key,
    template: '治疗降低 {{value}}',
    transform: 'abs'
  }
};


const SKILL_TYPES = {
  active: { key: 'active', label: '主动技能' },
  passive: { key: 'passive', label: '被动技能' }
};

const SKILL_DISCIPLINES = {
  sword: { key: 'sword', label: '剑修' },
  spell: { key: 'spell', label: '法修' },
  body: { key: 'body', label: '体修' },
  beast: { key: 'beast', label: '御兽' },
  sigil: { key: 'sigil', label: '符箓' }
};

const ELEMENT_CONFIG = {
  none: { key: 'none', label: '无属性', color: '#c4ccdd' },
  fire: { key: 'fire', label: '火系', color: '#ff7243' },
  lightning: { key: 'lightning', label: '雷系', color: '#8a9eff' },
  water: { key: 'water', label: '水系', color: '#4ac6ff' },
  wood: { key: 'wood', label: '木系', color: '#54d794' },
  earth: { key: 'earth', label: '土系', color: '#d49a62' },
  poison: { key: 'poison', label: '毒系', color: '#9dc35d' }
};

const SKILL_QUALITY_CONFIG = {
  linggan: {
    key: 'linggan',
    label: '灵感',
    color: '#6c8cff',
    weight: 58,
    maxLevel: 25,
    imprintSlots: [{ unlockLevel: 25, count: 1 }]
  },
  kaipi: {
    key: 'kaipi',
    label: '开辟',
    color: '#45c0a8',
    weight: 24,
    maxLevel: 35,
    imprintSlots: [{ unlockLevel: 25, count: 1 }]
  },
  tongxuan: {
    key: 'tongxuan',
    label: '通玄',
    color: '#b281ff',
    weight: 12,
    maxLevel: 50,
    imprintSlots: [
      { unlockLevel: 25, count: 1 },
      { unlockLevel: 50, count: 2, breakthrough: true }
    ]
  },
  wudao: {
    key: 'wudao',
    label: '悟道',
    color: '#f2a546',
    weight: 6,
    maxLevel: 50,
    imprintSlots: [
      { unlockLevel: 25, count: 1 },
      { unlockLevel: 40, count: 2 },
      { unlockLevel: 50, count: 3, exclusive: true }
    ]
  }
};


const SKILL_LIBRARY = [
  {
    id: 'sword_breaking_clouds',
    name: '破云斩',
    quality: 'linggan',
    type: 'active',
    discipline: 'sword',
    element: 'none',
    description: '以剑气撕裂前方敌人，奠定剑修入门的爆发节奏。',
    params: { cooldown: 2, cost: 20, range: '单体' },
    mechanics: ['造成 120% 攻击伤害，若暴击则额外造成 30% 伤害。'],
    growth: ['每级伤害 +4%，25 级解锁 1 个印记槽。'],
    progression: [
      { label: '主倍率', base: 1.2, perLevel: 0.04, format: 'percent' },
      { label: '暴击追加伤害', base: 0.3, perLevel: 0.02, format: 'percent' }
    ],
    tags: ['单体', '爆发'],
    maxLevel: 25
  },
  {
    id: 'spell_burning_burst',
    name: '烈炽火弹',
    quality: 'linggan',
    type: 'active',
    discipline: 'spell',
    element: 'fire',
    description: '凝聚火弹轰击目标，为法修建立起持续燃烧的基础。',
    params: { cooldown: 3, cost: 22, range: '单体' },
    mechanics: ['命中造成 100% 法攻，并附加 2 回合灼烧（每回合 20% 法攻）。'],
    growth: ['每级灼烧伤害 +2%，冷却固定 3 回合。'],
    progression: [
      { label: '命中倍率', base: 1, perLevel: 0.02, format: 'percent' },
      { label: '灼烧伤害', base: 0.2, perLevel: 0.02, format: 'percent', suffix: '/回合' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['DOT', '火系'],
    maxLevel: 25
  },
  {
    id: 'spell_frost_bolt',
    name: '凝霜矢',
    quality: 'kaipi',
    type: 'active',
    discipline: 'spell',
    element: 'water',
    description: '由灵力凝成的寒矢，命中即可拖慢敌人的行动。',
    params: { cooldown: 3, cost: 24, range: '单体' },
    mechanics: ['造成 130% 法攻并减速 30% 持续 2 回合。'],
    growth: ['每级伤害 +3%，减速 +1%。'],
    progression: [
      { label: '命中倍率', base: 1.3, perLevel: 0.03, format: 'percent' },
      { label: '减速幅度', base: -0.3, perLevel: -0.01, format: 'percent' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['减速', '水系'],
    maxLevel: 35
  },
  {
    id: 'body_bronze_skin',
    name: '铜皮诀',
    quality: 'linggan',
    type: 'passive',
    discipline: 'body',
    element: 'earth',
    description: '借地气淬体，短时化身铜皮铁骨，抵御外伤。',
    mechanics: ['受击时获得 8% 减伤，持续 1 回合，冷却 3 回合。'],
    growth: ['每级额外减伤 +0.5%，冷却不变。'],
    modifiers: { base: { damageReduction: 0.08 }, perLevel: { damageReduction: 0.005 } },
    progression: [
      { label: '触发减伤', base: 0.08, perLevel: 0.005, format: 'percent' },
      { label: '持续回合', base: 1, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['防御', '减伤'],
    maxLevel: 25
  },
  {
    id: 'body_blood_ignite',
    name: '焚血激',
    quality: 'kaipi',
    type: 'active',
    discipline: 'body',
    element: 'fire',
    description: '燃烧精血换取瞬间续航与反击之势。',
    params: { cooldown: 4, cost: 18, range: '自身' },
    mechanics: ['回复 15% 生命并获得 10% 反震，持续 2 回合。'],
    growth: ['每级回复 +1%，反震 +1%。'],
    progression: [
      { label: '即时回复', base: 0.15, perLevel: 0.01, format: 'percent' },
      { label: '反震比例', base: 0.1, perLevel: 0.01, format: 'percent' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['续航', '反震'],
    maxLevel: 35
  },
  {
    id: 'beast_spirit_pact',
    name: '灵契术',
    quality: 'linggan',
    type: 'active',
    discipline: 'beast',
    element: 'wood',
    description: '与灵兽缔结短暂契约，唤醒潜藏的攻击本能。',
    params: { cooldown: 4, cost: 20, range: '灵兽' },
    mechanics: ['灵兽攻击力 +15%，持续 3 回合。'],
    growth: ['每级加成 +1%，25 级解锁印记槽。'],
    progression: [
      { label: '灵兽攻击力加成', base: 0.15, perLevel: 0.01, format: 'percent' },
      { label: '持续回合', base: 3, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['御兽', '增益'],
    maxLevel: 25
  },
  {
    id: 'beast_war_drum',
    name: '兽魂鼓',
    quality: 'kaipi',
    type: 'passive',
    discipline: 'beast',
    element: 'lightning',
    description: '灵鼓震荡心神，灵兽出手即回荡真气。',
    mechanics: ['灵兽释放技能后，主人回复 5% 真气，冷却 2 回合。'],
    growth: ['每级真气回复 +0.3%。'],
    progression: [
      { label: '触发回复', base: 0.05, perLevel: 0.003, format: 'percent' },
      { label: '触发冷却', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['回气', '御兽'],
    maxLevel: 35
  },
  {
    id: 'sigil_focus_talisman',
    name: '定神符',
    quality: 'linggan',
    type: 'active',
    discipline: 'sigil',
    element: 'lightning',
    description: '以雷纹封锁心神，短暂夺去敌人的行动。',
    params: { cooldown: 5, cost: 26, range: '单体' },
    mechanics: ['80% 命中率眩晕 1 回合，未命中仍造成微量雷伤。'],
    growth: ['每级命中率 +2%。'],
    progression: [
      { label: '眩晕命中率', base: 0.8, perLevel: 0.02, format: 'percent' },
      { label: '控制时长', base: 1, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['眩晕', '控制'],
    maxLevel: 25
  },
  {
    id: 'sigil_corroding_mark',
    name: '蚀骨符',
    quality: 'kaipi',
    type: 'active',
    discipline: 'sigil',
    element: 'poison',
    description: '以腐蚀灵纹侵蚀对手筋骨，削弱其护体灵力。',
    params: { cooldown: 4, cost: 24, range: '单体' },
    mechanics: ['降低敌方 10% 防御并施加每回合 10% 中毒，持续 3 回合。'],
    growth: ['每级防御降低 +0.5%。'],
    progression: [
      { label: '防御削减', base: -0.1, perLevel: -0.005, format: 'percent' },
      { label: '中毒伤害', base: 0.1, perLevel: 0.005, format: 'percent', suffix: '/回合' },
      { label: '持续回合', base: 3, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['减防', '毒系'],
    maxLevel: 35
  },
  {
    id: 'sigil_void_respiration',
    name: '虚神息',
    quality: 'kaipi',
    type: 'passive',
    discipline: 'sigil',
    element: 'water',
    description: '调息真灵，扩展体内真气的循环空间。',
    mechanics: ['真气上限 +10%，回合结束额外回复 1% 真气。'],
    growth: ['每级真气上限 +1%。'],
    progression: [
      { label: '真气上限', base: 0.1, perLevel: 0.01, format: 'percent' },
      { label: '回合回复', base: 0.01, perLevel: 0, format: 'percent', suffix: '/回合' }
    ],
    tags: ['回气', '辅助'],
    maxLevel: 35
  },
  {
    id: 'sword_thousand_blades',
    name: '千刃星陨',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'sword',
    element: 'lightning',
    description: '汇聚剑意，雷霆般斩击四次，立刻压制要害。',
    params: { cooldown: 4, cost: 40, range: '单体' },
    mechanics: ['消耗 3 层剑意连续斩击 4 次，每次 70% 攻击；击杀刷新冷却。'],
    growth: ['每级每段伤害 +3%，剑意消耗固定。'],
    progression: [
      { label: '单段倍率', base: 0.7, perLevel: 0.03, format: 'percent' },
      { label: '段数', base: 4, perLevel: 0, format: 'integer', suffix: '段', digits: 0 }
    ],
    tags: ['连击', '爆发'],
    maxLevel: 50
  },
  {
    id: 'sword_immortal_domain',
    name: '戮仙剑域',
    quality: 'wudao',
    type: 'active',
    discipline: 'sword',
    element: 'none',
    description: '展开三回合剑域，将普攻与技能转化为无尽剑雨。',
    params: { cooldown: 6, cost: 55, range: '自身领域' },
    mechanics: ['普攻与技能额外触发 50% 剑气，暴击时生成剑意。'],
    growth: ['每级剑气伤害 +2%，专属符印提供穿透或变体效果。'],
    progression: [
      { label: '剑气附加倍率', base: 0.5, perLevel: 0.02, format: 'percent' },
      { label: '持续回合', base: 3, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['领域', '爆发'],
    maxLevel: 50
  },
  {
    id: 'spell_pyrocataclysm',
    name: '离火焚天',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'spell',
    element: 'fire',
    description: '布设离火阵焚烧战场，叠加灼烧与易伤。',
    params: { cooldown: 5, cost: 42, range: '大范围' },
    mechanics: ['造成 180% 法攻并附加 15% 易伤，灼烧每回合 30% 法攻。'],
    growth: ['每级伤害 +4%，易伤 +1%。'],
    progression: [
      { label: '命中倍率', base: 1.8, perLevel: 0.04, format: 'percent' },
      { label: '易伤幅度', base: 0.15, perLevel: 0.01, format: 'percent' },
      { label: '灼烧伤害', base: 0.3, perLevel: 0.015, format: 'percent', suffix: '/回合' }
    ],
    tags: ['AOE', '火系'],
    maxLevel: 50
  },
  {
    id: 'spell_thunder_chain',
    name: '万雷劫链',
    quality: 'wudao',
    type: 'active',
    discipline: 'spell',
    element: 'lightning',
    description: '雷霆链式劈落，撕裂群体并施加短暂眩晕。',
    params: { cooldown: 6, cost: 58, range: '链式 5 体' },
    mechanics: ['首目标 220% 法攻，最多连锁 5 名敌人，每次命中 40% 基础眩晕。'],
    growth: ['每级伤害 +5%，眩晕概率 +3%。'],
    progression: [
      { label: '命中倍率', base: 2.2, perLevel: 0.05, format: 'percent' },
      { label: '眩晕命中率', base: 0.4, perLevel: 0.03, format: 'percent' },
      { label: '连锁上限', base: 5, perLevel: 0, format: 'integer', suffix: '目标', digits: 0 }
    ],
    tags: ['群体', '眩晕'],
    maxLevel: 50
  },
  {
    id: 'body_diamond_eternity',
    name: '金刚不灭',
    quality: 'tongxuan',
    type: 'passive',
    discipline: 'body',
    element: 'earth',
    description: '濒死之际金刚护体，迅速稳住血线。',
    mechanics: ['生命低于 35% 触发 40% 减伤并每回合恢复 10% 生命，持续 3 回合，冷却 6 回合。'],
    growth: ['每级减伤 +2%，回复 +1%。'],
    modifiers: {
      base: { damageReduction: 0.4 },
      perLevel: { damageReduction: 0.02 },
      special: { healPerRound: 0.1 },
      specialPerLevel: { healPerRound: 0.01 },
      notes: ['生命低于 35% 触发，持续 3 回合，冷却 6 回合。']
    },
    progression: [
      { label: '触发减伤', base: 0.4, perLevel: 0.02, format: 'percent' },
      { label: '回合回复', base: 0.1, perLevel: 0.01, format: 'percent', suffix: '/回合' }
    ],
    tags: ['保命', '减伤'],
    maxLevel: 50
  },
  {
    id: 'body_furnace_of_ruin',
    name: '焚世熔炉',
    quality: 'wudao',
    type: 'active',
    discipline: 'body',
    element: 'fire',
    description: '化身熔炉，护盾吸收巨量伤害并反射灼烧。',
    params: { cooldown: 6, cost: 60, range: '自身' },
    mechanics: ['护盾吸收 40% 生命并对近战者反射 20% 真实灼烧；破裂时爆发 250% 火伤。'],
    growth: ['每级护盾 +3%，反射 +1%。'],
    progression: [
      { label: '护盾吸收', base: 0.4, perLevel: 0.03, format: 'percent' },
      { label: '反射灼烧', base: 0.2, perLevel: 0.01, format: 'percent' },
      { label: '爆裂伤害', base: 2.5, perLevel: 0.05, format: 'percent' }
    ],
    tags: ['护盾', '反击'],
    maxLevel: 50
  },
  {
    id: 'beast_shared_heart',
    name: '玄兽同心',
    quality: 'tongxuan',
    type: 'passive',
    discipline: 'beast',
    element: 'wood',
    description: '主宠同心协力，持续提升攻速与回气。',
    mechanics: ['灵兽命中给主人叠加“同心”层：攻速 +5%、真气回复 +5%，最高 5 层。'],
    growth: ['每级加成 +0.5%，倒地后保留 1 层。'],
    progression: [
      { label: '每层攻速', base: 0.05, perLevel: 0.005, format: 'percent' },
      { label: '每层回气', base: 0.05, perLevel: 0.005, format: 'percent' },
      { label: '层数上限', base: 5, perLevel: 0, format: 'integer', suffix: '层', digits: 0 }
    ],
    tags: ['攻速', '御兽'],
    maxLevel: 50
  },
  {
    id: 'beast_empyrial_charge',
    name: '帝御九霄',
    quality: 'wudao',
    type: 'active',
    discipline: 'beast',
    element: 'lightning',
    description: '统御灵兽极速协同，打造爆发回合。',
    params: { cooldown: 6, cost: 58, range: '灵兽' },
    mechanics: ['灵兽立即行动并获得伤害 +40%、技能冷却 -1；主人下次主动技能额外造成 100% 伤害。'],
    growth: ['每级狂暴加成 +2%，额外伤害 +5%。'],
    progression: [
      { label: '灵兽伤害加成', base: 0.4, perLevel: 0.02, format: 'percent' },
      { label: '技能冷却缩减', base: -1, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 },
      { label: '主人下次技能增伤', base: 1, perLevel: 0.05, format: 'percent' }
    ],
    tags: ['连携', '爆发'],
    maxLevel: 50
  },
  {
    id: 'sigil_soul_bind',
    name: '镇魂神符',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'sigil',
    element: 'water',
    description: '水灵镇压心魂，大范围沉默拖延敌阵节奏。',
    params: { cooldown: 5, cost: 44, range: '全体' },
    mechanics: ['沉默全体 2 回合并降低 20% 真气恢复，命中率 70%。'],
    growth: ['每级命中 +2%，减真气 +2%。'],
    progression: [
      { label: '沉默命中率', base: 0.7, perLevel: 0.02, format: 'percent' },
      { label: '真气回复压制', base: -0.2, perLevel: -0.02, format: 'percent' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['沉默', '群控'],
    maxLevel: 50
  },
  {
    id: 'sigil_taiyi_barrier',
    name: '太乙护界',
    quality: 'wudao',
    type: 'active',
    discipline: 'sigil',
    element: 'earth',
    description: '太乙护界笼罩全体，护盾与抗性同步提升。',
    params: { cooldown: 7, cost: 60, range: '全体友方' },
    mechanics: ['全体获得 30% 生命护盾 +20% 抗性，持续 3 回合；受控时自动净化并反射。'],
    growth: ['每级护盾 +2%、抗性 +1%，符印可解锁群体复活。'],
    progression: [
      { label: '护盾吸收', base: 0.3, perLevel: 0.02, format: 'percent' },
      { label: '抗性提升', base: 0.2, perLevel: 0.01, format: 'percent' },
      { label: '持续回合', base: 3, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['护盾', '净化'],
    maxLevel: 50
  },
  {
    id: 'sword_flowing_strike',
    name: '流光剑步',
    quality: 'kaipi',
    type: 'active',
    discipline: 'sword',
    element: 'lightning',
    description: '身影化流光，迅疾突进完成破绽打击。',
    params: { cooldown: 4, cost: 24, range: '突进单体' },
    mechanics: ['突进至目标身后造成 140% 攻击，自身敏捷 +12%，持续 2 回合。'],
    growth: ['每级伤害 +3%，敏捷加成 +0.5%。'],
    progression: [
      { label: '命中倍率', base: 1.4, perLevel: 0.03, format: 'percent' },
      { label: '敏捷加成', base: 0.12, perLevel: 0.005, format: 'percent' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['机动', '敏捷'],
    maxLevel: 35
  },
  {
    id: 'sword_flame_wings',
    name: '烈羽焚锋',
    quality: 'kaipi',
    type: 'active',
    discipline: 'sword',
    element: 'fire',
    description: '炽羽化刃，扫荡前方两格敌人。',
    params: { cooldown: 4, cost: 26, range: '前方两格' },
    mechanics: ['对前方两格各造成 135% 攻击并附 2 回合灼烧（每回合 15% 攻击）。'],
    growth: ['每级伤害 +3%，灼烧 +1%。'],
    progression: [
      { label: '单格倍率', base: 1.35, perLevel: 0.03, format: 'percent' },
      { label: '灼烧伤害', base: 0.15, perLevel: 0.01, format: 'percent', suffix: '/回合' },
      { label: '目标数量', base: 2, perLevel: 0, format: 'integer', suffix: '个', digits: 0 }
    ],
    tags: ['多段', '火系'],
    maxLevel: 35
  },
  {
    id: 'spell_frost_tide',
    name: '凌霜定潮',
    quality: 'kaipi',
    type: 'active',
    discipline: 'spell',
    element: 'water',
    description: '唤起寒潮限制敌人攻势。',
    params: { cooldown: 4, cost: 24, range: '小范围' },
    mechanics: ['造成 130% 法攻并降低目标 20% 攻速，持续 2 回合。'],
    growth: ['每级伤害 +2%，减速 +1%。'],
    progression: [
      { label: '命中倍率', base: 1.3, perLevel: 0.02, format: 'percent' },
      { label: '攻速降低', base: -0.2, perLevel: -0.01, format: 'percent' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['攻速削减', '水系'],
    maxLevel: 35
  },
  {
    id: 'spell_searing_comet',
    name: '灼脉流炬',
    quality: 'kaipi',
    type: 'active',
    discipline: 'spell',
    element: 'fire',
    description: '火线贯穿敌阵，对灼烧目标造成额外爆裂。',
    params: { cooldown: 4, cost: 28, range: '直线' },
    mechanics: ['直线造成 145% 法攻，命中灼烧目标额外造成 30% 瞬时伤害。'],
    growth: ['每级基础伤害 +3%，额外伤害 +2%。'],
    progression: [
      { label: '基础倍率', base: 1.45, perLevel: 0.03, format: 'percent' },
      { label: '灼烧追加', base: 0.3, perLevel: 0.02, format: 'percent' }
    ],
    tags: ['直线', '火系'],
    maxLevel: 35
  },
  {
    id: 'body_rockridge_guard',
    name: '岩嵯坚体',
    quality: 'kaipi',
    type: 'passive',
    discipline: 'body',
    element: 'earth',
    description: '遇到暴击时岩甲护体，提升坦度。',
    mechanics: ['受到暴击触发岩甲：减伤 25% 并回复 8% 生命，持续 1 回合，冷却 3 回合。'],
    growth: ['每级减伤 +1%，回复 +0.5%。'],
    modifiers: {
      base: { damageReduction: 0.25 },
      perLevel: { damageReduction: 0.01 },
      special: { healOnTrigger: 0.08 },
      specialPerLevel: { healOnTrigger: 0.005 },
      notes: ['受到暴击触发，持续 1 回合，冷却 3 回合。']
    },
    progression: [
      { label: '触发减伤', base: 0.25, perLevel: 0.01, format: 'percent' },
      { label: '生命回复', base: 0.08, perLevel: 0.005, format: 'percent' }
    ],
    tags: ['减伤', '恢复'],
    maxLevel: 35
  },
  {
    id: 'body_blood_fury',
    name: '熔血怒元',
    quality: 'kaipi',
    type: 'active',
    discipline: 'body',
    element: 'fire',
    description: '激发熔血之力，短时间化守为攻。',
    params: { cooldown: 4, cost: 20, range: '自身' },
    mechanics: ['立即回复 12% 生命并获得 15% 反震，持续 2 回合；被攻击者额外承受 10% 火伤。'],
    growth: ['每级回复 +0.8%，反震 +1%，火伤 +0.5%。'],
    progression: [
      { label: '即时回复', base: 0.12, perLevel: 0.008, format: 'percent' },
      { label: '反震比例', base: 0.15, perLevel: 0.01, format: 'percent' },
      { label: '额外火伤', base: 0.1, perLevel: 0.005, format: 'percent' }
    ],
    tags: ['反击', '火系'],
    maxLevel: 35
  },
  {
    id: 'beast_wood_blessing',
    name: '木灵惠泽',
    quality: 'kaipi',
    type: 'active',
    discipline: 'beast',
    element: 'wood',
    description: '木灵环绕，快速治愈灵兽伤势。',
    params: { cooldown: 5, cost: 22, range: '灵兽' },
    mechanics: ['灵兽回复 18% 生命并获得治疗量 +20%，持续 3 回合。'],
    growth: ['每级治疗加成 +1%。'],
    progression: [
      { label: '即时治疗', base: 0.18, perLevel: 0.008, format: 'percent' },
      { label: '治疗量加成', base: 0.2, perLevel: 0.01, format: 'percent' },
      { label: '持续回合', base: 3, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['治疗', '御兽'],
    maxLevel: 35
  },
  {
    id: 'beast_thunder_command',
    name: '雷驭号令',
    quality: 'kaipi',
    type: 'passive',
    discipline: 'beast',
    element: 'lightning',
    description: '雷霆号令推动主角技的节奏。',
    mechanics: ['灵兽释放技能后使主人下次主动技能冷却 -1，冷却 3 回合。'],
    growth: ['每级额外缩短 0.1 回合，向下取整至最多 -2。'],
    progression: [
      { label: '触发冷却缩减', base: -1, perLevel: -0.1, format: 'integer', suffix: '回合', digits: 1 },
      { label: '触发间隔', base: 3, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['冷却缩减', '御兽'],
    maxLevel: 35
  },
  {
    id: 'sigil_rupture_chain',
    name: '断厄符索',
    quality: 'kaipi',
    type: 'active',
    discipline: 'sigil',
    element: 'poison',
    description: '符索缠绕经脉，阻断妖气流动。',
    params: { cooldown: 4, cost: 24, range: '单体' },
    mechanics: ['造成 120% 法攻并降低 20% 妖气回复，持续 3 回合。'],
    growth: ['每级伤害 +2%，回复降低 +1%。'],
    progression: [
      { label: '命中倍率', base: 1.2, perLevel: 0.02, format: 'percent' },
      { label: '妖气回复压制', base: -0.2, perLevel: -0.01, format: 'percent' },
      { label: '持续回合', base: 3, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['资源压制', '毒系'],
    maxLevel: 35
  },
  {
    id: 'sigil_purified_mind',
    name: '清魂定印',
    quality: 'kaipi',
    type: 'passive',
    discipline: 'sigil',
    element: 'water',
    description: '心神澄净，减缓负面影响。',
    mechanics: ['若自身未受控，回合结束回复 3% 真气并清除 1 层减益，冷却 2 回合。'],
    growth: ['每级真气恢复 +0.2%。'],
    progression: [
      { label: '回合回复', base: 0.03, perLevel: 0.002, format: 'percent', suffix: '/回合' },
      { label: '冷却时间', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['回气', '净化'],
    maxLevel: 35
  },
  {
    id: 'sword_thunder_break',
    name: '雷霆断界',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'sword',
    element: 'lightning',
    description: '剑势化雷，兼具伤害与眩晕。',
    params: { cooldown: 4, cost: 36, range: '单体' },
    mechanics: ['消耗 2 层剑意连击 3 次（每次 60% 攻击），并有 50% 几率眩晕 1 回合。'],
    growth: ['每级每段 +4%，眩晕概率 +2%。'],
    progression: [
      { label: '单段倍率', base: 0.6, perLevel: 0.04, format: 'percent' },
      { label: '眩晕命中率', base: 0.5, perLevel: 0.02, format: 'percent' },
      { label: '段数', base: 3, perLevel: 0, format: 'integer', suffix: '段', digits: 0 }
    ],
    tags: ['连击', '眩晕'],
    maxLevel: 50
  },
  {
    id: 'sword_blazing_brand',
    name: '焚霞御剑',
    quality: 'tongxuan',
    type: 'passive',
    discipline: 'sword',
    element: 'fire',
    description: '暴击附加剑炎标记，造成追加火伤。',
    mechanics: ['暴击时附加剑炎，下一次受击额外承受 70% 攻击火伤，冷却 2 回合。'],
    growth: ['每级附加伤害 +4%。'],
    progression: [
      { label: '剑炎爆发', base: 0.7, perLevel: 0.04, format: 'percent' },
      { label: '触发冷却', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['燃烧', '爆发'],
    maxLevel: 50
  },
  {
    id: 'spell_frost_prison',
    name: '霜渊天缚',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'spell',
    element: 'water',
    description: '冰棱阵冻结战场，解除时造成额外破冰伤。',
    params: { cooldown: 5, cost: 40, range: '大范围' },
    mechanics: ['造成 170% 法攻并冻结 2 回合（基础 60% 命中），破冰额外造成 40% 法攻。'],
    growth: ['每级伤害 +4%，冻结命中 +2%。'],
    progression: [
      { label: '命中倍率', base: 1.7, perLevel: 0.04, format: 'percent' },
      { label: '冻结命中率', base: 0.6, perLevel: 0.02, format: 'percent' },
      { label: '破冰伤害', base: 0.4, perLevel: 0.02, format: 'percent' }
    ],
    tags: ['冻结', '控场'],
    maxLevel: 50
  },
  {
    id: 'spell_scorching_void',
    name: '灼阳星墟',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'spell',
    element: 'fire',
    description: '引燃星火坠落，叠加自身火势层数。',
    params: { cooldown: 4, cost: 38, range: '小范围' },
    mechanics: ['造成 180% 法攻并附加 12% 易伤 3 回合，自身获得 1 层火势（法攻 +5%）。'],
    growth: ['每级伤害 +4%，易伤 +1%，火势最多 3 层。'],
    progression: [
      { label: '命中倍率', base: 1.8, perLevel: 0.04, format: 'percent' },
      { label: '易伤幅度', base: 0.12, perLevel: 0.01, format: 'percent' },
      { label: '火势每层加成', base: 0.05, perLevel: 0.005, format: 'percent' }
    ],
    tags: ['爆发', '火势'],
    maxLevel: 50
  },
  {
    id: 'body_stone_bulwark',
    name: '玄石擎壁',
    quality: 'tongxuan',
    type: 'passive',
    discipline: 'body',
    element: 'earth',
    description: '生命危急时形成玄石护壁并反射伤害。',
    mechanics: ['生命低于 50% 生成护盾吸收 30% 生命并反射 15% 土伤，持续 2 回合。'],
    growth: ['每级护盾 +2%，反射 +1%。'],
    progression: [
      { label: '护盾吸收', base: 0.3, perLevel: 0.02, format: 'percent' },
      { label: '反射伤害', base: 0.15, perLevel: 0.01, format: 'percent' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['护盾', '反击'],
    maxLevel: 50
  },
  {
    id: 'body_flame_shroud',
    name: '炎魂蔽天',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'body',
    element: 'fire',
    description: '炎魂护体，兼顾减伤与反击。',
    params: { cooldown: 5, cost: 40, range: '自身' },
    mechanics: ['开启 2 回合炎魂：减伤 25%，对近战者造成每回合 60% 火反击并回复 5% 生命。'],
    growth: ['每级减伤 +1%，反击 +3%，回复 +0.5%。'],
    progression: [
      { label: '减伤幅度', base: 0.25, perLevel: 0.01, format: 'percent' },
      { label: '反击伤害', base: 0.6, perLevel: 0.03, format: 'percent', suffix: '/回合' },
      { label: '回合回复', base: 0.05, perLevel: 0.005, format: 'percent', suffix: '/回合' }
    ],
    tags: ['反击', '持续'],
    maxLevel: 50
  },
  {
    id: 'beast_shared_vein',
    name: '同脉灵契',
    quality: 'tongxuan',
    type: 'passive',
    discipline: 'beast',
    element: 'wood',
    description: '人宠同脉，分享增益与真气。',
    mechanics: ['灵兽命中后给主人与灵兽各回复 4% 真气并延长共享增益 1 回合，冷却 3 回合。'],
    growth: ['每级回复 +0.3%，延长最多 3 回合。'],
    progression: [
      { label: '触发回气', base: 0.04, perLevel: 0.003, format: 'percent' },
      { label: '增益延长', base: 1, perLevel: 0.2, format: 'integer', suffix: '回合', digits: 1 },
      { label: '触发冷却', base: 3, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['回气', '增益延长'],
    maxLevel: 50
  },
  {
    id: 'beast_electric_assault',
    name: '电翎急袭',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'beast',
    element: 'lightning',
    description: '命令灵兽穿梭战场，打出额外雷击。',
    params: { cooldown: 4, cost: 34, range: '单体连锁' },
    mechanics: ['灵兽立即行动造成两段 75% 雷击，若目标被眩晕则连锁至另一名敌人。'],
    growth: ['每级伤害 +3%，连锁伤害完全继承。'],
    progression: [
      { label: '单段倍率', base: 0.75, perLevel: 0.03, format: 'percent' },
      { label: '段数', base: 2, perLevel: 0, format: 'integer', suffix: '段', digits: 0 },
      { label: '连锁目标', base: 2, perLevel: 0, format: 'integer', suffix: '人', digits: 0 }
    ],
    tags: ['连携', '雷系'],
    maxLevel: 50
  },
  {
    id: 'sigil_nine_palace',
    name: '九宫封煞',
    quality: 'tongxuan',
    type: 'active',
    discipline: 'sigil',
    element: 'earth',
    description: '布置九宫结界限制敌军移动与防御。',
    params: { cooldown: 5, cost: 42, range: '范围' },
    mechanics: ['范围内敌人减速 40%、防御 -15%，持续 2 回合；首个击败目标被禁锢。'],
    growth: ['每级减速 +1%，防御降低 +0.5%。'],
    progression: [
      { label: '范围减速', base: -0.4, perLevel: -0.01, format: 'percent' },
      { label: '防御削减', base: -0.15, perLevel: -0.005, format: 'percent' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['减速', '禁锢'],
    maxLevel: 50
  },
  {
    id: 'sigil_heart_rot',
    name: '灭脉蚀心',
    quality: 'tongxuan',
    type: 'passive',
    discipline: 'sigil',
    element: 'poison',
    description: '对中毒者施加蚀心印记，压制其治疗。',
    mechanics: ['攻击中毒目标时附加“蚀心”：受治疗 -20%，持续 2 回合，冷却 2 回合。'],
    growth: ['每级治疗压制 +1%。'],
    progression: [
      { label: '治疗压制', base: -0.2, perLevel: -0.01, format: 'percent' },
      { label: '持续回合', base: 2, perLevel: 0, format: 'integer', suffix: '回合', digits: 0 }
    ],
    tags: ['治疗压制', '毒系'],
    maxLevel: 50
  }
];

const SKILL_MAP = buildMap(SKILL_LIBRARY);

function buildMap(list) {
  const map = {};
  list.forEach((item) => {
    map[item.id] = item;
  });
  return map;
}

function resolveSkillLevelValue(level, fallback = 1) {
  if (Number.isFinite(level)) {
    return Math.max(1, Math.floor(level));
  }
  const parsed = Number(level);
  if (Number.isFinite(parsed)) {
    return Math.max(1, Math.floor(parsed));
  }
  if (typeof level === 'string') {
    const match = level.match(/(\d+)/);
    if (match) {
      const extracted = Number(match[1]);
      if (Number.isFinite(extracted)) {
        return Math.max(1, Math.floor(extracted));
      }
    }
  }
  const fallbackNumber = Number(fallback);
  if (Number.isFinite(fallbackNumber)) {
    return Math.max(1, Math.floor(fallbackNumber));
  }
  return 1;
}

function resolveSkillProgressionDetails(definition, level = 1) {
  if (!definition || typeof definition !== 'object') {
    return [];
  }
  const entries = Array.isArray(definition.progression) ? definition.progression : [];
  if (!entries.length) {
    return [];
  }
  const currentLevel = resolveSkillLevelValue(level);
  const skillId = definition.id || definition.skillId || '';
  const defaultMaxLevel = resolveSkillLevelValue(
    resolveSkillMaxLevel(skillId) || definition.maxLevel || currentLevel,
    currentLevel
  );
  return entries
    .map((entry, index) => {
      if (!entry || typeof entry !== 'object' || !entry.label) {
        return null;
      }
      const format = entry.format || 'percent';
      const suffix = resolveProgressionSuffix(entry, format);
      const base = Number(entry.base) || 0;
      const perLevel = Number(entry.perLevel) || 0;
      const entryMaxLevel =
        entry.maxLevel != null ? resolveSkillLevelValue(entry.maxLevel, currentLevel) : defaultMaxLevel;
      const resolvedMax = Math.max(currentLevel, entryMaxLevel);
      const extraLevels = Math.max(0, currentLevel - 1);
      const currentValue = base + perLevel * extraLevels;
      const maxValue = base + perLevel * Math.max(0, resolvedMax - 1);
      const formattedCurrent = formatProgressionNumber(currentValue, format, entry);
      const formattedPerLevel =
        perLevel !== 0 ? formatProgressionNumber(Math.abs(perLevel), format, entry) : null;
      const maxDifferent = Math.abs(maxValue - currentValue) > 1e-6;
      const formattedMax = maxDifferent ? formatProgressionNumber(maxValue, format, entry) : null;
      let text = `${entry.label}：${formattedCurrent}${suffix}`;
      if (perLevel !== 0) {
        const sign = perLevel > 0 ? '+' : '-';
        text += `（每级${sign}${formattedPerLevel}${suffix}`;
        if (formattedMax) {
          text += `，满级${formattedMax}${suffix}`;
        }
        text += '）';
      } else if (formattedMax) {
        text += `（满级${formattedMax}${suffix}）`;
      }
      if (entry.note) {
        text += `，${entry.note}`;
      }
      const config = resolveEffectLabelConfig(entry.label, skillId);
      const magnitudeBase = normalizeMechanicNumber(
        formatProgressionNumber(Math.abs(base), format, entry)
      );
      const magnitudeCurrent = normalizeMechanicNumber(
        formatProgressionNumber(Math.abs(currentValue), format, entry)
      );
      const displayValue = resolveEffectDisplayValue(config, currentValue);
      const formattedDisplay = formatProgressionNumber(displayValue, format, entry);
      const valueSuffix = resolveEffectSuffix(config, suffix);
      const valueText = `${resolveEffectValuePrefix(config)}${formattedDisplay}${valueSuffix}${resolveEffectValueSuffix(config)}`;
      const highlight = formatEffectHighlight(config, entry.label, valueText, formattedDisplay, valueSuffix);
      return {
        label: entry.label,
        format,
        suffix,
        baseValue: base,
        perLevel,
        currentValue,
        maxValue,
        text,
        magnitudeBase,
        magnitudeCurrent,
        displayValue,
        formattedDisplay,
        valueText,
        highlight,
        effectType: config.type || SKILL_EFFECT_TYPES.generic.key,
        groupKey: resolveEffectGroupKey(config, skillId, entry.label),
        connector: resolveEffectConnector(config, skillId),
        groupPrefix: resolveEffectGroupPrefix(config, skillId),
        groupSuffix: resolveEffectGroupSuffix(config, skillId),
        order: index
      };
    })
    .filter(Boolean);
}

function composeSkillEffectHighlights(details) {
  if (!Array.isArray(details) || !details.length) {
    return [];
  }
  const groups = [];
  details.forEach((detail) => {
    const key = detail.groupKey || detail.label;
    let group = groups.find((item) => item.key === key);
    if (!group) {
      group = {
        key,
        prefix: detail.groupPrefix || '',
        suffix: detail.groupSuffix || '',
        entries: []
      };
      groups.push(group);
    } else {
      if (!group.prefix && detail.groupPrefix) {
        group.prefix = detail.groupPrefix;
      }
      if (!group.suffix && detail.groupSuffix) {
        group.suffix = detail.groupSuffix;
      }
    }
    group.entries.push(detail);
  });
  return groups.map((group) => {
    const sorted = group.entries.slice().sort((a, b) => a.order - b.order);
    let text = group.prefix || '';
    sorted.forEach((detail, index) => {
      const connector = index === 0 ? '' : detail.connector != null ? detail.connector : '，';
      text += `${connector}${detail.highlight}`;
    });
    if (group.suffix) {
      text += group.suffix;
    }
    return text;
  });
}

function formatSkillMechanics(definition, level = 1, progressionDetails = null) {
  if (!definition || typeof definition !== 'object') {
    return [];
  }
  const mechanics = Array.isArray(definition.mechanics) ? definition.mechanics.slice() : [];
  if (!mechanics.length) {
    return [];
  }
  const normalizedLevel = resolveSkillLevelValue(level);
  const progression =
    Array.isArray(progressionDetails) && progressionDetails.length
      ? progressionDetails
      : resolveSkillProgressionDetails(definition, normalizedLevel);
  if (!progression.length) {
    return mechanics;
  }
  return mechanics.map((text) => {
    if (typeof text !== 'string') {
      return text;
    }
    let updated = text;
    progression.forEach((item) => {
      const baseMagnitude = item.magnitudeBase;
      const replacementMagnitude = item.magnitudeCurrent;
      if (!baseMagnitude || (!replacementMagnitude && replacementMagnitude !== '0')) {
        return;
      }
      updated = updated.replace(/-?\d+(?:\.\d+)?/g, (token, offset, string) => {
        if (!token) {
          return token;
        }
        const sign = token.startsWith('-') ? '-' : '';
        const magnitude = sign ? token.slice(1) : token;
        if (!magnitude) {
          return token;
        }
        const normalizedMagnitude = normalizeMechanicNumber(magnitude);
        if (normalizedMagnitude !== baseMagnitude) {
          return token;
        }
        if (!matchesMechanicContext(item.format, string, offset, token.length)) {
          return token;
        }
        if (sign) {
          return `${sign}${replacementMagnitude}`;
        }
        return replacementMagnitude;
      });
    });
    return updated;
  });
}

function resolveEffectLabelConfig(label, skillId) {
  const base = SKILL_EFFECT_LABEL_CONFIG[label] || {};
  const groups = base.groups || {};
  const override =
    (skillId && groups && groups[skillId]) || groups.default || null;
  return {
    label: override && override.label ? override.label : base.label || label,
    type: override && override.type ? override.type : base.type,
    template: override && override.template ? override.template : base.template,
    transform: override && override.transform ? override.transform : base.transform,
    suffix: override && override.suffix != null ? override.suffix : base.suffix,
    valuePrefix:
      override && override.valuePrefix != null ? override.valuePrefix : base.valuePrefix || '',
    valueSuffix:
      override && override.valueSuffix != null ? override.valueSuffix : base.valueSuffix || '',
    connector: override && override.connector != null ? override.connector : base.connector,
    group: override && override.group != null ? override.group : base.group,
    groupKey: override && override.groupKey != null ? override.groupKey : base.groupKey,
    groupPrefix:
      override && override.groupPrefix != null ? override.groupPrefix : base.groupPrefix || '',
    groupSuffix:
      override && override.groupSuffix != null ? override.groupSuffix : base.groupSuffix || '',
    append: override && override.append != null ? override.append : base.append || '',
    prefix: override && override.prefix != null ? override.prefix : base.prefix || '',
    omitSuffix: override && override.omitSuffix != null ? override.omitSuffix : base.omitSuffix
  };
}

function resolveEffectDisplayValue(config, value) {
  if (!config || !config.transform) {
    return value;
  }
  if (config.transform === 'abs') {
    return Math.abs(value);
  }
  if (config.transform === 'negate') {
    return -value;
  }
  return value;
}

function resolveEffectSuffix(config, fallback) {
  if (!config) {
    return fallback;
  }
  if (config.suffix != null) {
    return config.suffix;
  }
  if (config.omitSuffix) {
    return '';
  }
  return fallback;
}

function resolveEffectValuePrefix(config) {
  return (config && config.valuePrefix) || '';
}

function resolveEffectValueSuffix(config) {
  return (config && config.valueSuffix) || '';
}

function formatEffectHighlight(config, label, valueText, rawValueText, suffix) {
  const template = (config && config.template) || '{{label}} {{value}}';
  const resolvedLabel = (config && config.label) || label;
  let text = template
    .replace(/\{\{\s*label\s*\}\}/g, resolvedLabel)
    .replace(/\{\{\s*value\s*\}\}/g, valueText)
    .replace(/\{\{\s*rawValue\s*\}\}/g, rawValueText)
    .replace(/\{\{\s*suffix\s*\}\}/g, suffix || '');
  if (config && config.prefix) {
    text = `${config.prefix}${text}`;
  }
  if (config && config.append) {
    text += config.append;
  }
  return text;
}

function resolveEffectGroupKey(config, skillId, label) {
  if (config && config.groupKey) {
    return config.groupKey;
  }
  if (config && config.group) {
    return config.group;
  }
  return `${skillId || 'skill'}:${label}`;
}

function resolveEffectConnector(config, skillId) {
  if (config && config.connector != null) {
    return config.connector;
  }
  return null;
}

function resolveEffectGroupPrefix(config, skillId) {
  if (config && config.groupPrefix) {
    return config.groupPrefix;
  }
  return '';
}

function resolveEffectGroupSuffix(config, skillId) {
  if (config && config.groupSuffix) {
    return config.groupSuffix;
  }
  return '';
}

function resolveProgressionSuffix(entry, format) {
  if (entry && typeof entry.suffix === 'string') {
    if (format === 'percent' || format === 'perTurnPercent') {
      return `%${entry.suffix}`;
    }
    return entry.suffix;
  }
  switch (format) {
    case 'percent':
      return '%';
    case 'perTurnPercent':
      return '%/回合';
    case 'integer':
      return '';
    default:
      return '';
  }
}

function formatProgressionNumber(value, format, entry = {}) {
  if (!Number.isFinite(value)) {
    return '0';
  }
  let scaled = value;
  switch (format) {
    case 'percent':
    case 'perTurnPercent':
      scaled = value * 100;
      break;
    case 'integer':
      break;
    default:
      break;
  }
  const digits =
    entry.digits != null ? Math.max(0, Math.floor(entry.digits)) : resolveDefaultDigits(format, scaled);
  if (digits === 0) {
    return `${Math.round(scaled)}`;
  }
  const fixed = scaled.toFixed(digits);
  return fixed.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
}

function resolveDefaultDigits(format, scaled) {
  if (format === 'percent' || format === 'perTurnPercent') {
    return Math.abs(scaled) >= 100 ? 0 : 1;
  }
  if (format === 'integer') {
    return 0;
  }
  return Math.abs(scaled) >= 100 ? 0 : 2;
}

function normalizeMechanicNumber(token) {
  if (token == null) {
    return '';
  }
  let normalized = `${token}`.trim();
  if (!normalized) {
    return '';
  }
  if (/^0+\.0+$/.test(normalized)) {
    return '0';
  }
  if (normalized.includes('.')) {
    normalized = normalized.replace(/0+$/, '');
    if (normalized.endsWith('.')) {
      normalized = normalized.slice(0, -1);
    }
  }
  if (normalized.startsWith('0') && normalized[1] !== '.' && normalized.length > 1) {
    normalized = normalized.replace(/^0+(?=\d)/, '');
  }
  return normalized || '0';
}

function matchesMechanicContext(format, text, offset, length) {
  if (!format) {
    return true;
  }
  const nextPortion = text.slice(offset + length, offset + length + 3);
  const trimmedNext = nextPortion.replace(/^\s+/, '');
  const percentMarkers = ['%', '％'];
  if (format === 'percent' || format === 'perTurnPercent') {
    return percentMarkers.some((marker) => trimmedNext.startsWith(marker));
  }
  if (percentMarkers.some((marker) => trimmedNext.startsWith(marker))) {
    return false;
  }
  return true;
}

function createBonusSummary() {
  const base = {};
  BASE_ATTRIBUTE_KEYS.forEach((key) => {
    base[key] = 0;
  });
  const combatAdditive = {};
  const combatMultipliers = {};
  COMBAT_STAT_KEYS.forEach((key) => {
    combatAdditive[key] = 0;
    combatMultipliers[key] = 1;
  });
  const special = {};
  SPECIAL_STAT_KEYS.forEach((key) => {
    special[key] = 0;
  });
  return {
    base,
    combatAdditive,
    combatMultipliers,
    special,
    sets: [],
    notes: []
  };
}

function applyBonus(summary, key, value) {
  if (!summary || value == null || value === 0) {
    return;
  }
  if (BASE_ATTRIBUTE_KEYS.includes(key)) {
    summary.base[key] = (summary.base[key] || 0) + value;
    return;
  }
  if (key.endsWith('Multiplier')) {
    const target = key.replace('Multiplier', '');
    if (COMBAT_STAT_KEYS.includes(target)) {
      summary.combatMultipliers[target] = (summary.combatMultipliers[target] || 1) * (1 + value);
    }
    return;
  }
  if (COMBAT_STAT_KEYS.includes(key)) {
    summary.combatAdditive[key] = (summary.combatAdditive[key] || 0) + value;
    return;
  }
  if (SPECIAL_STAT_KEYS.includes(key)) {
    summary.special[key] = (summary.special[key] || 0) + value;
    return;
  }
  summary.special[key] = (summary.special[key] || 0) + value;
}

function mergeBonusSummary(target, source) {
  if (!source) {
    return target;
  }
  BASE_ATTRIBUTE_KEYS.forEach((key) => {
    target.base[key] = (target.base[key] || 0) + (source.base[key] || 0);
  });
  COMBAT_STAT_KEYS.forEach((key) => {
    target.combatAdditive[key] = (target.combatAdditive[key] || 0) + (source.combatAdditive[key] || 0);
    target.combatMultipliers[key] = (target.combatMultipliers[key] || 1) * (source.combatMultipliers[key] || 1);
  });
  SPECIAL_STAT_KEYS.forEach((key) => {
    target.special[key] = (target.special[key] || 0) + (source.special[key] || 0);
  });
  Object.keys(source.special || {}).forEach((key) => {
    if (!SPECIAL_STAT_KEYS.includes(key)) {
      target.special[key] = (target.special[key] || 0) + (source.special[key] || 0);
    }
  });
  if (Array.isArray(source.notes) && source.notes.length) {
    target.notes.push(...source.notes);
  }
  if (Array.isArray(source.sets) && source.sets.length) {
    target.sets.push(...source.sets);
  }
  return target;
}

function flattenBonusSummary(summary) {
  const result = {};
  BASE_ATTRIBUTE_KEYS.forEach((key) => {
    if (summary.base[key]) {
      result[key] = summary.base[key];
    }
  });
  COMBAT_STAT_KEYS.forEach((key) => {
    if (summary.combatAdditive[key]) {
      result[key] = (result[key] || 0) + summary.combatAdditive[key];
    }
    if (summary.combatMultipliers[key] && summary.combatMultipliers[key] !== 1) {
      result[`${key}Multiplier`] = (summary.combatMultipliers[key] || 1) - 1;
    }
  });
  Object.keys(summary.special || {}).forEach((key) => {
    if (summary.special[key]) {
      result[key] = (result[key] || 0) + summary.special[key];
    }
  });
  return result;
}

function aggregateSkillEffects(skills) {
  const summary = createBonusSummary();
  if (!skills || typeof skills !== 'object') {
    return summary;
  }

  const inventory = Array.isArray(skills.inventory) ? skills.inventory : [];
  const equipped = Array.isArray(skills.equipped) ? skills.equipped : [];
  const inventoryMap = inventory.reduce((map, entry) => {
    map[entry.skillId] = entry;
    return map;
  }, {});

  equipped.forEach((skillId) => {
    if (!skillId) return;
    const entry = inventoryMap[skillId] || { skillId, level: 1 };
    const definition = SKILL_MAP[skillId];
    if (!definition) return;
    const effects = resolveSkillEffects(definition, entry.level || 1);
    mergeBonusSummary(summary, effects);
  });

  return summary;
}

function resolveSkillEffects(definition, level = 1) {
  const summary = createBonusSummary();
  if (!definition) {
    return summary;
  }
  const quality = definition.quality || 'linggan';
  const qualityConfig = SKILL_QUALITY_CONFIG[quality];
  const defaultMaxLevel = (qualityConfig && qualityConfig.maxLevel) || 5;
  const maxLevel = definition.maxLevel || defaultMaxLevel;
  const clampedLevel = Math.min(maxLevel, Math.max(1, level));
  const extraLevel = clampedLevel - 1;

  if (definition.modifiers && typeof definition.modifiers === 'object') {
    applyModifierGroup(summary, definition.modifiers.base, 1);
    applyModifierGroup(summary, definition.modifiers.perLevel, extraLevel);
    applyModifierGroup(summary, definition.modifiers.multipliers, 1);
    applyModifierGroup(summary, definition.modifiers.multipliersPerLevel, extraLevel);
    applyModifierGroup(summary, definition.modifiers.special, 1);
    applyModifierGroup(summary, definition.modifiers.specialPerLevel, extraLevel);
    if (Array.isArray(definition.modifiers.notes)) {
      summary.notes.push(...definition.modifiers.notes);
    }
    return summary;
  }

  const effects = definition.effects || {};
  const scaling = definition.levelScaling || {};

  Object.keys(effects).forEach((key) => {
    const baseValue = effects[key] || 0;
    const scaleValue = scaling[key] || 0;
    const total = baseValue + scaleValue * extraLevel;
    applyBonus(summary, key, total);
  });

  Object.keys(scaling).forEach((key) => {
    if (effects[key]) {
      return;
    }
    const extra = (scaling[key] || 0) * extraLevel;
    applyBonus(summary, key, extra);
  });

  return summary;
}

function applyModifierGroup(summary, group, scale = 1) {
  if (!group || typeof group !== 'object') {
    return;
  }
  Object.keys(group).forEach((key) => {
    const value = group[key];
    if (typeof value === 'number') {
      applyBonus(summary, key, value * scale);
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      applyModifierGroup(summary, value, scale);
    }
  });
}

function resolveSkillQualityColor(quality) {
  const config = SKILL_QUALITY_CONFIG[quality];
  return (config && config.color) || '#9aa4b5';
}

function resolveSkillQualityLabel(quality) {
  const config = SKILL_QUALITY_CONFIG[quality];
  return (config && config.label) || '灵感';
}

function resolveSkillTypeLabel(type) {
  const config = SKILL_TYPES[type];
  return (config && config.label) || '技能';
}

function resolveSkillDisciplineLabel(key) {
  const config = SKILL_DISCIPLINES[key];
  return (config && config.label) || '通用';
}

function resolveSkillElementLabel(element) {
  const config = ELEMENT_CONFIG[element];
  return (config && config.label) || '无属性';
}

function resolveSkillMaxLevel(skillId) {
  const definition = SKILL_MAP[skillId];
  if (!definition) {
    return 5;
  }
  const qualityConfig = SKILL_QUALITY_CONFIG[definition.quality];
  const fallback = (qualityConfig && qualityConfig.maxLevel) || 5;
  return definition.maxLevel || fallback;
}


module.exports = {
  BASE_ATTRIBUTE_KEYS,
  COMBAT_STAT_KEYS,
  SKILL_EFFECT_TYPES,
  SKILL_TYPES,
  SKILL_DISCIPLINES,
  ELEMENT_CONFIG,
  SKILL_QUALITY_CONFIG,
  SKILL_LIBRARY,
  SKILL_MAP,
  createBonusSummary,
  applyBonus,
  mergeBonusSummary,
  flattenBonusSummary,
  aggregateSkillEffects,
  resolveSkillEffects,
  resolveSkillLevelValue,
  resolveSkillProgressionDetails,
  composeSkillEffectHighlights,
  formatSkillMechanics,
  resolveSkillQualityColor,
  resolveSkillQualityLabel,
  resolveSkillTypeLabel,
  resolveSkillDisciplineLabel,
  resolveSkillElementLabel,
  resolveSkillMaxLevel
};
