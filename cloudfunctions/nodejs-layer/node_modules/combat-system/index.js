'use strict';

const { getLevelCurveConfig } = require('../../balance/config-loader');

const DEFAULT_COMBAT_STATS_FALLBACK = {
  maxHp: 2860,
  physicalAttack: 82,
  magicAttack: 82,
  physicalDefense: 61,
  magicDefense: 61,
  speed: 92,
  accuracy: 112,
  dodge: 96,
  critRate: 0.062,
  critDamage: 1.52,
  finalDamageBonus: 0,
  finalDamageReduction: 0.024,
  lifeSteal: 0,
  healingBonus: 0.08,
  healingReduction: 0,
  controlHit: 11,
  controlResist: 11,
  physicalPenetration: 1,
  magicPenetration: 1,
  critResist: 0.0184,
  comboRate: 0,
  block: 0,
  counterRate: 0,
  damageReduction: 0,
  healingReceived: 0,
  rageGain: 0,
  controlStrength: 0,
  shieldPower: 0,
  summonPower: 0,
  elementalVulnerability: 0
};

const DEFAULT_SPECIAL_STATS_FALLBACK = {
  shield: 0,
  bonusDamage: 0,
  dodgeChance: 0,
  healOnHit: 0,
  healOnKill: 0,
  damageReflection: 0,
  accuracyBonus: 0,
  speedBonus: 0,
  physicalPenetrationBonus: 0,
  magicPenetrationBonus: 0
};

function getLevelCurves() {
  return getLevelCurveConfig() || {};
}

function getDefaultCombatStats() {
  const curves = getLevelCurves();
  return (curves.defaults && curves.defaults.combatStats) || DEFAULT_COMBAT_STATS_FALLBACK;
}

function getDefaultSpecialStats() {
  const curves = getLevelCurves();
  return (curves.defaults && curves.defaults.specialStats) || DEFAULT_SPECIAL_STATS_FALLBACK;
}

const DEFAULT_COMBAT_STATS = getDefaultCombatStats();
const DEFAULT_SPECIAL_STATS = getDefaultSpecialStats();

const STAT_ALIASES = {
  hp: 'maxHp',
  health: 'maxHp',
  maxHP: 'maxHp',
  attack: 'physicalAttack',
  physicalAtk: 'physicalAttack',
  physicalATK: 'physicalAttack',
  weaponAttack: 'physicalAttack',
  spellAttack: 'magicAttack',
  magicAtk: 'magicAttack',
  magicATK: 'magicAttack',
  defense: 'physicalDefense',
  armor: 'physicalDefense',
  resistance: 'magicDefense',
  magicResist: 'magicDefense',
  hitRate: 'accuracy',
  accuracyRate: 'accuracy',
  evasion: 'dodge',
  dodgeRate: 'dodge',
  criticalRate: 'critRate',
  critical: 'critRate',
  crit: 'critRate',
  criticalDamage: 'critDamage',
  critDamageRate: 'critDamage',
  finalDamage: 'finalDamageBonus',
  finalReduce: 'finalDamageReduction',
  damageReduce: 'finalDamageReduction',
  armorPenetration: 'physicalPenetration',
  armorPen: 'physicalPenetration',
  spellPenetration: 'magicPenetration',
  spellPen: 'magicPenetration',
  magicPen: 'magicPenetration'
};

const LEGACY_PERCENT_KEYS = new Set([
  'critRate',
  'finalDamageBonus',
  'finalDamageReduction',
  'lifeSteal',
  'healingBonus',
  'healingReduction',
  'controlHit',
  'controlResist',
  'critResist',
  'comboRate',
  'block',
  'counterRate',
  'damageReduction',
  'healingReceived',
  'rageGain',
  'controlStrength',
  'shieldPower',
  'summonPower',
  'elementalVulnerability'
]);

const SPECIAL_PERCENT_KEYS = new Set(['dodgeChance', 'damageReflection']);

function getStatBoundaries() {
  const curves = getLevelCurves();
  const healing = curves.healing || {};
  const finalDamage = curves.finalDamage || {};
  const mitigation = curves.mitigation || {};
  const procCaps = curves.procCaps || {};
  const specialCaps = curves.specialCaps || {};
  const statFloors = curves.statFloors || {};
  const crit = curves.crit || {};
  return {
    critRateMin: crit.min !== undefined ? crit.min : 0,
    critRateMax: crit.max !== undefined ? crit.max : 0.95,
    critDamageMin: statFloors.critDamageMin !== undefined ? statFloors.critDamageMin : 1.2,
    finalDamageBonusMin:
      finalDamage.bonusClamp && finalDamage.bonusClamp.min !== undefined
        ? finalDamage.bonusClamp.min
        : -0.9,
    finalDamageBonusMax:
      finalDamage.bonusClamp && finalDamage.bonusClamp.max !== undefined
        ? finalDamage.bonusClamp.max
        : 2,
    finalDamageReductionMin:
      finalDamage.reductionClamp && finalDamage.reductionClamp.min !== undefined
        ? finalDamage.reductionClamp.min
        : 0,
    finalDamageReductionMax:
      finalDamage.reductionClamp && finalDamage.reductionClamp.max !== undefined
        ? finalDamage.reductionClamp.max
        : 0.9,
    lifeStealMax: healing.lifeStealMax !== undefined ? healing.lifeStealMax : 0.6,
    healingBonusMin:
      healing.healingBonusClamp && healing.healingBonusClamp.min !== undefined
        ? healing.healingBonusClamp.min
        : -1,
    healingBonusMax:
      healing.healingBonusClamp && healing.healingBonusClamp.max !== undefined
        ? healing.healingBonusClamp.max
        : 1.5,
    healingReductionMin:
      healing.healingReductionClamp && healing.healingReductionClamp.min !== undefined
        ? healing.healingReductionClamp.min
        : -1,
    healingReductionMax:
      healing.healingReductionClamp && healing.healingReductionClamp.max !== undefined
        ? healing.healingReductionClamp.max
        : 1.5,
    healingReceivedMin:
      healing.healingReceivedClamp && healing.healingReceivedClamp.min !== undefined
        ? healing.healingReceivedClamp.min
        : -0.5,
    healingReceivedMax:
      healing.healingReceivedClamp && healing.healingReceivedClamp.max !== undefined
        ? healing.healingReceivedClamp.max
        : 1.5,
    damageReductionMax:
      mitigation.damageReductionMax !== undefined ? mitigation.damageReductionMax : 0.8,
    comboRateMax: procCaps.comboRateMax !== undefined ? procCaps.comboRateMax : 1,
    blockMax: procCaps.blockMax !== undefined ? procCaps.blockMax : 1,
    counterRateMax: procCaps.counterRateMax !== undefined ? procCaps.counterRateMax : 1,
    dodgeChanceMax:
      specialCaps.dodgeChanceMax !== undefined ? specialCaps.dodgeChanceMax : 0.8,
    damageReflectionMax:
      specialCaps.damageReflectionMax !== undefined ? specialCaps.damageReflectionMax : 0.8
  };
}

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function toNumber(value) {
  const number = Number(value);
  return Number.isFinite(number) ? number : 0;
}

function normalizeStatValue(key, value, convertLegacyPercentages) {
  let normalized = value;
  const limits = getStatBoundaries();
  if (convertLegacyPercentages) {
    if (key === 'critRate') {
      normalized = value > 1 ? value / 100 : value;
    } else if (key === 'critDamage') {
      normalized = value >= 3 ? 1.5 + value / 100 : value;
    } else if (LEGACY_PERCENT_KEYS.has(key) && Math.abs(value) > 1 && Math.abs(value) <= 1000) {
      normalized = value / 100;
    }
  }
  switch (key) {
    case 'critRate':
      return clamp(normalized, limits.critRateMin, limits.critRateMax);
    case 'critDamage':
      return Math.max(limits.critDamageMin, normalized);
    case 'finalDamageBonus':
      return clamp(normalized, limits.finalDamageBonusMin, limits.finalDamageBonusMax);
    case 'finalDamageReduction':
      return clamp(normalized, limits.finalDamageReductionMin, limits.finalDamageReductionMax);
    case 'lifeSteal':
      return clamp(normalized, 0, limits.lifeStealMax);
    case 'healingBonus':
    case 'healingReduction':
      return clamp(normalized, limits.healingBonusMin, limits.healingBonusMax);
    case 'damageReduction':
      return clamp(normalized, 0, limits.damageReductionMax);
    case 'healingReceived':
      return clamp(normalized, limits.healingReceivedMin, limits.healingReceivedMax);
    case 'comboRate':
    case 'block':
    case 'counterRate':
      return clamp(normalized, 0, limits[key + 'Max'] || 1);
    case 'critResist':
    case 'controlHit':
    case 'controlResist':
    case 'rageGain':
    case 'controlStrength':
    case 'shieldPower':
    case 'summonPower':
    case 'elementalVulnerability':
      return normalized;
    default:
      return normalized;
  }
}

function applyStatSource(target, source, convertLegacyPercentages) {
  if (!source || typeof source !== 'object') {
    return;
  }
  Object.keys(source).forEach((rawKey) => {
    const resolvedKey = STAT_ALIASES[rawKey] || rawKey;
    if (!Object.prototype.hasOwnProperty.call(target, resolvedKey)) {
      return;
    }
    const number = Number(source[rawKey]);
    if (!Number.isFinite(number)) {
      return;
    }
    target[resolvedKey] = normalizeStatValue(resolvedKey, number, convertLegacyPercentages);
  });
}

function resolveCombatStats(summary = {}, options = {}) {
  const { defaults = getDefaultCombatStats(), convertLegacyPercentages = true } = options;
  const stats = { ...defaults };
  applyStatSource(stats, summary.finalStats || summary.stats || {}, convertLegacyPercentages);
  applyStatSource(stats, summary, convertLegacyPercentages);
  const combatStats = Array.isArray(summary.combatStats) ? summary.combatStats : [];
  combatStats.forEach((entry) => {
    if (!entry || typeof entry !== 'object' || !entry.key) {
      return;
    }
    const key = entry.key;
    const resolvedKey = STAT_ALIASES[key] || key;
    if (!Object.prototype.hasOwnProperty.call(stats, resolvedKey)) {
      return;
    }
    const value = Number(entry.value);
    const base = Number(entry.base);
    if (Number.isFinite(value)) {
      stats[resolvedKey] = normalizeStatValue(resolvedKey, value, convertLegacyPercentages);
    } else if (Number.isFinite(base)) {
      stats[resolvedKey] = normalizeStatValue(resolvedKey, base, convertLegacyPercentages);
    }
  });
  return stats;
}

function resolveSpecialStats(special = {}, options = {}) {
  const { defaults = getDefaultSpecialStats(), convertLegacyPercentages = true } = options;
  const resolved = { ...defaults };
  const limits = getStatBoundaries();
  if (!special || typeof special !== 'object') {
    return resolved;
  }
  Object.keys(resolved).forEach((key) => {
    if (!Object.prototype.hasOwnProperty.call(special, key)) {
      return;
    }
    const value = Number(special[key]);
    if (!Number.isFinite(value)) {
      return;
    }
    let normalized = value;
    if (convertLegacyPercentages && SPECIAL_PERCENT_KEYS.has(key) && Math.abs(value) > 1 && Math.abs(value) <= 1000) {
      normalized = value / 100;
    }
    switch (key) {
      case 'dodgeChance':
        resolved[key] = clamp(normalized, 0, limits.dodgeChanceMax);
        break;
      case 'damageReflection':
        resolved[key] = clamp(normalized, 0, limits.damageReflectionMax);
        break;
      case 'shield':
        resolved[key] = Math.max(0, normalized);
        break;
      default:
        resolved[key] = normalized;
        break;
    }
  });
  return resolved;
}

function createCombatantFromAttributes(attributes = {}, options = {}) {
  const stats = resolveCombatStats(
    { ...attributes, finalStats: attributes.finalStats, combatStats: attributes.combatStats },
    options
  );
  const special = resolveSpecialStats(attributes.skillSummary || attributes.special || {}, options);
  return { stats, special };
}

function extractCombatProfile(profile, options = {}) {
  if (!profile || typeof profile !== 'object') {
    return {
      stats: resolveCombatStats({}, options),
      special: resolveSpecialStats({}, options),
      combatPower: 0
    };
  }
  const attributeSummary = profile.attributeSummary || profile.attributes || {};
  const finalStats =
    attributeSummary.finalStats ||
    profile.finalStats ||
    (profile.derivedSummary && profile.derivedSummary.finalStats) ||
    {};
  const combatStats = Array.isArray(profile.combatStats) ? profile.combatStats : attributeSummary.combatStats;
  const stats = resolveCombatStats(
    {
      ...attributeSummary,
      finalStats,
      combatStats
    },
    options
  );
  const special = resolveSpecialStats(attributeSummary.skillSummary || profile.skillSummary || {}, options);
  const combatPower = Number(attributeSummary.combatPower || profile.combatPower || 0);
  return { stats, special, combatPower: Number.isFinite(combatPower) ? combatPower : 0 };
}

function executeAttack(attacker, attackerSpecial = {}, defender, defenderSpecial = {}, rng = Math.random) {
  const random = typeof rng === 'function' ? rng : Math.random;
  const offensiveSpecial = attackerSpecial || {};
  const defensiveSpecial = defenderSpecial || {};
  const curves = getLevelCurves();
  const hitConfig = curves.hitFormula || {};
  const penetrationConfig = curves.penetration || {};
  const baseDamageConfig = curves.baseDamage || {};
  const critConfig = curves.crit || {};
  const finalDamageConfig = curves.finalDamage || {};
  const healingConfig = curves.healing || {};

  const accuracy = Number(attacker.accuracy || 100) + Number(offensiveSpecial.accuracyBonus || 0);
  const dodge = Number(defender.dodge || 0);
  const baseHitChance = clamp(
    (hitConfig.base !== undefined ? hitConfig.base : 0.85) +
      (accuracy - dodge) * (hitConfig.slope !== undefined ? hitConfig.slope : 0.005),
    hitConfig.min !== undefined ? hitConfig.min : 0.2,
    hitConfig.max !== undefined ? hitConfig.max : 0.99
  );
  if (random() > baseHitChance) {
    return { dodged: true, damage: 0, crit: false, heal: 0, usingMagic: false };
  }
  const specialCaps = curves.specialCaps || {};
  const dodgeChanceMax = specialCaps.dodgeChanceMax !== undefined ? specialCaps.dodgeChanceMax : 0.8;
  if (random() < clamp(defensiveSpecial.dodgeChance || 0, 0, dodgeChanceMax)) {
    return { dodged: true, damage: 0, crit: false, heal: 0, usingMagic: false };
  }

  const physicalAttack = Math.max(0, Number(attacker.physicalAttack) || 0);
  const magicAttack = Math.max(0, Number(attacker.magicAttack) || 0);
  const physicalPenetrationRating = Math.max(0, Number(attacker.physicalPenetration) || 0);
  const magicPenetrationRating = Math.max(0, Number(attacker.magicPenetration) || 0);
  const physicalPenetration = clamp(
    physicalPenetrationRating * (penetrationConfig.scale || 0) + Number(offensiveSpecial.physicalPenetrationBonus || 0),
    0,
    penetrationConfig.max !== undefined ? penetrationConfig.max : 0.6
  );
  const magicPenetration = clamp(
    magicPenetrationRating * (penetrationConfig.scale || 0) + Number(offensiveSpecial.magicPenetrationBonus || 0),
    0,
    penetrationConfig.max !== undefined ? penetrationConfig.max : 0.6
  );

  const physicalDefense = Math.max(0, Number(defender.physicalDefense) || 0);
  const magicDefense = Math.max(0, Number(defender.magicDefense) || 0);
  const effectivePhysicalDefense = physicalDefense * (1 - physicalPenetration);
  const effectiveMagicDefense = magicDefense * (1 - magicPenetration);

  const basePhysical =
    physicalAttack > 0
      ? Math.max(
          physicalAttack * (baseDamageConfig.minAttackRatio !== undefined ? baseDamageConfig.minAttackRatio : 0.25),
          physicalAttack - effectivePhysicalDefense
        )
      : 0;
  const baseMagic =
    magicAttack > 0
      ? Math.max(
          magicAttack * (baseDamageConfig.minAttackRatio !== undefined ? baseDamageConfig.minAttackRatio : 0.25),
          magicAttack - effectiveMagicDefense
        )
      : 0;
  const usingMagic = baseMagic > basePhysical;
  let damage = usingMagic ? baseMagic : basePhysical;
  const randomMin = baseDamageConfig.randomMin !== undefined ? baseDamageConfig.randomMin : 0.9;
  const randomRange = baseDamageConfig.randomRange !== undefined ? baseDamageConfig.randomRange : 0.2;
  damage *= randomMin + random() * randomRange;

  const bonusDamage = Number(offensiveSpecial.bonusDamage) || 0;
  if (bonusDamage) {
    damage += bonusDamage;
  }

  const critChance = clamp(
    (Number(attacker.critRate) || 0) - (Number(defender.critResist) || 0),
    critConfig.min !== undefined ? critConfig.min : 0.05,
    critConfig.max !== undefined ? critConfig.max : 0.95
  );
  const crit = random() < critChance;
  if (crit) {
    const critDamageMin = critConfig.damageMin !== undefined ? critConfig.damageMin : getStatBoundaries().critDamageMin;
    damage *= Math.max(critDamageMin, Number(attacker.critDamage) || 1.5);
  }

  const finalDamageBonus = Number(attacker.finalDamageBonus) || 0;
  const finalDamageReduction = clamp(
    Number(defender.finalDamageReduction) || 0,
    finalDamageConfig.reductionClamp && finalDamageConfig.reductionClamp.min !== undefined
      ? finalDamageConfig.reductionClamp.min
      : 0,
    finalDamageConfig.reductionClamp && finalDamageConfig.reductionClamp.max !== undefined
      ? finalDamageConfig.reductionClamp.max
      : 0.9
  );
  const minFinalMultiplier = finalDamageConfig.minMultiplier !== undefined ? finalDamageConfig.minMultiplier : 0.1;
  const finalMultiplier = Math.max(minFinalMultiplier, 1 + finalDamageBonus - finalDamageReduction);
  damage *= finalMultiplier;

  damage = Math.max(baseDamageConfig.minDamage !== undefined ? baseDamageConfig.minDamage : 1, damage);

  const lifeSteal = clamp(
    Number(attacker.lifeSteal) || 0,
    0,
    healingConfig.lifeStealMax !== undefined ? healingConfig.lifeStealMax : 0.6
  );
  const healingBonus = Number(attacker.healingBonus) || 0;
  const healingReduction = Number(defender.healingReduction) || 0;
  const healingMultiplier = clamp(
    1 + healingBonus - healingReduction,
    healingConfig.multiplierClamp && healingConfig.multiplierClamp.min !== undefined
      ? healingConfig.multiplierClamp.min
      : 0,
    healingConfig.multiplierClamp && healingConfig.multiplierClamp.max !== undefined
      ? healingConfig.multiplierClamp.max
      : 2
  );
  let heal = Math.max(0, damage * lifeSteal * healingMultiplier);
  const healOnHit = Number(offensiveSpecial.healOnHit) || 0;
  if (healOnHit) {
    heal += healOnHit;
  }

  return { damage, crit, dodged: false, heal, usingMagic };
}

function calculateCombatPower(stats, special = {}) {
  if (!stats) return 0;
  const limits = getStatBoundaries();
  const maxHp = toNumber(stats.maxHp);
  const physicalAttack = toNumber(stats.physicalAttack);
  const magicAttack = toNumber(stats.magicAttack);
  const physicalDefense = toNumber(stats.physicalDefense);
  const magicDefense = toNumber(stats.magicDefense);
  const speed = toNumber(stats.speed);
  const accuracy = toNumber(stats.accuracy);
  const dodge = toNumber(stats.dodge);
  const critRate = clamp(toNumber(stats.critRate), limits.critRateMin, limits.critRateMax);
  const critDamage = Math.max(limits.critDamageMin, toNumber(stats.critDamage) || 1.5);
  const critResist = toNumber(stats.critResist);
  const finalDamageBonus = toNumber(stats.finalDamageBonus);
  const finalDamageReduction = clamp(
    toNumber(stats.finalDamageReduction),
    limits.finalDamageReductionMin,
    limits.finalDamageReductionMax
  );
  const lifeSteal = clamp(toNumber(stats.lifeSteal), 0, limits.lifeStealMax);
  const healingBonus = toNumber(stats.healingBonus);
  const controlHit = toNumber(stats.controlHit);
  const controlResist = toNumber(stats.controlResist);
  const physicalPenetration = toNumber(stats.physicalPenetration);
  const magicPenetration = toNumber(stats.magicPenetration);
  const comboRate = clamp(toNumber(stats.comboRate), 0, limits.comboRateMax);
  const block = clamp(toNumber(stats.block), 0, limits.blockMax);
  const counterRate = clamp(toNumber(stats.counterRate), 0, limits.counterRateMax);
  const damageReduction = clamp(toNumber(stats.damageReduction), 0, limits.damageReductionMax);
  const healingReceived = clamp(
    toNumber(stats.healingReceived),
    limits.healingReceivedMin,
    limits.healingReceivedMax
  );
  const rageGain = toNumber(stats.rageGain);
  const controlStrength = toNumber(stats.controlStrength);
  const shieldPower = toNumber(stats.shieldPower);
  const summonPower = toNumber(stats.summonPower);
  const elementalVulnerability = toNumber(stats.elementalVulnerability);
  const shield = toNumber(special.shield);
  const bonusDamage = toNumber(special.bonusDamage);
  const dodgeChance = toNumber(special.dodgeChance);

  const power =
    maxHp * 0.35 +
    (physicalAttack + magicAttack) * 1.8 +
    (physicalDefense + magicDefense) * 1.45 +
    speed * 1.2 +
    accuracy * 0.9 +
    dodge * 2.5 +
    critRate * 520 +
    (critDamage - 1) * 180 +
    finalDamageBonus * 650 -
    finalDamageReduction * 480 +
    critResist * 360 +
    lifeSteal * 420 +
    healingBonus * 380 +
    controlHit * 1.1 +
    controlResist * 1.1 +
    physicalPenetration * 2.2 +
    magicPenetration * 2.2 +
    comboRate * 520 +
    block * 380 +
    counterRate * 480 +
    damageReduction * 360 +
    healingReceived * 340 +
    rageGain * 320 +
    controlStrength * 300 +
    shieldPower * 260 +
    summonPower * 240 +
    elementalVulnerability * 320 +
    shield * 0.25 +
    bonusDamage * 1.4 +
    dodgeChance * 620;
  return Math.round(power);
}

function toFiniteNumber(value) {
  if (value === null || value === undefined) {
    return null;
  }
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === 'string') {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  if (typeof value !== 'object') {
    return null;
  }
  if (Number.isFinite(value.speed)) {
    return Number(value.speed);
  }
  return null;
}

function resolveSpeedValue(source, visited = new Set()) {
  if (source === null || source === undefined) {
    return null;
  }
  if (typeof source !== 'object') {
    return toFiniteNumber(source);
  }
  if (visited.has(source)) {
    return null;
  }
  visited.add(source);

  const direct = toFiniteNumber(source);
  if (direct !== null) {
    return direct;
  }

  const directSpeed = toFiniteNumber(source.speed);
  if (directSpeed !== null) {
    return directSpeed;
  }

  const candidateKeys = [
    'stats',
    'combatant',
    'baseStats',
    'finalStats',
    'attributes',
    'attributeTotals',
    'attributeSummary',
    'state',
    'player',
    'opponent',
    'enemy',
    'target'
  ];

  for (let i = 0; i < candidateKeys.length; i += 1) {
    const key = candidateKeys[i];
    if (!Object.prototype.hasOwnProperty.call(source, key)) {
      continue;
    }
    const nested = source[key];
    if (nested === null || nested === undefined) {
      continue;
    }
    if (typeof nested === 'object') {
      const resolved = resolveSpeedValue(nested, visited);
      if (resolved !== null) {
        return resolved;
      }
    } else {
      const resolved = toFiniteNumber(nested);
      if (resolved !== null) {
        return resolved;
      }
    }
  }

  if (Array.isArray(source)) {
    for (let i = 0; i < source.length; i += 1) {
      const value = source[i];
      const resolved = resolveSpeedValue(value, visited);
      if (resolved !== null) {
        return resolved;
      }
    }
  }

  const values = Object.values(source);
  for (let i = 0; i < values.length; i += 1) {
    const resolved = resolveSpeedValue(values[i], visited);
    if (resolved !== null) {
      return resolved;
    }
  }

  return null;
}

function determineRoundOrder(playerSource, opponentSource, options = {}) {
  const {
    fallbackFirst = 'player',
    playerKey = 'player',
    opponentKey = 'opponent'
  } = options;

  const playerSpeed = resolveSpeedValue(playerSource);
  const opponentSpeed = resolveSpeedValue(opponentSource);

  const fallbackNormalized = typeof fallbackFirst === 'string' ? fallbackFirst.toLowerCase() : 'player';
  let firstSide = fallbackNormalized === 'opponent' || fallbackNormalized === 'enemy' ? 'opponent' : 'player';

  if (playerSpeed !== null && opponentSpeed !== null) {
    if (playerSpeed > opponentSpeed) {
      firstSide = 'player';
    } else if (playerSpeed < opponentSpeed) {
      firstSide = 'opponent';
    }
  } else if (playerSpeed !== null) {
    firstSide = 'player';
  } else if (opponentSpeed !== null) {
    firstSide = 'opponent';
  }

  const order = firstSide === 'player' ? [playerKey, opponentKey] : [opponentKey, playerKey];

  return {
    order,
    firstSide,
    playerSpeed,
    opponentSpeed
  };
}

module.exports = {
  DEFAULT_COMBAT_STATS,
  DEFAULT_SPECIAL_STATS,
  clamp,
  resolveCombatStats,
  resolveSpecialStats,
  createCombatantFromAttributes,
  extractCombatProfile,
  executeAttack,
  calculateCombatPower,
  determineRoundOrder,
  resolveSpeedValue
};
