'use strict';

const DEFAULT_COMBAT_STATS = {
  maxHp: 2860,
  physicalAttack: 82,
  magicAttack: 82,
  physicalDefense: 61,
  magicDefense: 61,
  speed: 92,
  accuracy: 112,
  dodge: 96,
  critRate: 0.062,
  critDamage: 1.52,
  finalDamageBonus: 0,
  finalDamageReduction: 0.024,
  lifeSteal: 0,
  healingBonus: 0.08,
  healingReduction: 0,
  controlHit: 11,
  controlResist: 11,
  physicalPenetration: 1,
  magicPenetration: 1,
  critResist: 0.0184,
  comboRate: 0,
  block: 0,
  counterRate: 0,
  damageReduction: 0,
  healingReceived: 0,
  rageGain: 0,
  controlStrength: 0,
  shieldPower: 0,
  summonPower: 0,
  elementalVulnerability: 0
};

const DEFAULT_SPECIAL_STATS = {
  shield: 0,
  bonusDamage: 0,
  dodgeChance: 0,
  healOnHit: 0,
  healOnKill: 0,
  damageReflection: 0,
  accuracyBonus: 0,
  speedBonus: 0,
  physicalPenetrationBonus: 0,
  magicPenetrationBonus: 0
};

const STAT_ALIASES = {
  hp: 'maxHp',
  health: 'maxHp',
  maxHP: 'maxHp',
  attack: 'physicalAttack',
  physicalAtk: 'physicalAttack',
  physicalATK: 'physicalAttack',
  weaponAttack: 'physicalAttack',
  spellAttack: 'magicAttack',
  magicAtk: 'magicAttack',
  magicATK: 'magicAttack',
  defense: 'physicalDefense',
  armor: 'physicalDefense',
  resistance: 'magicDefense',
  magicResist: 'magicDefense',
  hitRate: 'accuracy',
  accuracyRate: 'accuracy',
  evasion: 'dodge',
  dodgeRate: 'dodge',
  criticalRate: 'critRate',
  critical: 'critRate',
  crit: 'critRate',
  criticalDamage: 'critDamage',
  critDamageRate: 'critDamage',
  finalDamage: 'finalDamageBonus',
  finalReduce: 'finalDamageReduction',
  damageReduce: 'finalDamageReduction',
  armorPenetration: 'physicalPenetration',
  armorPen: 'physicalPenetration',
  spellPenetration: 'magicPenetration',
  spellPen: 'magicPenetration',
  magicPen: 'magicPenetration'
};

const LEGACY_PERCENT_KEYS = new Set([
  'critRate',
  'finalDamageBonus',
  'finalDamageReduction',
  'lifeSteal',
  'healingBonus',
  'healingReduction',
  'controlHit',
  'controlResist',
  'critResist',
  'comboRate',
  'block',
  'counterRate',
  'damageReduction',
  'healingReceived',
  'rageGain',
  'controlStrength',
  'shieldPower',
  'summonPower',
  'elementalVulnerability'
]);

const SPECIAL_PERCENT_KEYS = new Set(['dodgeChance', 'damageReflection']);

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function toNumber(value) {
  const number = Number(value);
  return Number.isFinite(number) ? number : 0;
}

function normalizeStatValue(key, value, convertLegacyPercentages) {
  let normalized = value;
  if (convertLegacyPercentages) {
    if (key === 'critRate') {
      normalized = value > 1 ? value / 100 : value;
    } else if (key === 'critDamage') {
      normalized = value >= 3 ? 1.5 + value / 100 : value;
    } else if (LEGACY_PERCENT_KEYS.has(key) && Math.abs(value) > 1 && Math.abs(value) <= 1000) {
      normalized = value / 100;
    }
  }
  switch (key) {
    case 'critRate':
      return clamp(normalized, 0, 0.95);
    case 'critDamage':
      return Math.max(1.2, normalized);
    case 'finalDamageBonus':
      return clamp(normalized, -0.9, 2);
    case 'finalDamageReduction':
      return clamp(normalized, 0, 0.9);
    case 'lifeSteal':
      return clamp(normalized, 0, 0.6);
    case 'healingBonus':
    case 'healingReduction':
      return clamp(normalized, -1, 1.5);
    case 'damageReduction':
      return clamp(normalized, 0, 0.8);
    case 'healingReceived':
      return clamp(normalized, -0.5, 1.5);
    case 'comboRate':
    case 'block':
    case 'counterRate':
      return clamp(normalized, 0, 1);
    case 'critResist':
    case 'controlHit':
    case 'controlResist':
    case 'rageGain':
    case 'controlStrength':
    case 'shieldPower':
    case 'summonPower':
    case 'elementalVulnerability':
      return normalized;
    default:
      return normalized;
  }
}

function applyStatSource(target, source, convertLegacyPercentages) {
  if (!source || typeof source !== 'object') {
    return;
  }
  Object.keys(source).forEach((rawKey) => {
    const resolvedKey = STAT_ALIASES[rawKey] || rawKey;
    if (!Object.prototype.hasOwnProperty.call(target, resolvedKey)) {
      return;
    }
    const number = Number(source[rawKey]);
    if (!Number.isFinite(number)) {
      return;
    }
    target[resolvedKey] = normalizeStatValue(resolvedKey, number, convertLegacyPercentages);
  });
}

function resolveCombatStats(summary = {}, options = {}) {
  const { defaults = DEFAULT_COMBAT_STATS, convertLegacyPercentages = true } = options;
  const stats = { ...defaults };
  applyStatSource(stats, summary.finalStats || summary.stats || {}, convertLegacyPercentages);
  applyStatSource(stats, summary, convertLegacyPercentages);
  const combatStats = Array.isArray(summary.combatStats) ? summary.combatStats : [];
  combatStats.forEach((entry) => {
    if (!entry || typeof entry !== 'object' || !entry.key) {
      return;
    }
    const key = entry.key;
    const resolvedKey = STAT_ALIASES[key] || key;
    if (!Object.prototype.hasOwnProperty.call(stats, resolvedKey)) {
      return;
    }
    const value = Number(entry.value);
    const base = Number(entry.base);
    if (Number.isFinite(value)) {
      stats[resolvedKey] = normalizeStatValue(resolvedKey, value, convertLegacyPercentages);
    } else if (Number.isFinite(base)) {
      stats[resolvedKey] = normalizeStatValue(resolvedKey, base, convertLegacyPercentages);
    }
  });
  return stats;
}

function resolveSpecialStats(special = {}, options = {}) {
  const { defaults = DEFAULT_SPECIAL_STATS, convertLegacyPercentages = true } = options;
  const resolved = { ...defaults };
  if (!special || typeof special !== 'object') {
    return resolved;
  }
  Object.keys(resolved).forEach((key) => {
    if (!Object.prototype.hasOwnProperty.call(special, key)) {
      return;
    }
    const value = Number(special[key]);
    if (!Number.isFinite(value)) {
      return;
    }
    let normalized = value;
    if (convertLegacyPercentages && SPECIAL_PERCENT_KEYS.has(key) && Math.abs(value) > 1 && Math.abs(value) <= 1000) {
      normalized = value / 100;
    }
    switch (key) {
      case 'dodgeChance':
        resolved[key] = clamp(normalized, 0, 0.8);
        break;
      case 'damageReflection':
        resolved[key] = clamp(normalized, 0, 0.8);
        break;
      case 'shield':
        resolved[key] = Math.max(0, normalized);
        break;
      default:
        resolved[key] = normalized;
        break;
    }
  });
  return resolved;
}

function createCombatantFromAttributes(attributes = {}, options = {}) {
  const stats = resolveCombatStats(
    { ...attributes, finalStats: attributes.finalStats, combatStats: attributes.combatStats },
    options
  );
  const special = resolveSpecialStats(attributes.skillSummary || attributes.special || {}, options);
  return { stats, special };
}

function extractCombatProfile(profile, options = {}) {
  if (!profile || typeof profile !== 'object') {
    return {
      stats: resolveCombatStats({}, options),
      special: resolveSpecialStats({}, options),
      combatPower: 0
    };
  }
  const attributeSummary = profile.attributeSummary || profile.attributes || {};
  const finalStats =
    attributeSummary.finalStats ||
    profile.finalStats ||
    (profile.derivedSummary && profile.derivedSummary.finalStats) ||
    {};
  const combatStats = Array.isArray(profile.combatStats) ? profile.combatStats : attributeSummary.combatStats;
  const stats = resolveCombatStats(
    {
      ...attributeSummary,
      finalStats,
      combatStats
    },
    options
  );
  const special = resolveSpecialStats(attributeSummary.skillSummary || profile.skillSummary || {}, options);
  const combatPower = Number(attributeSummary.combatPower || profile.combatPower || 0);
  return { stats, special, combatPower: Number.isFinite(combatPower) ? combatPower : 0 };
}

function executeAttack(attacker, attackerSpecial = {}, defender, defenderSpecial = {}, rng = Math.random) {
  const random = typeof rng === 'function' ? rng : Math.random;
  const offensiveSpecial = attackerSpecial || {};
  const defensiveSpecial = defenderSpecial || {};

  const accuracy = Number(attacker.accuracy || 100) + Number(offensiveSpecial.accuracyBonus || 0);
  const dodge = Number(defender.dodge || 0);
  const baseHitChance = clamp(0.85 + (accuracy - dodge) * 0.005, 0.2, 0.99);
  if (random() > baseHitChance) {
    return { dodged: true, damage: 0, crit: false, heal: 0, usingMagic: false };
  }
  if (random() < clamp(defensiveSpecial.dodgeChance || 0, 0, 0.8)) {
    return { dodged: true, damage: 0, crit: false, heal: 0, usingMagic: false };
  }

  const physicalAttack = Math.max(0, Number(attacker.physicalAttack) || 0);
  const magicAttack = Math.max(0, Number(attacker.magicAttack) || 0);
  const physicalPenetrationRating = Math.max(0, Number(attacker.physicalPenetration) || 0);
  const magicPenetrationRating = Math.max(0, Number(attacker.magicPenetration) || 0);
  const physicalPenetration = clamp(
    physicalPenetrationRating * 0.005 + Number(offensiveSpecial.physicalPenetrationBonus || 0),
    0,
    0.6
  );
  const magicPenetration = clamp(
    magicPenetrationRating * 0.005 + Number(offensiveSpecial.magicPenetrationBonus || 0),
    0,
    0.6
  );

  const physicalDefense = Math.max(0, Number(defender.physicalDefense) || 0);
  const magicDefense = Math.max(0, Number(defender.magicDefense) || 0);
  const effectivePhysicalDefense = physicalDefense * (1 - physicalPenetration);
  const effectiveMagicDefense = magicDefense * (1 - magicPenetration);

  const basePhysical =
    physicalAttack > 0 ? Math.max(physicalAttack * 0.25, physicalAttack - effectivePhysicalDefense) : 0;
  const baseMagic = magicAttack > 0 ? Math.max(magicAttack * 0.25, magicAttack - effectiveMagicDefense) : 0;
  const usingMagic = baseMagic > basePhysical;
  let damage = usingMagic ? baseMagic : basePhysical;
  damage *= 0.9 + random() * 0.2;

  const bonusDamage = Number(offensiveSpecial.bonusDamage) || 0;
  if (bonusDamage) {
    damage += bonusDamage;
  }

  const critChance = clamp((Number(attacker.critRate) || 0) - (Number(defender.critResist) || 0), 0.05, 0.95);
  const crit = random() < critChance;
  if (crit) {
    damage *= Math.max(1.2, Number(attacker.critDamage) || 1.5);
  }

  const finalDamageBonus = Number(attacker.finalDamageBonus) || 0;
  const finalDamageReduction = clamp(Number(defender.finalDamageReduction) || 0, 0, 0.9);
  const finalMultiplier = Math.max(0.1, 1 + finalDamageBonus - finalDamageReduction);
  damage *= finalMultiplier;

  damage = Math.max(1, damage);

  const lifeSteal = clamp(Number(attacker.lifeSteal) || 0, 0, 0.6);
  const healingBonus = Number(attacker.healingBonus) || 0;
  const healingReduction = Number(defender.healingReduction) || 0;
  const healingMultiplier = clamp(1 + healingBonus - healingReduction, 0, 2);
  let heal = Math.max(0, damage * lifeSteal * healingMultiplier);
  const healOnHit = Number(offensiveSpecial.healOnHit) || 0;
  if (healOnHit) {
    heal += healOnHit;
  }

  return { damage, crit, dodged: false, heal, usingMagic };
}

function calculateCombatPower(stats, special = {}) {
  if (!stats) return 0;
  const maxHp = toNumber(stats.maxHp);
  const physicalAttack = toNumber(stats.physicalAttack);
  const magicAttack = toNumber(stats.magicAttack);
  const physicalDefense = toNumber(stats.physicalDefense);
  const magicDefense = toNumber(stats.magicDefense);
  const speed = toNumber(stats.speed);
  const accuracy = toNumber(stats.accuracy);
  const dodge = toNumber(stats.dodge);
  const critRate = clamp(toNumber(stats.critRate), 0, 0.95);
  const critDamage = Math.max(1.2, toNumber(stats.critDamage) || 1.5);
  const critResist = toNumber(stats.critResist);
  const finalDamageBonus = toNumber(stats.finalDamageBonus);
  const finalDamageReduction = clamp(toNumber(stats.finalDamageReduction), 0, 0.9);
  const lifeSteal = clamp(toNumber(stats.lifeSteal), 0, 0.6);
  const healingBonus = toNumber(stats.healingBonus);
  const controlHit = toNumber(stats.controlHit);
  const controlResist = toNumber(stats.controlResist);
  const physicalPenetration = toNumber(stats.physicalPenetration);
  const magicPenetration = toNumber(stats.magicPenetration);
  const comboRate = toNumber(stats.comboRate);
  const block = toNumber(stats.block);
  const counterRate = toNumber(stats.counterRate);
  const damageReduction = toNumber(stats.damageReduction);
  const healingReceived = toNumber(stats.healingReceived);
  const rageGain = toNumber(stats.rageGain);
  const controlStrength = toNumber(stats.controlStrength);
  const shieldPower = toNumber(stats.shieldPower);
  const summonPower = toNumber(stats.summonPower);
  const elementalVulnerability = toNumber(stats.elementalVulnerability);
  const shield = toNumber(special.shield);
  const bonusDamage = toNumber(special.bonusDamage);
  const dodgeChance = toNumber(special.dodgeChance);

  const power =
    maxHp * 0.35 +
    (physicalAttack + magicAttack) * 1.8 +
    (physicalDefense + magicDefense) * 1.45 +
    speed * 1.2 +
    accuracy * 0.9 +
    dodge * 2.5 +
    critRate * 520 +
    (critDamage - 1) * 180 +
    finalDamageBonus * 650 -
    finalDamageReduction * 480 +
    critResist * 360 +
    lifeSteal * 420 +
    healingBonus * 380 +
    controlHit * 1.1 +
    controlResist * 1.1 +
    physicalPenetration * 2.2 +
    magicPenetration * 2.2 +
    comboRate * 520 +
    block * 380 +
    counterRate * 480 +
    damageReduction * 360 +
    healingReceived * 340 +
    rageGain * 320 +
    controlStrength * 300 +
    shieldPower * 260 +
    summonPower * 240 +
    elementalVulnerability * 320 +
    shield * 0.25 +
    bonusDamage * 1.4 +
    dodgeChance * 620;
  return Math.round(power);
}

function toFiniteNumber(value) {
  if (value === null || value === undefined) {
    return null;
  }
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === 'string') {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  if (typeof value !== 'object') {
    return null;
  }
  if (Number.isFinite(value.speed)) {
    return Number(value.speed);
  }
  return null;
}

function resolveSpeedValue(source, visited = new Set()) {
  if (source === null || source === undefined) {
    return null;
  }
  if (typeof source !== 'object') {
    return toFiniteNumber(source);
  }
  if (visited.has(source)) {
    return null;
  }
  visited.add(source);

  const direct = toFiniteNumber(source);
  if (direct !== null) {
    return direct;
  }

  const directSpeed = toFiniteNumber(source.speed);
  if (directSpeed !== null) {
    return directSpeed;
  }

  const candidateKeys = [
    'stats',
    'combatant',
    'baseStats',
    'finalStats',
    'attributes',
    'attributeTotals',
    'attributeSummary',
    'state',
    'player',
    'opponent',
    'enemy',
    'target'
  ];

  for (let i = 0; i < candidateKeys.length; i += 1) {
    const key = candidateKeys[i];
    if (!Object.prototype.hasOwnProperty.call(source, key)) {
      continue;
    }
    const nested = source[key];
    if (nested === null || nested === undefined) {
      continue;
    }
    if (typeof nested === 'object') {
      const resolved = resolveSpeedValue(nested, visited);
      if (resolved !== null) {
        return resolved;
      }
    } else {
      const resolved = toFiniteNumber(nested);
      if (resolved !== null) {
        return resolved;
      }
    }
  }

  if (Array.isArray(source)) {
    for (let i = 0; i < source.length; i += 1) {
      const value = source[i];
      const resolved = resolveSpeedValue(value, visited);
      if (resolved !== null) {
        return resolved;
      }
    }
  }

  const values = Object.values(source);
  for (let i = 0; i < values.length; i += 1) {
    const resolved = resolveSpeedValue(values[i], visited);
    if (resolved !== null) {
      return resolved;
    }
  }

  return null;
}

function determineRoundOrder(playerSource, opponentSource, options = {}) {
  const {
    fallbackFirst = 'player',
    playerKey = 'player',
    opponentKey = 'opponent'
  } = options;

  const playerSpeed = resolveSpeedValue(playerSource);
  const opponentSpeed = resolveSpeedValue(opponentSource);

  const fallbackNormalized = typeof fallbackFirst === 'string' ? fallbackFirst.toLowerCase() : 'player';
  let firstSide = fallbackNormalized === 'opponent' || fallbackNormalized === 'enemy' ? 'opponent' : 'player';

  if (playerSpeed !== null && opponentSpeed !== null) {
    if (playerSpeed > opponentSpeed) {
      firstSide = 'player';
    } else if (playerSpeed < opponentSpeed) {
      firstSide = 'opponent';
    }
  } else if (playerSpeed !== null) {
    firstSide = 'player';
  } else if (opponentSpeed !== null) {
    firstSide = 'opponent';
  }

  const order = firstSide === 'player' ? [playerKey, opponentKey] : [opponentKey, playerKey];

  return {
    order,
    firstSide,
    playerSpeed,
    opponentSpeed
  };
}

module.exports = {
  DEFAULT_COMBAT_STATS,
  DEFAULT_SPECIAL_STATS,
  clamp,
  resolveCombatStats,
  resolveSpecialStats,
  createCombatantFromAttributes,
  extractCombatProfile,
  executeAttack,
  calculateCombatPower,
  determineRoundOrder,
  resolveSpeedValue
};
